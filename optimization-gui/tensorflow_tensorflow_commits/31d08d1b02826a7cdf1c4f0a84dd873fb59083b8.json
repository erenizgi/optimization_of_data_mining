{
    "author": "tensorflower-gardener",
    "message": "[SymbolicExpr] Make AffineToSymbolicExpr public to be used in IndexingMap constructor\n\n- Make it public\n- Rename to AffineToSymbolicExpr\n- Added a test\n\nPiperOrigin-RevId: 808589400",
    "sha": "31d08d1b02826a7cdf1c4f0a84dd873fb59083b8",
    "files": [
        {
            "sha": "cdb42caab43c67cd80dc71562f94f5a79a04bc40",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_converter.cc",
            "status": "modified",
            "additions": 44,
            "deletions": 44,
            "changes": 88,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/31d08d1b02826a7cdf1c4f0a84dd873fb59083b8/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/31d08d1b02826a7cdf1c4f0a84dd873fb59083b8/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.cc?ref=31d08d1b02826a7cdf1c4f0a84dd873fb59083b8",
            "patch": "@@ -31,48 +31,6 @@ namespace xla {\n namespace gpu {\n namespace {\n \n-// Helper function to convert mlir::AffineExpr to xla::gpu::SymbolicExpr.\n-SymbolicExpr AffineToSymbolic(mlir::AffineExpr affine_expr,\n-                              SymbolicExprContext* context, int num_dims) {\n-  switch (affine_expr.getKind()) {\n-    case mlir::AffineExprKind::Constant:\n-      return context->CreateConstant(\n-          mlir::cast<mlir::AffineConstantExpr>(affine_expr).getValue());\n-    case mlir::AffineExprKind::DimId:\n-      return context->CreateVariable(\n-          mlir::cast<mlir::AffineDimExpr>(affine_expr).getPosition());\n-    case mlir::AffineExprKind::SymbolId:\n-      return context->CreateVariable(\n-          mlir::cast<mlir::AffineSymbolExpr>(affine_expr).getPosition() +\n-          num_dims);\n-    case mlir::AffineExprKind::Add: {\n-      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineToSymbolic(bin_op.getLHS(), context, num_dims) +\n-             AffineToSymbolic(bin_op.getRHS(), context, num_dims);\n-    }\n-    case mlir::AffineExprKind::Mul: {\n-      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineToSymbolic(bin_op.getLHS(), context, num_dims) *\n-             AffineToSymbolic(bin_op.getRHS(), context, num_dims);\n-    }\n-    case mlir::AffineExprKind::FloorDiv: {\n-      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineToSymbolic(bin_op.getLHS(), context, num_dims)\n-          .floorDiv(AffineToSymbolic(bin_op.getRHS(), context, num_dims));\n-    }\n-    case mlir::AffineExprKind::CeilDiv: {\n-      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineToSymbolic(bin_op.getLHS(), context, num_dims)\n-          .ceilDiv(AffineToSymbolic(bin_op.getRHS(), context, num_dims));\n-    }\n-    case mlir::AffineExprKind::Mod: {\n-      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n-      return AffineToSymbolic(bin_op.getLHS(), context, num_dims) %\n-             AffineToSymbolic(bin_op.getRHS(), context, num_dims);\n-    }\n-  }\n-}\n-\n // Helper function to convert xla::gpu::SymbolicExpr to mlir::AffineExpr.\n mlir::AffineExpr SymbolicToAffine(SymbolicExpr symbolic_expr,\n                                   mlir::MLIRContext* context, int num_dims) {\n@@ -115,13 +73,55 @@ mlir::AffineExpr SymbolicToAffine(SymbolicExpr symbolic_expr,\n \n }  // namespace\n \n+// Helper function to convert mlir::AffineExpr to xla::gpu::SymbolicExpr.\n+SymbolicExpr AffineToSymbolicExpr(mlir::AffineExpr affine_expr,\n+                                  SymbolicExprContext* context, int num_dims) {\n+  switch (affine_expr.getKind()) {\n+    case mlir::AffineExprKind::Constant:\n+      return context->CreateConstant(\n+          mlir::cast<mlir::AffineConstantExpr>(affine_expr).getValue());\n+    case mlir::AffineExprKind::DimId:\n+      return context->CreateVariable(\n+          mlir::cast<mlir::AffineDimExpr>(affine_expr).getPosition());\n+    case mlir::AffineExprKind::SymbolId:\n+      return context->CreateVariable(\n+          mlir::cast<mlir::AffineSymbolExpr>(affine_expr).getPosition() +\n+          num_dims);\n+    case mlir::AffineExprKind::Add: {\n+      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n+      return AffineToSymbolicExpr(bin_op.getLHS(), context, num_dims) +\n+             AffineToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n+    }\n+    case mlir::AffineExprKind::Mul: {\n+      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n+      return AffineToSymbolicExpr(bin_op.getLHS(), context, num_dims) *\n+             AffineToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n+    }\n+    case mlir::AffineExprKind::FloorDiv: {\n+      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n+      return AffineToSymbolicExpr(bin_op.getLHS(), context, num_dims)\n+          .floorDiv(AffineToSymbolicExpr(bin_op.getRHS(), context, num_dims));\n+    }\n+    case mlir::AffineExprKind::CeilDiv: {\n+      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n+      return AffineToSymbolicExpr(bin_op.getLHS(), context, num_dims)\n+          .ceilDiv(AffineToSymbolicExpr(bin_op.getRHS(), context, num_dims));\n+    }\n+    case mlir::AffineExprKind::Mod: {\n+      auto bin_op = mlir::cast<mlir::AffineBinaryOpExpr>(affine_expr);\n+      return AffineToSymbolicExpr(bin_op.getLHS(), context, num_dims) %\n+             AffineToSymbolicExpr(bin_op.getRHS(), context, num_dims);\n+    }\n+  }\n+}\n+\n SymbolicMap AffineMapToSymbolicMap(const mlir::AffineMap& affine_map,\n                                    SymbolicExprContext* context) {\n   llvm::SmallVector<SymbolicExpr> results;\n   results.reserve(affine_map.getNumResults());\n   int num_dims = affine_map.getNumDims();\n   for (mlir::AffineExpr expr : affine_map.getResults()) {\n-    results.push_back(AffineToSymbolic(expr, context, num_dims));\n+    results.push_back(AffineToSymbolicExpr(expr, context, num_dims));\n   }\n   return SymbolicMap::Get(context, num_dims, affine_map.getNumSymbols(),\n                           results);\n@@ -152,7 +152,7 @@ ConvertAffineConstraintsToSymbolicConstraints(\n     SymbolicExprContext* context, int num_dims) {\n   llvm::MapVector<SymbolicExpr, Interval> symbolic_constraints;\n   for (const auto& [affine_expr, interval] : affine_constraints) {\n-    SymbolicExpr expr = AffineToSymbolic(affine_expr, context, num_dims);\n+    SymbolicExpr expr = AffineToSymbolicExpr(affine_expr, context, num_dims);\n     symbolic_constraints[expr] = interval;\n   }\n   return symbolic_constraints;"
        },
        {
            "sha": "8bc7f1ff3bed33be562743cc58358143a756ca16",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_converter.h",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/31d08d1b02826a7cdf1c4f0a84dd873fb59083b8/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/31d08d1b02826a7cdf1c4f0a84dd873fb59083b8/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter.h?ref=31d08d1b02826a7cdf1c4f0a84dd873fb59083b8",
            "patch": "@@ -27,6 +27,10 @@ limitations under the License.\n namespace xla {\n namespace gpu {\n \n+// Helper function to convert mlir::AffineExpr to xla::gpu::SymbolicExpr.\n+SymbolicExpr AffineToSymbolicExpr(::mlir::AffineExpr affine_expr,\n+                                  SymbolicExprContext* context, int num_dims);\n+\n // Converts an mlir::AffineMap to xla::gpu::SymbolicMap.\n SymbolicMap AffineMapToSymbolicMap(const mlir::AffineMap& affine_map,\n                                    SymbolicExprContext* context);"
        },
        {
            "sha": "03395354c9274db1452818aecfd1d2bd8dd7cf2c",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_converter_test.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/31d08d1b02826a7cdf1c4f0a84dd873fb59083b8/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/31d08d1b02826a7cdf1c4f0a84dd873fb59083b8/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc?ref=31d08d1b02826a7cdf1c4f0a84dd873fb59083b8",
            "patch": "@@ -110,6 +110,40 @@ TEST(SymbolicMapConverterTest, ConvertAffineConstraintsToSymbolicConstraints) {\n   EXPECT_EQ(symbolic_constraints[sym_d0 - sym_c1], (Interval{10, 20}));\n }\n \n+TEST(AffineToSymbolicExprTest, ConvertAffineToSymbolicExpr) {\n+  MLIRContext mlir_context;\n+  SymbolicExprContext symbolic_context;\n+\n+  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &mlir_context);\n+  mlir::AffineExpr d1 = mlir::getAffineDimExpr(1, &mlir_context);\n+  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &mlir_context);\n+  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &mlir_context);\n+  mlir::AffineExpr c2 = mlir::getAffineConstantExpr(2, &mlir_context);\n+  mlir::AffineExpr c3 = mlir::getAffineConstantExpr(3, &mlir_context);\n+\n+  mlir::AffineExpr affine_expr =\n+      mlir::getAffineBinaryOpExpr(\n+          mlir::AffineExprKind::Mod,\n+          mlir::getAffineBinaryOpExpr(mlir::AffineExprKind::FloorDiv,\n+                                      d0 * c2 + s0 - c1, c2),\n+          c3) +\n+      d1;  // ((d0 * 2 + s0 - 1) floordiv 2) mod 3 + d1\n+\n+  SymbolicExpr exp_d0 = symbolic_context.CreateVariable(0);\n+  SymbolicExpr exp_d1 = symbolic_context.CreateVariable(1);\n+  SymbolicExpr exp_s0 = symbolic_context.CreateVariable(2);\n+  SymbolicExpr exp_c1 = symbolic_context.CreateConstant(1);\n+  SymbolicExpr exp_c2 = symbolic_context.CreateConstant(2);\n+  SymbolicExpr exp_c3 = symbolic_context.CreateConstant(3);\n+\n+  SymbolicExpr expected_symbolic_expr =\n+      ((exp_d0 * exp_c2 + exp_s0 - exp_c1) / exp_c2) % exp_c3 + exp_d1;\n+\n+  EXPECT_EQ(\n+      AffineToSymbolicExpr(affine_expr, &symbolic_context, /*num_dims=*/2),\n+      expected_symbolic_expr);\n+}\n+\n }  // namespace\n }  // namespace gpu\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 126,
        "additions": 82,
        "deletions": 44
    }
}