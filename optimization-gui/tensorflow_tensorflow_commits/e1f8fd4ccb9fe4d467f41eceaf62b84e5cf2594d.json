{
    "author": "mwhittaker",
    "message": "Add Google-specific signal handling.\n\nPiperOrigin-RevId: 845939788",
    "sha": "e1f8fd4ccb9fe4d467f41eceaf62b84e5cf2594d",
    "files": [
        {
            "sha": "e25a85a40e4d3856984920a3f6ba38acbb423b0b",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_notifier.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e1f8fd4ccb9fe4d467f41eceaf62b84e5cf2594d/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e1f8fd4ccb9fe4d467f41eceaf62b84e5cf2594d/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier.cc?ref=e1f8fd4ccb9fe4d467f41eceaf62b84e5cf2594d",
            "patch": "@@ -28,6 +28,10 @@ limitations under the License.\n #include \"absl/time/clock.h\"\n #include \"absl/time/time.h\"\n #include \"xla/tsl/platform/env.h\"\n+#if defined(PLATFORM_GOOGLE)\n+#include \"thread/executor.h\"\n+#include \"thread/signal.h\"\n+#endif\n \n namespace xla {\n \n@@ -53,7 +57,17 @@ class SigtermNotifier : public PreemptionNotifier {\n SigtermNotifier::SigtermNotifier(tsl::Env* env) : PreemptionNotifier(env) {\n   sigterm_received.store(false);\n   StartListenerThread();\n+#if defined(PLATFORM_GOOGLE)\n+  thread::signal::Token unused_token;\n+\n+  thread::signal::AddHandler(\n+      SIGTERM, thread::Executor::DefaultExecutor(),\n+      []() { sigterm_received.store(true); },\n+      /*flags=*/0,  // Don't override existing signal handlers.\n+      &unused_token);\n+#else\n   std::signal(SIGTERM, [](int signal) { sigterm_received.store(true); });\n+#endif\n }\n \n void SigtermNotifier::StartListenerThread() {"
        },
        {
            "sha": "3a012e7632c776dbe3f3994ab32a9a3e04d555c2",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_notifier_test.cc",
            "status": "modified",
            "additions": 25,
            "deletions": 6,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e1f8fd4ccb9fe4d467f41eceaf62b84e5cf2594d/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e1f8fd4ccb9fe4d467f41eceaf62b84e5cf2594d/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_notifier_test.cc?ref=e1f8fd4ccb9fe4d467f41eceaf62b84e5cf2594d",
            "patch": "@@ -27,11 +27,30 @@ limitations under the License.\n #include \"xla/tsl/platform/status.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n+#if defined(PLATFORM_GOOGLE)\n+#include \"thread/executor.h\"\n+#include \"thread/signal.h\"\n+#endif\n \n namespace xla {\n namespace {\n \n-TEST(PreemptNotifierTest, WillBePreemptedAt) {\n+class PreemptNotifierTest : public ::testing::Test {\n+ public:\n+  PreemptNotifierTest() {\n+#if defined(PLATFORM_GOOGLE)\n+    // Override default test SIGTERM handler so that test does not exit\n+    // prematurely.\n+    thread::signal::Token unused_token;\n+\n+    thread::signal::AddHandler(\n+        SIGTERM, thread::Executor::DefaultExecutor(), []() {},\n+        thread::signal::kOverrideDefault, &unused_token);\n+#endif\n+  }\n+};\n+\n+TEST_F(PreemptNotifierTest, WillBePreemptedAt) {\n   auto env = tsl::Env::Default();\n   std::unique_ptr<PreemptionNotifier> preempt_notifier =\n       PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n@@ -52,8 +71,8 @@ TEST(PreemptNotifierTest, WillBePreemptedAt) {\n   EXPECT_LT(time_diff, absl::Seconds(3));\n }\n \n-TEST(PreemptNotifierTest,\n-     WillBePreemptedAt_AlreadyPreempted_ReturnsImmediately) {\n+TEST_F(PreemptNotifierTest,\n+       WillBePreemptedAt_AlreadyPreempted_ReturnsImmediately) {\n   auto env = tsl::Env::Default();\n   std::unique_ptr<PreemptionNotifier> preempt_notifier =\n       PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n@@ -78,7 +97,7 @@ TEST(PreemptNotifierTest,\n   EXPECT_LT(time_diff, absl::Seconds(2));\n }\n \n-TEST(PreemptNotifierTest, WillBePreemptedAtAsync_SameResultForAllCallbacks) {\n+TEST_F(PreemptNotifierTest, WillBePreemptedAtAsync_SameResultForAllCallbacks) {\n   auto env = tsl::Env::Default();\n   std::unique_ptr<PreemptionNotifier> preempt_notifier =\n       PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n@@ -109,7 +128,7 @@ TEST(PreemptNotifierTest, WillBePreemptedAtAsync_SameResultForAllCallbacks) {\n   EXPECT_EQ(preempt_time.value(), preempt_time_2.value());\n }\n \n-TEST(PreemptNotifierTest, Reset_TwoDifferentPreemptTimesRecorded) {\n+TEST_F(PreemptNotifierTest, Reset_TwoDifferentPreemptTimesRecorded) {\n   auto env = tsl::Env::Default();\n   std::unique_ptr<PreemptionNotifier> preempt_notifier =\n       PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);\n@@ -131,7 +150,7 @@ TEST(PreemptNotifierTest, Reset_TwoDifferentPreemptTimesRecorded) {\n   EXPECT_NE(preempt_time, preempt_time_2);\n }\n \n-TEST(PreemptNotifierTest, DestructorCancelsPendingCalls) {\n+TEST_F(PreemptNotifierTest, DestructorCancelsPendingCalls) {\n   auto env = tsl::Env::Default();\n   std::unique_ptr<PreemptionNotifier> preempt_notifier =\n       PreemptionNotifier::CreatePreemptionNotifier(\"sigterm\", env);"
        }
    ],
    "stats": {
        "total": 45,
        "additions": 39,
        "deletions": 6
    }
}