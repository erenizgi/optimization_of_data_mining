{
    "author": "tensorflower-gardener",
    "message": "Clone manual computations inside ShardMapImport pass instead of in a separate pass.\n\nPiperOrigin-RevId: 811289766",
    "sha": "8bebb03acc801480697983067ffa62591d259041",
    "files": [
        {
            "sha": "252ff2c89d0ab0eefad29b84d23230e31ede0a4a",
            "filename": "third_party/xla/xla/service/spmd/shardy/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2FBUILD?ref=8bebb03acc801480697983067ffa62591d259041",
            "patch": "@@ -138,7 +138,6 @@ xla_cc_binary(\n         \"//xla/service/spmd/shardy/round_trip_common:import_func_calls\",\n         \"//xla/service/spmd/shardy/round_trip_common:import_sdy_custom_calls\",\n         \"//xla/service/spmd/shardy/round_trip_common:open_while_free_vars_sharding\",\n-        \"//xla/service/spmd/shardy/sdy_round_trip:clone_manual_computation_calls\",\n         \"//xla/service/spmd/shardy/sdy_round_trip:dedup_meshes\",\n         \"//xla/service/spmd/shardy/sdy_round_trip:export_ops\",\n         \"//xla/service/spmd/shardy/sdy_round_trip:export_shardy_attrs\","
        },
        {
            "sha": "25467bcd27a87b7613f1e6fb3370032ead590f7e",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_opt_main.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_opt_main.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_opt_main.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_opt_main.cc?ref=8bebb03acc801480697983067ffa62591d259041",
            "patch": "@@ -27,7 +27,6 @@ limitations under the License.\n #include \"xla/service/spmd/shardy/round_trip_common/import_func_calls.h\"\n #include \"xla/service/spmd/shardy/round_trip_common/import_sdy_custom_calls.h\"\n #include \"xla/service/spmd/shardy/round_trip_common/open_while_free_vars_sharding.h\"\n-#include \"xla/service/spmd/shardy/sdy_round_trip/clone_manual_computation_calls.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/dedup_meshes.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/export_ops.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/export_shardy_attrs.h\"\n@@ -81,7 +80,6 @@ int main(int argc, char** argv) {\n   xla::sdy::registerSdyRoundTripExportPipeline();\n   xla::sdy::registerSdyRoundTripDedupMeshesPass();\n   xla::sdy::registerSdyRoundTripShardMapExportPass();\n-  xla::sdy::registerSdyRoundTripCloneManualComputationCallsPass();\n   xla::sdy::registerSdyRoundTripShardMapImportPass();\n   xla::sdy::registerSdyRoundTripImportPipeline();\n   xla::sdy::registerSdyRoundTripTestingPipeline();"
        },
        {
            "sha": "40da37501b04e81ecf36487fde323a21091ff17f",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_round_trip/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 17,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2FBUILD?ref=8bebb03acc801480697983067ffa62591d259041",
            "patch": "@@ -115,22 +115,6 @@ cc_library(\n     ],\n )\n \n-cc_library(\n-    name = \"clone_manual_computation_calls\",\n-    srcs = [\"clone_manual_computation_calls.cc\"],\n-    hdrs = [\"clone_manual_computation_calls.h\"],\n-    deps = [\n-        \"//xla/service/spmd/shardy:constants\",\n-        \"@llvm-project//llvm:Support\",\n-        \"@llvm-project//mlir:FuncDialect\",\n-        \"@llvm-project//mlir:IR\",\n-        \"@llvm-project//mlir:Pass\",\n-        \"@llvm-project//mlir:Support\",\n-        \"@llvm-project//mlir:TransformUtils\",\n-        \"@stablehlo//:stablehlo_ops\",\n-    ],\n-)\n-\n cc_library(\n     name = \"dedup_meshes\",\n     srcs = [\"dedup_meshes.cc\"],\n@@ -152,7 +136,6 @@ cc_library(\n     hdrs = [\"pipelines.h\"],\n     visibility = internal_visibility([\":friends\"]),\n     deps = [\n-        \":clone_manual_computation_calls\",\n         \":dedup_meshes\",\n         \":export_ops\",\n         \":export_shardy_attrs\","
        },
        {
            "sha": "7803fcd862cf9f0a54e5fea6cd21bda58170cba7",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_round_trip/clone_manual_computation_calls.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 111,
            "changes": 111,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9150ee5c72af231a2ae08a67a69d071beba75fe2/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9150ee5c72af231a2ae08a67a69d071beba75fe2/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.cc?ref=9150ee5c72af231a2ae08a67a69d071beba75fe2",
            "patch": "@@ -1,111 +0,0 @@\n-/* Copyright 2025 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/service/spmd/shardy/sdy_round_trip/clone_manual_computation_calls.h\"\n-\n-#include <cassert>\n-#include <memory>\n-\n-#include \"llvm/ADT/DenseSet.h\"\n-#include \"llvm/ADT/StringRef.h\"\n-#include \"llvm/Support/Casting.h\"\n-#include \"llvm/Support/ErrorHandling.h\"\n-#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n-#include \"mlir/IR/BuiltinAttributes.h\"\n-#include \"mlir/IR/BuiltinOps.h\"\n-#include \"mlir/IR/Diagnostics.h\"\n-#include \"mlir/IR/DialectRegistry.h\"\n-#include \"mlir/IR/MLIRContext.h\"\n-#include \"mlir/IR/Operation.h\"\n-#include \"mlir/IR/SymbolTable.h\"\n-#include \"mlir/IR/Value.h\"\n-#include \"mlir/IR/Visitors.h\"\n-#include \"mlir/Pass/Pass.h\"\n-#include \"mlir/Pass/PassManager.h\"\n-#include \"mlir/Pass/PassRegistry.h\"\n-#include \"mlir/Support/LLVM.h\"\n-#include \"mlir/Support/TypeID.h\"\n-#include \"mlir/Transforms/DialectConversion.h\"\n-#include \"stablehlo/dialect/StablehloOps.h\"\n-#include \"xla/service/spmd/shardy/constants.h\"\n-\n-namespace xla {\n-namespace sdy {\n-\n-namespace {\n-\n-using ::mlir::ModuleOp;\n-using ::mlir::StringRef;\n-using ::mlir::SymbolTable;\n-using ::mlir::func::CallOp;\n-using ::mlir::func::FuncOp;\n-\n-namespace stablehlo = ::mlir::stablehlo;\n-\n-class SdyRoundTripCloneManualComputationCallsPass\n-    : public mlir::PassWrapper<SdyRoundTripCloneManualComputationCallsPass,\n-                               mlir::OperationPass<ModuleOp>> {\n- public:\n-  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(\n-      SdyRoundTripCloneManualComputationCallsPass)\n-\n-  void runOnOperation() final {\n-    ModuleOp moduleOp = getOperation();\n-    SymbolTable symbolTable(moduleOp);\n-\n-    // Clone multiple calls to the same function.\n-    llvm::DenseSet<StringRef> seenCalleeNames;\n-    moduleOp->walk([&](CallOp op) {\n-      if (!op.getCallee().contains(kManualComputationFuncName)) {\n-        return;\n-      }\n-      if (seenCalleeNames.insert(op.getCallee()).second) {\n-        return;\n-      }\n-      // TODO(b/430894772): Clone manual computations but with a body just calls\n-      // a newly created shared function with the body of the manual computation\n-      // bodyinstead of copying the body for each cloned manual computation, so\n-      // they can be potentially be deduplicated at the end.\n-      auto funcOp = symbolTable.lookup<FuncOp>(op.getCallee())->clone();\n-      op.setCallee(symbolTable.insert(funcOp));\n-    });\n-  }\n-\n-  StringRef getArgument() const override {\n-    return \"xla-sdy-round-trip-clone-manual-computation-calls\";\n-  }\n-\n-  StringRef getDescription() const override {\n-    return \"Clone xla.sdy.manual_computation_body functions so that each call \"\n-           \"has its own unique function.\";\n-  }\n-  void getDependentDialects(mlir::DialectRegistry& registry) const final {\n-    registry.insert<stablehlo::StablehloDialect>();\n-  }\n-};\n-\n-}  // namespace\n-\n-void registerSdyRoundTripCloneManualComputationCallsPass() {\n-  mlir::registerPass(createSdyRoundTripCloneManualComputationCallsPass);\n-}\n-\n-std::unique_ptr<mlir::Pass>\n-createSdyRoundTripCloneManualComputationCallsPass() {\n-  return std::make_unique<SdyRoundTripCloneManualComputationCallsPass>();\n-}\n-\n-}  // namespace sdy\n-}  // namespace xla"
        },
        {
            "sha": "ef46ea91585681c2780e09477355bb3a71c57ad7",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_round_trip/clone_manual_computation_calls.h",
            "status": "removed",
            "additions": 0,
            "deletions": 34,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9150ee5c72af231a2ae08a67a69d071beba75fe2/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9150ee5c72af231a2ae08a67a69d071beba75fe2/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.h?ref=9150ee5c72af231a2ae08a67a69d071beba75fe2",
            "patch": "@@ -1,34 +0,0 @@\n-/* Copyright 2025 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#ifndef XLA_SERVICE_SPMD_SHARDY_SDY_ROUND_TRIP_CLONE_MANUAL_COMPUTATION_CALLS_H_\n-#define XLA_SERVICE_SPMD_SHARDY_SDY_ROUND_TRIP_CLONE_MANUAL_COMPUTATION_CALLS_H_\n-\n-#include <memory>\n-\n-#include \"mlir/Pass/Pass.h\"\n-\n-namespace xla {\n-namespace sdy {\n-\n-std::unique_ptr<mlir::Pass> createSdyRoundTripCloneManualComputationCallsPass();\n-\n-// Registers the xla-sdy-round-trip-clone-manual-computation-calls pass.\n-void registerSdyRoundTripCloneManualComputationCallsPass();\n-\n-}  // namespace sdy\n-}  // namespace xla\n-\n-#endif  // XLA_SERVICE_SPMD_SHARDY_SDY_ROUND_TRIP_CLONE_MANUAL_COMPUTATION_CALLS_H_"
        },
        {
            "sha": "9589d3ef315a34a95006192d3e303fbe8a85936a",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_round_trip/pipelines.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 4,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fpipelines.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fpipelines.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fpipelines.cc?ref=8bebb03acc801480697983067ffa62591d259041",
            "patch": "@@ -26,7 +26,6 @@ limitations under the License.\n #include \"shardy/dialect/sdy/transforms/import/passes.h\"\n #include \"xla/service/hlo.pb.h\"\n #include \"xla/service/spmd/shardy/round_trip_common/pipeline_passes.h\"\n-#include \"xla/service/spmd/shardy/sdy_round_trip/clone_manual_computation_calls.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/dedup_meshes.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/export_ops.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/export_shardy_attrs.h\"\n@@ -64,9 +63,6 @@ void addSdyRoundTripImportPipeline(mlir::OpPassManager& pm,\n                                    bool liftAndDedupMeshes) {\n   addCommonPreImportPasses(pm, enableConstantImport);\n   pm.addPass(createSdyRoundTripImportShardyAttrsPass());\n-  // TODO(b/430894772): Drop the pass and handle cloning inside shard map import\n-  // pass.\n-  pm.addPass(createSdyRoundTripCloneManualComputationCallsPass());\n   pm.addPass(createSdyRoundTripShardMapImportPass());\n   addCommonPostImportPasses(pm, importFuncCalls);\n   if (liftAndDedupMeshes) {"
        },
        {
            "sha": "d7a1d67eed2d67bac31256b3f7e12ae1b09c9e95",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_round_trip/shard_map_import.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 13,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fshard_map_import.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fshard_map_import.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fshard_map_import.cc?ref=8bebb03acc801480697983067ffa62591d259041",
            "patch": "@@ -68,14 +68,7 @@ namespace sdy = ::mlir::sdy;\n \n mlir::LogicalResult rewriteManualComputation(\n     CallOp callOp, mlir::IRRewriter& rewriter,\n-    const mlir::SymbolTable& symbolTable,\n-    llvm::SmallDenseSet<StringRef>& manualComputationCalleeNames) {\n-  if (manualComputationCalleeNames.contains(callOp.getCallee())) {\n-    return callOp->emitOpError(\n-        \"expected a unique FuncOp per @local_xla.sdy.manual_computation_body call. \"\n-        \"Were functions maybe somehow shared/de-duped between two \"\n-        \"ManualComputations?\");\n-  }\n+    const mlir::SymbolTable& symbolTable) {\n   auto shmapBodyFunc = symbolTable.lookup<FuncOp>(callOp.getCallee());\n \n   // If the callOp has no uses, but has at least one result, then it means\n@@ -85,7 +78,6 @@ mlir::LogicalResult rewriteManualComputation(\n   // function.\n   if (callOp.use_empty() && !callOp->getResults().empty()) {\n     rewriter.eraseOp(callOp);\n-    rewriter.eraseOp(shmapBodyFunc);\n     return mlir::success();\n   }\n \n@@ -175,7 +167,6 @@ mlir::LogicalResult rewriteManualComputation(\n     manualAxes =\n         parseStringAttr<sdy::ManualAxesAttr>(callOpFrontendAttrs, kManualAxes);\n   }\n-  manualComputationCalleeNames.insert(callOp.getCallee());\n   auto manualComputationOp =\n       rewriter.replaceOpWithNewOp<sdy::ManualComputationOp>(\n           callOp, resultTypes, operands, inShardings, outShardings, manualAxes);\n@@ -202,6 +193,21 @@ class SdyRoundTripShardMapImportPass\n     mlir::IRRewriter rewriter(module);\n     llvm::SmallDenseSet<StringRef> manualComputationCalleeNames;\n \n+    // Clone multiple calls to the same function.\n+    module->walk([&](CallOp op) {\n+      if (!op.getCallee().contains(kManualComputationFuncName)) {\n+        return;\n+      }\n+      if (manualComputationCalleeNames.insert(op.getCallee()).second) {\n+        return;\n+      }\n+      // TODO(b/446881697): Clone just the body on demand like in\n+      // shardy/stablehlo_round_trip/shard_map_import.cc.\n+      FuncOp funcOp = symbolTable.lookup<FuncOp>(op.getCallee()).clone();\n+      op.setCallee(symbolTable.insert(funcOp));\n+      manualComputationCalleeNames.insert(funcOp.getName());\n+    });\n+\n     mlir::CallGraph callGraph(module);\n     llvm::ReversePostOrderTraversal<const mlir::CallGraph*> rpo(&callGraph);\n     for (mlir::CallGraphNode* node : llvm::reverse(rpo)) {\n@@ -212,9 +218,8 @@ class SdyRoundTripShardMapImportPass\n                   return mlir::WalkResult::advance();\n                 }\n                 rewriter.setInsertionPoint(callOp);\n-                if (mlir::failed(rewriteManualComputation(\n-                        callOp, rewriter, symbolTable,\n-                        manualComputationCalleeNames))) {\n+                if (mlir::failed(rewriteManualComputation(callOp, rewriter,\n+                                                          symbolTable))) {\n                   callOp.emitError(\n                       \"failed to rewrite func.call to manual computation\");\n                   return mlir::WalkResult::interrupt();"
        },
        {
            "sha": "4032bd091250118bc5f03adc1738d9931d8ecd3f",
            "filename": "third_party/xla/xla/service/spmd/shardy/test/sdy_round_trip_clone_manual_computation_calls.mlir",
            "status": "removed",
            "additions": 0,
            "deletions": 128,
            "changes": 128,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/9150ee5c72af231a2ae08a67a69d071beba75fe2/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_clone_manual_computation_calls.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/9150ee5c72af231a2ae08a67a69d071beba75fe2/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_clone_manual_computation_calls.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_clone_manual_computation_calls.mlir?ref=9150ee5c72af231a2ae08a67a69d071beba75fe2",
            "patch": "@@ -1,128 +0,0 @@\n-// RUN: sdy_opt %s -xla-sdy-round-trip-clone-manual-computation-calls -split-input-file 2>&1 | FileCheck %s\n-\n-sdy.mesh @mesh_0 = <[\"a\"=4, \"b\"=2]>\n-\n-// CHECK-LABEL: func @single_manual_comp\n-func.func @single_manual_comp(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>) {\n-  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n-  // CHECK: call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %1 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n-  return %2 : tensor<8x32xf32>\n-}\n-\n-// CHECK:      func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n-// CHECK-NEXT: }\n-func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  return %0 : tensor<2x32xf32>\n-}\n-\n-// -----\n-\n-sdy.mesh @mesh_0 = <[\"a\"=4, \"b\"=2]>\n-\n-// CHECK-LABEL: func @using_same_body_func\n-func.func @using_same_body_func(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>) {\n-  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n-  // CHECK: call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %1 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n-  // CHECK: call @local_xla.sdy.manual_computation_body_0(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %3 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %4 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%3) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n-  return %4 : tensor<8x32xf32>\n-}\n-\n-// CHECK:      func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n-// CHECK-NEXT: }\n-func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  return %0 : tensor<2x32xf32>\n-}\n-\n-// CHECK:      func.func @local_xla.sdy.manual_computation_body_0(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n-// CHECK-NEXT: }\n-\n-// -----\n-\n-sdy.mesh @mesh_0 = <[\"a\"=4, \"b\"=2]>\n-\n-// CHECK-LABEL: func @using_different_body_func\n-func.func @using_different_body_func(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>) {\n-  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n-  // CHECK: call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %1 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n-  // CHECK: call @local_xla.sdy.manual_computation_body_another(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %3 = call @local_xla.sdy.manual_computation_body_another(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %4 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%3) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n-  return %4 : tensor<8x32xf32>\n-}\n-\n-// CHECK:      func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n-// CHECK-NEXT: }\n-func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  return %0 : tensor<2x32xf32>\n-}\n-\n-// CHECK:      func.func @local_xla.sdy.manual_computation_body_another(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n-// CHECK-NEXT: }\n-func.func @local_xla.sdy.manual_computation_body_another(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  return %0 : tensor<2x32xf32>\n-}\n-\n-// -----\n-\n-sdy.mesh @mesh_0 = <[\"a\"=4, \"b\"=2]>\n-\n-// CHECK-LABEL: func @using_same_body_func_potential_name_collision\n-func.func @using_same_body_func_potential_name_collision(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>) {\n-  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n-  // CHECK: call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %1 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n-  // CHECK: call @local_xla.sdy.manual_computation_body_0(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %3 = call @local_xla.sdy.manual_computation_body_0(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %4 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%3) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n-  // CHECK: call @local_xla.sdy.manual_computation_body_1(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %5 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  %6 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%5) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n-  return %6 : tensor<8x32xf32>\n-}\n-\n-// CHECK:      func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n-// CHECK-NEXT: }\n-func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  return %0 : tensor<2x32xf32>\n-}\n-\n-// CHECK:      func.func @local_xla.sdy.manual_computation_body_0(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n-// CHECK-NEXT: }\n-func.func @local_xla.sdy.manual_computation_body_0(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-  return %0 : tensor<2x32xf32>\n-}\n-\n-// CHECK:      func.func @local_xla.sdy.manual_computation_body_1(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n-// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n-// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n-// CHECK-NEXT: }\n-"
        },
        {
            "sha": "42a7a79c106c6addc79149393099c60f5fc1acdd",
            "filename": "third_party/xla/xla/service/spmd/shardy/test/sdy_round_trip_shard_map_import.mlir",
            "status": "modified",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_shard_map_import.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_shard_map_import.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_shard_map_import.mlir?ref=8bebb03acc801480697983067ffa62591d259041",
            "patch": "@@ -298,3 +298,96 @@ func.func @local_xla.sdy.manual_computation_body_10(%arg0: tensor<0x8xf32>, %arg\n   %0 = stablehlo.dot %arg0, %arg1 : (tensor<0x8xf32>, tensor<8x0xf32>) -> tensor<0x0xf32>\n   return %0, %arg1 : tensor<0x0xf32>, tensor<8x0xf32>\n }\n+\n+// CHECK-LABEL: func @using_same_body_func\n+func.func @using_same_body_func(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>, tensor<8x32xf32>) {\n+  // CHECK:      %[[MC0:.*]] = sdy.manual_computation(%arg0, %arg1)\n+  // CHECK-SAME:   in_shardings=[<@mesh_0, [{\"a\"}, {\"b\"}]>, <@mesh_0, [{\"b\"}, {}], replicated={\"a\"}>]\n+  // CHECK-SAME:   out_shardings=[<@mesh_0, [{\"a\"}, {}], replicated={\"b\"}>]\n+  // CHECK-SAME:   manual_axes={\"a\", \"b\"}\n+  // CHECK:      %[[MC1:.*]] = sdy.manual_computation(%arg0, %arg1)\n+  // CHECK-SAME:   in_shardings=[<@mesh_0, [{\"a\"}, {\"b\"}]>, <@mesh_0, [{\"b\"}, {}], replicated={\"a\"}>]\n+  // CHECK-SAME:   out_shardings=[<@mesh_0, [{\"a\"}, {}], replicated={\"b\"}>]\n+  // CHECK-SAME:   manual_axes={\"a\", \"b\"}\n+  // CHECK:      return %[[MC0]], %[[MC1]]\n+  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n+  %1 = call @local_xla.sdy.manual_computation_body.clone.a(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  %3 = call @local_xla.sdy.manual_computation_body.clone.a(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %4 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%3) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  return %2, %4 : tensor<8x32xf32>, tensor<8x32xf32>\n+}\n+\n+// CHECK-NOT: func.func @local_xla.sdy.manual_computation_body.clone.a\n+func.func @local_xla.sdy.manual_computation_body.clone.a(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}\n+\n+// CHECK-LABEL: func @using_different_body_func\n+func.func @using_different_body_func(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>, tensor<8x32xf32>) {\n+  // CHECK:      %[[MC0:.*]] = sdy.manual_computation(%arg0, %arg1)\n+  // CHECK-SAME:   in_shardings=[<@mesh_0, [{\"a\"}, {\"b\"}]>, <@mesh_0, [{\"b\"}, {}], replicated={\"a\"}>]\n+  // CHECK-SAME:   out_shardings=[<@mesh_0, [{\"a\"}, {}], replicated={\"b\"}>]\n+  // CHECK-SAME:   manual_axes={\"a\", \"b\"}\n+  // CHECK:      %[[MC1:.*]] = sdy.manual_computation(%arg0, %arg1)\n+  // CHECK-SAME:   in_shardings=[<@mesh_0, [{\"a\"}, {\"b\"}]>, <@mesh_0, [{\"b\"}, {}], replicated={\"a\"}>]\n+  // CHECK-SAME:   out_shardings=[<@mesh_0, [{\"a\"}, {}], replicated={\"b\"}>]\n+  // CHECK-SAME:   manual_axes={\"a\", \"b\"}\n+  // CHECK: return %[[MC0]], %[[MC1]]\n+  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n+  %1 = call @local_xla.sdy.manual_computation_body.clone.b(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  %3 = call @local_xla.sdy.manual_computation_body.clone.b_another(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %4 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%3) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  return %2, %4 : tensor<8x32xf32>, tensor<8x32xf32>\n+}\n+\n+// CHECK-NOT: func.func @local_xla.sdy.manual_computation_body.clone.b\n+func.func @local_xla.sdy.manual_computation_body.clone.b(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}\n+\n+// CHECK-NOT: func.func @local_xla.sdy.manual_computation_body.clone.b_another\n+func.func @local_xla.sdy.manual_computation_body.clone.b_another(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}\n+\n+// CHECK-LABEL: func @using_same_body_func_potential_name_collision\n+func.func @using_same_body_func_potential_name_collision(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>, tensor<8x32xf32>, tensor<8x32xf32>) {\n+  // CHECK:      %[[MC0:.*]] = sdy.manual_computation(%arg0, %arg1)\n+  // CHECK-SAME:   in_shardings=[<@mesh_0, [{\"a\"}, {\"b\"}]>, <@mesh_0, [{\"b\"}, {}], replicated={\"a\"}>]\n+  // CHECK-SAME:   out_shardings=[<@mesh_0, [{\"a\"}, {}], replicated={\"b\"}>]\n+  // CHECK-SAME:   manual_axes={\"a\", \"b\"}\n+  // CHECK:      %[[MC1:.*]] = sdy.manual_computation(%arg0, %arg1)\n+  // CHECK-SAME:   in_shardings=[<@mesh_0, [{\"a\"}, {\"b\"}]>, <@mesh_0, [{\"b\"}, {}], replicated={\"a\"}>]\n+  // CHECK-SAME:   out_shardings=[<@mesh_0, [{\"a\"}, {}], replicated={\"b\"}>]\n+  // CHECK-SAME:   manual_axes={\"a\", \"b\"}\n+  // CHECK:      %[[MC2:.*]] = sdy.manual_computation(%arg0, %arg1)\n+  // CHECK-SAME:   in_shardings=[<@mesh_0, [{\"a\"}, {\"b\"}]>, <@mesh_0, [{\"b\"}, {}], replicated={\"a\"}>]\n+  // CHECK-SAME:   out_shardings=[<@mesh_0, [{\"a\"}, {}], replicated={\"b\"}>]\n+  // CHECK-SAME:   manual_axes={\"a\", \"b\"}\n+  // CHECK: return %[[MC0]], %[[MC1]], %[[MC2]]\n+  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n+  %1 = call @local_xla.sdy.manual_computation_body.clone.c(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  %3 = call @local_xla.sdy.manual_computation_body.clone.c_0(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %4 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%3) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  %5 = call @local_xla.sdy.manual_computation_body.clone.c(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %6 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%5) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  return %2, %4, %6 : tensor<8x32xf32>, tensor<8x32xf32>, tensor<8x32xf32>\n+}\n+\n+// CHECK-NOT: func.func @local_xla.sdy.manual_computation_body.clone.c\n+func.func @local_xla.sdy.manual_computation_body.clone.c(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}\n+\n+// CHECK-NOT: func.func @local_xla.sdy.manual_computation_body.clone.c_0\n+func.func @local_xla.sdy.manual_computation_body.clone.c_0(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}"
        },
        {
            "sha": "d20fbedd11181219e64b670b159b1042ada22f35",
            "filename": "third_party/xla/xla/service/spmd/shardy/test/sdy_round_trip_shard_map_import_failure.mlir",
            "status": "modified",
            "additions": 3,
            "deletions": 17,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_shard_map_import_failure.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8bebb03acc801480697983067ffa62591d259041/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_shard_map_import_failure.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_shard_map_import_failure.mlir?ref=8bebb03acc801480697983067ffa62591d259041",
            "patch": "@@ -1,22 +1,6 @@\n // RUN: sdy_opt %s -xla-sdy-round-trip-shard-map-import -split-input-file -verify-diagnostics\n \n-func.func @using_same_body_func(%arg0: tensor<8x8xf32>) -> tensor<8x8xf32> {\n-  %0 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0) : (tensor<8x8xf32>) -> (tensor<2x8xf32>)\n-  %1 = call @local_xla.sdy.manual_computation_body(%0) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh, [{\\\\\\22a\\\\\\22}, {\\\\\\22b\\\\\\22}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\\\\\22a\\\\\\22, \\\\\\22b\\\\\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh, [{\\\\\\22a\\\\\\22}, {}], replicated={\\\\\\22b\\\\\\22}>]>\"}} : (tensor<2x8xf32>) -> (tensor<2x8xf32>)\n-  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) : (tensor<2x8xf32>) -> (tensor<8x8xf32>)\n-  %3 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%2) : (tensor<8x8xf32>) -> (tensor<2x8xf32>)\n-  // expected-error @+2 {{'func.call' op expected a unique FuncOp per @local_xla.sdy.manual_computation_body call}}\n-  // expected-error @+1 {{failed to rewrite func.call to manual computation}}\n-  %4 = call @local_xla.sdy.manual_computation_body(%3) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh, [{\\\\\\22a\\\\\\22}, {\\\\\\22b\\\\\\22}]>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\\\\\22a\\\\\\22, \\\\\\22b\\\\\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh, [{\\\\\\22a\\\\\\22}, {}], replicated={\\\\\\22b\\\\\\22}>]>\"}} : (tensor<2x8xf32>) -> (tensor<2x8xf32>)\n-  %5 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%4) : (tensor<2x8xf32>) -> (tensor<8x8xf32>)\n-  return %5 : tensor<8x8xf32>\n-}\n-\n-func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>) -> tensor<2x8xf32> {\n-  return %arg0 : tensor<2x8xf32>\n-}\n-\n-// -----\n+sdy.mesh @mesh = <[\"a\"=2, \"b\"=2]>\n \n func.func @manual_computation_missing_global_to_local_shape(%arg0: tensor<0x16xf32>) -> (tensor<0x16xf32>) {\n   %c = stablehlo.constant dense<0.000000e+00> : tensor<0x8xf32>\n@@ -33,6 +17,8 @@ func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<0x8xf32>) -> tens\n \n // -----\n \n+sdy.mesh @mesh = <[\"a\"=2, \"b\"=2]>\n+\n func.func @manual_computation_missing_local_to_global_shape(%arg0: tensor<0x16xf32>) -> (tensor<0x8xf32>) {\n   %0 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22b\\22}>\", xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh, [{}, {\\22b\\22}]>]>\"}} : (tensor<0x16xf32>) -> tensor<0x8xf32>\n   // expected-error @+2 {{'func.call' op expected the first use of @local_xla.sdy.manual_computation_body to be a xla.sdy.LocalToGlobalShape CustomCallOp}}"
        }
    ],
    "stats": {
        "total": 441,
        "additions": 114,
        "deletions": 327
    }
}