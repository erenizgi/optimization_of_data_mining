{
    "author": "zacmustin",
    "message": "Eliminate `resizing` in C API `Execute`.\n\nThe resizing of `c_output_lists{, _storage}` causes significant overhead when enabling the C API.\n\nIn this change, we initialize these variables to have the correct size first-time around, saving us the repeated `resize`ing. This comes at the expense of a small increase in code duplication in `Execute` and `ExecuteWithSingleDevice`, since the code is no longer shared by `GetCommonExecuteArgs`.\n\nPiperOrigin-RevId: 811068152",
    "sha": "c68e3d9c67b39539f7bbe8dacbc261b853e9c2ef",
    "files": [
        {
            "sha": "796b91d80d747f64daa10b8ce3a44ee34de6994c",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 27,
            "changes": 75,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c68e3d9c67b39539f7bbe8dacbc261b853e9c2ef/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c68e3d9c67b39539f7bbe8dacbc261b853e9c2ef/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc?ref=c68e3d9c67b39539f7bbe8dacbc261b853e9c2ef",
            "patch": "@@ -2048,14 +2048,42 @@ static void CppRecvCallbackListsToC(\n   }\n }\n \n+absl::StatusOr<size_t> PjRtCApiLoadedExecutable::GetNumOutputs() const {\n+  PJRT_Executable_NumOutputs_Args args;\n+  args.struct_size = PJRT_Executable_NumOutputs_Args_STRUCT_SIZE;\n+  args.extension_start = nullptr;\n+  args.executable = c_executable();\n+  RETURN_STATUS_IF_PJRT_ERROR(pjrt_c_api()->PJRT_Executable_NumOutputs(&args),\n+                              pjrt_c_api());\n+  return args.num_outputs;\n+}\n+\n+absl::StatusOr<std::vector<std::vector<PJRT_Buffer*>>>\n+PjRtCApiLoadedExecutable::InitializeOutputListsStorage(\n+    size_t outer_size) const {\n+  TF_ASSIGN_OR_RETURN(size_t inner_size, GetNumOutputs());\n+  std::vector<std::vector<PJRT_Buffer*>> c_output_lists_storage(\n+      outer_size, std::vector<PJRT_Buffer*>(inner_size));\n+  return c_output_lists_storage;\n+}\n+\n+absl::StatusOr<std::vector<PJRT_Buffer**>>\n+PjRtCApiLoadedExecutable::InitializeOutputLists(\n+    std::vector<std::vector<PJRT_Buffer*>>& c_output_lists_storage) const {\n+  size_t outer_size = c_output_lists_storage.size();\n+  std::vector<PJRT_Buffer**> c_output_lists(outer_size);\n+  for (int i = 0; i < outer_size; ++i) {\n+    c_output_lists[i] = c_output_lists_storage[i].data();\n+  }\n+  return c_output_lists;\n+}\n+\n absl::StatusOr<PJRT_LoadedExecutable_Execute_Args>\n PjRtCApiLoadedExecutable::GetCommonExecuteArgs(\n     absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n     const ExecuteOptions& options, PJRT_ExecuteOptions& c_options,\n     std::vector<std::vector<PJRT_Buffer*>>& c_argument_lists_storage,\n     std::vector<PJRT_Buffer**>& c_arguments,\n-    std::vector<std::vector<PJRT_Buffer*>>& c_output_lists_storage,\n-    std::vector<PJRT_Buffer**>& c_output_lists,\n     std::optional<std::vector<PJRT_Event*>>& device_complete_events,\n     SendRecvCallbackData& callback_data,\n     std::vector<int64_t>& non_donatable_input_indices_storage,\n@@ -2114,25 +2142,6 @@ PjRtCApiLoadedExecutable::GetCommonExecuteArgs(\n   }\n   args.argument_lists = c_arguments.data();\n \n-  // Allocates memory for output. `c_buffer_lists_storage` and `c_buffer_lists`\n-  // needs to stay alive during the call of `PJRT_LoadedExecutable_Execute`.\n-\n-  PJRT_Executable_NumOutputs_Args numoutputs_args;\n-  numoutputs_args.struct_size = PJRT_Executable_NumOutputs_Args_STRUCT_SIZE;\n-  numoutputs_args.extension_start = nullptr;\n-  numoutputs_args.executable = c_executable();\n-  RETURN_STATUS_IF_PJRT_ERROR(\n-      pjrt_c_api()->PJRT_Executable_NumOutputs(&numoutputs_args), pjrt_c_api());\n-  size_t outer_size = args.num_devices;\n-  size_t inner_size = numoutputs_args.num_outputs;\n-  c_output_lists_storage.resize(outer_size);\n-  c_output_lists.resize(outer_size);\n-  for (int i = 0; i < outer_size; ++i) {\n-    c_output_lists_storage[i].resize(inner_size);\n-    c_output_lists[i] = c_output_lists_storage[i].data();\n-  }\n-  args.output_lists = c_output_lists.data();\n-\n   // Allocates memory for callbacks. `callback_data` needs to stay alive during\n   // the execution.\n   if (!options.send_callbacks.empty()) {\n@@ -2203,8 +2212,6 @@ PjRtCApiLoadedExecutable::Execute(\n     const ExecuteOptions& options,\n     std::optional<std::vector<PjRtFuture<>>>& returned_futures) const {\n   std::vector<std::vector<PJRT_Buffer*>> c_argument_lists_storage;\n-  std::vector<std::vector<PJRT_Buffer*>> c_output_lists_storage;\n-  std::vector<PJRT_Buffer**> c_output_lists;\n   std::vector<int64_t> non_donatable_input_indices_storage;\n   std::vector<int> task_ids_storage;\n   std::vector<int64_t> incarnation_ids_storage;\n@@ -2235,11 +2242,19 @@ PjRtCApiLoadedExecutable::Execute(\n       PJRT_LoadedExecutable_Execute_Args args,\n       GetCommonExecuteArgs(argument_handles, options, c_options,\n                            c_argument_lists_storage, c_arguments,\n-                           c_output_lists_storage, c_output_lists,\n                            device_complete_events, *callback_data,\n                            non_donatable_input_indices_storage,\n                            task_ids_storage, incarnation_ids_storage));\n \n+  // Allocates memory for output. `c_output_lists_storage` and `c_output_lists`\n+  // need to stay alive during the call of `PJRT_LoadedExecutable_Execute`.\n+  TF_ASSIGN_OR_RETURN(\n+      std::vector<std::vector<PJRT_Buffer*>> c_output_lists_storage,\n+      InitializeOutputListsStorage(args.num_devices));\n+  TF_ASSIGN_OR_RETURN(std::vector<PJRT_Buffer**> c_output_lists,\n+                      InitializeOutputLists(c_output_lists_storage));\n+  args.output_lists = c_output_lists.data();\n+\n   args.execute_device = nullptr;\n   PJRT_Profiler_Extension profiler_extension =\n       pjrt::CreatePjrtProfilerExtension(\n@@ -2291,8 +2306,6 @@ PjRtCApiLoadedExecutable::ExecuteWithSingleDevice(\n       {argument_handles.begin(), argument_handles.end()}};\n \n   std::vector<std::vector<PJRT_Buffer*>> c_argument_lists_storage;\n-  std::vector<std::vector<PJRT_Buffer*>> c_output_lists_storage;\n-  std::vector<PJRT_Buffer**> c_output_lists;\n   std::vector<int64_t> non_donatable_input_indices_storage;\n   std::vector<int> task_ids_storage;\n   std::vector<int64_t> incarnation_ids_storage;\n@@ -2309,11 +2322,19 @@ PjRtCApiLoadedExecutable::ExecuteWithSingleDevice(\n       PJRT_LoadedExecutable_Execute_Args args,\n       GetCommonExecuteArgs(argument_handles_vec, options, c_options,\n                            c_argument_lists_storage, c_arguments,\n-                           c_output_lists_storage, c_output_lists,\n                            device_complete_events, *callback_data,\n                            non_donatable_input_indices_storage,\n                            task_ids_storage, incarnation_ids_storage));\n \n+  // Allocates memory for output. `c_output_lists_storage` and `c_output_lists`\n+  // need to stay alive during the call of `PJRT_LoadedExecutable_Execute`.\n+  TF_ASSIGN_OR_RETURN(\n+      std::vector<std::vector<PJRT_Buffer*>> c_output_lists_storage,\n+      InitializeOutputListsStorage(args.num_devices));\n+  TF_ASSIGN_OR_RETURN(std::vector<PJRT_Buffer**> c_output_lists,\n+                      InitializeOutputLists(c_output_lists_storage));\n+  args.output_lists = c_output_lists.data();\n+\n   args.execute_device =\n       tensorflow::down_cast<PjRtCApiDevice*>(device)->c_device();\n   PJRT_Profiler_Extension profiler_extension ="
        },
        {
            "sha": "27a9922875126700a951e6f53f15a30e4bd17759",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 14,
            "deletions": 4,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c68e3d9c67b39539f7bbe8dacbc261b853e9c2ef/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c68e3d9c67b39539f7bbe8dacbc261b853e9c2ef/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h?ref=c68e3d9c67b39539f7bbe8dacbc261b853e9c2ef",
            "patch": "@@ -714,16 +714,26 @@ class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n     std::vector<RecvCallbackFunction> recv_callback_functions;\n   };\n \n-  // Gets common Execute_Args between Execute, ExecuteSharded and\n-  // ExecutePortable. device_complete_events in the return is set if the input\n+  // Returns the number of outputs of the executable.\n+  absl::StatusOr<size_t> GetNumOutputs() const;\n+\n+  // Allocates memory for the `Execute` output.\n+  // These functions are a little verbose, but allocating the correct amount of\n+  // memory on initialization (thus avoiding `resize` calls) provides a\n+  // significant performance optimization.\n+  absl::StatusOr<std::vector<std::vector<PJRT_Buffer*>>>\n+  InitializeOutputListsStorage(size_t outer_size) const;\n+  absl::StatusOr<std::vector<PJRT_Buffer**>> InitializeOutputLists(\n+      std::vector<std::vector<PJRT_Buffer*>>& c_output_lists_storage) const;\n+\n+  // Gets common Execute_Args for use in various Execute* functions.\n+  // device_complete_events in the return is set if the input\n   // device_complete_events has value.\n   absl::StatusOr<PJRT_LoadedExecutable_Execute_Args> GetCommonExecuteArgs(\n       absl::Span<const std::vector<PjRtBuffer*>> argument_handles,\n       const ExecuteOptions& options, PJRT_ExecuteOptions& c_options,\n       std::vector<std::vector<PJRT_Buffer*>>& c_argument_lists_storage,\n       std::vector<PJRT_Buffer**>& c_arguments,\n-      std::vector<std::vector<PJRT_Buffer*>>& c_output_lists_storage,\n-      std::vector<PJRT_Buffer**>& c_output_lists,\n       std::optional<std::vector<PJRT_Event*>>& device_complete_events,\n       SendRecvCallbackData& send_recv_callback_data,\n       std::vector<int64_t>& non_donatable_input_indices_storage,"
        }
    ],
    "stats": {
        "total": 93,
        "additions": 62,
        "deletions": 31
    }
}