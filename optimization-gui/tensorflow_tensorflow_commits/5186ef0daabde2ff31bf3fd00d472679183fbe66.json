{
    "author": "WillFroom",
    "message": "[XLA:CPU/GPU][XTile] Split out the tiled emitter specific constraints.\n\nThis fixes the issue with us getting invalid tiling results on CPU for reshape / bitcasts.\n\nPiperOrigin-RevId: 839170888",
    "sha": "5186ef0daabde2ff31bf3fd00d472679183fbe66",
    "files": [
        {
            "sha": "0e0243f5b6dbd5b5d8d191861a885e68cf831514",
            "filename": "third_party/xla/xla/backends/cpu/codegen/tiled/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ftiled%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ftiled%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ftiled%2FBUILD?ref=5186ef0daabde2ff31bf3fd00d472679183fbe66",
            "patch": "@@ -39,6 +39,7 @@ cc_library(\n         \"//xla:shape_util\",\n         \"//xla:util\",\n         \"//xla/backends/cpu/codegen:kernel_api_ir_builder\",\n+        \"//xla/backends/gpu/codegen/triton:tiled_emitter_constraints\",\n         \"//xla/codegen:kernel_definition\",\n         \"//xla/codegen:kernel_spec\",\n         \"//xla/codegen:mlir_kernel_source\","
        },
        {
            "sha": "719ae388f6f33813155dedbb5c03eca4f91c68c5",
            "filename": "third_party/xla/xla/backends/cpu/codegen/tiled/tiled_fusion_emitter.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ftiled%2Ftiled_fusion_emitter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ftiled%2Ftiled_fusion_emitter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Ftiled%2Ftiled_fusion_emitter.cc?ref=5186ef0daabde2ff31bf3fd00d472679183fbe66",
            "patch": "@@ -35,6 +35,7 @@ limitations under the License.\n #include \"xla/backends/cpu/codegen/kernel_api_ir_builder.h\"\n #include \"xla/backends/gpu/codegen/triton/fusion_emitter.h\"\n #include \"xla/backends/gpu/codegen/triton/ir/triton_xla_ops.h\"\n+#include \"xla/backends/gpu/codegen/triton/tiled_emitter_constraints.h\"\n #include \"xla/codegen/emitters/ir/xla_ops.h\"\n #include \"xla/codegen/emitters/kernel_api_builder.h\"\n #include \"xla/codegen/kernel_definition.h\"\n@@ -62,8 +63,9 @@ namespace xla::cpu {\n \n absl::StatusOr<std::vector<FlatTiling>> GetTiling(\n     mlir::MLIRContext& context, const HloFusionInstruction& fusion) {\n+  auto constraints_builder = TiledEmitterConstraints::GetBuilder();\n   auto symbolic_tile_analysis_or = SymbolicTileAnalysis::AnalyzeComputation(\n-      *fusion.fused_instructions_computation(), &context);\n+      *fusion.fused_instructions_computation(), &context, constraints_builder);\n   if (std::holds_alternative<FusionDecision>(symbolic_tile_analysis_or)) {\n     return Internal(\n         \"Unsupported fusion in EmitGeneric: %s\",\n@@ -210,8 +212,9 @@ absl::StatusOr<KernelDefinition<MlirKernelSource>> EmitTiledFusionKernel(\n                                                           tile_sizes.end());\n   }\n \n+  auto constraints_builder = TiledEmitterConstraints::GetBuilder();\n   TF_ASSIGN_OR_RETURN(auto module,\n-                      gpu::EmitXTileModule(name, nullptr, &fusion,\n+                      gpu::EmitXTileModule(name, constraints_builder, &fusion,\n                                            block_level_parameters, context));\n   module->setName(absl::StrCat(\"__compute_module\", \"_\", name));\n "
        },
        {
            "sha": "8d5fb6f624af7c1ea557395c6f6dd1fe01f40320",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/BUILD",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2FBUILD?ref=5186ef0daabde2ff31bf3fd00d472679183fbe66",
            "patch": "@@ -1109,3 +1109,51 @@ xla_cc_test(\n         \"@llvm-project//mlir:IR\",\n     ],\n )\n+\n+cc_library(\n+    name = \"tiled_emitter_constraints\",\n+    srcs = [\"tiled_emitter_constraints.cc\"],\n+    hdrs = [\"tiled_emitter_constraints.h\"],\n+    compatible_with = get_compatible_with_portable(),\n+    deps = [\n+        \":emitter_helpers\",\n+        \"//xla:util\",\n+        \"//xla/codegen/tiling:affine_map_evaluator\",\n+        \"//xla/codegen/tiling:constraint_expression\",\n+        \"//xla/codegen/tiling:symbolic_tile\",\n+        \"//xla/codegen/tiling:symbolic_tile_analysis\",\n+        \"//xla/codegen/tiling:symbolic_tiled_hlo_instruction\",\n+        \"//xla/hlo/analysis:indexing_analysis\",\n+        \"//xla/hlo/analysis:interval\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/utils:hlo_traversal\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/memory\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//mlir:IR\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"tiled_emitter_constraints_test\",\n+    srcs = [\"tiled_emitter_constraints_test.cc\"],\n+    deps = [\n+        \":tiled_emitter_constraints\",\n+        \"//xla/codegen/tiling:symbolic_tile_analysis\",\n+        \"//xla/codegen/tiling:tiling_specification\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n+        \"//xla/hlo/testlib:verified_hlo_module\",\n+        \"//xla/service:instruction_fusion\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:test\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+        \"@com_google_googletest//:gtest_main\",\n+        \"@llvm-project//mlir:IR\",\n+    ],\n+)"
        },
        {
            "sha": "5868858b4834c8d37a88dce6a2e1155dbd320206",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/tiled_emitter_constraints.cc",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftiled_emitter_constraints.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftiled_emitter_constraints.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftiled_emitter_constraints.cc?ref=5186ef0daabde2ff31bf3fd00d472679183fbe66",
            "patch": "@@ -0,0 +1,201 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/gpu/codegen/triton/tiled_emitter_constraints.h\"\n+\n+#include <cstdint>\n+#include <memory>\n+#include <optional>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/log/check.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/memory/memory.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_join.h\"\n+#include \"absl/types/span.h\"\n+#include \"llvm/ADT/SmallVector.h\"\n+#include \"mlir/IR/AffineExpr.h\"\n+#include \"mlir/IR/AffineMap.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/backends/gpu/codegen/triton/emitter_helpers.h\"\n+#include \"xla/codegen/tiling/affine_map_evaluator.h\"\n+#include \"xla/codegen/tiling/constraint_expression.h\"\n+#include \"xla/codegen/tiling/symbolic_tile.h\"\n+#include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n+#include \"xla/codegen/tiling/symbolic_tiled_hlo_instruction.h\"\n+#include \"xla/hlo/analysis/indexing_analysis.h\"\n+#include \"xla/hlo/analysis/indexing_map.h\"\n+#include \"xla/hlo/analysis/indexing_map_serialization.h\"\n+#include \"xla/hlo/analysis/interval.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/hlo/utils/hlo_traversal.h\"\n+#include \"xla/util.h\"\n+\n+namespace xla {\n+\n+using ::mlir::AffineExpr;\n+using ::mlir::AffineMap;\n+using ::mlir::MLIRContext;\n+\n+std::vector<TiledEmitterConstraints::CustomConstraints>\n+TiledEmitterConstraints::DeriveCustomConstraints(\n+    const std::vector<std::unique_ptr<SymbolicTiledHloInstruction>>&\n+        instructions,\n+    const HloFusionAdaptor& fusion_adaptor) {\n+  std::vector<CustomConstraints> result;\n+\n+  for (const auto& instruction : instructions) {\n+    const HloInstruction* hlo = instruction->hlo();\n+    // Don't consider operands to the fusion computation for constraints.\n+    if (!fusion_adaptor.ContainsInstruction(hlo)) {\n+      continue;\n+    }\n+\n+    // Construct custom constraints for parameters of bitcasts and reshapes\n+    // within `instructions`.\n+    if (hlo->opcode() == HloOpcode::kReshape ||\n+        hlo->opcode() == HloOpcode::kBitcast) {\n+      AffineMap size_map = instruction->symbolic_tile().size_map();\n+      MLIRContext* ctx = size_map.getContext();\n+\n+      IndexingMap reshape_indexing_map =\n+          ComputeOutputToInputIndexing(hlo, /*output_id=*/0, ctx)\n+              .indexing_maps[0]\n+              .begin()\n+              ->map();\n+\n+      std::optional<SymbolicTile> reshape_symbolic_tile =\n+          SymbolicTile::FromIndexingMap(reshape_indexing_map);\n+\n+      // Since we managed to create a `SymbolicTiledHloInstruction` for this\n+      // instruction, it should never be the case that we fail to derive a\n+      // `SymbolicTile`, so we `CHECK`. This is enforced by checks in\n+      // `SymbolicTileAnalysis`'s internal function\n+      // `ShouldProceedWithSymbolicTileDerivation`.\n+      CHECK(reshape_symbolic_tile.has_value());\n+\n+      ConstraintExpression reshape_constraints =\n+          reshape_symbolic_tile->constraints();\n+      result.push_back(\n+          CustomConstraints{size_map, std::move(reshape_constraints)});\n+      continue;\n+    }\n+\n+    // Construct emitter-specific constraints for concatenates. This allows\n+    // filtering for tile sizes that divide the concatenated dimension for all\n+    // the operands exactly.\n+    if (hlo->opcode() == HloOpcode::kConcatenate) {\n+      AffineMap size_map = instruction->symbolic_tile().size_map();\n+      MLIRContext* ctx = size_map.getContext();\n+      int concatenate_dimension_index = hlo->concatenate_dimension();\n+      AffineExpr concatenate_dimension_map_parameter =\n+          mlir::getAffineDimExpr(concatenate_dimension_index, ctx);\n+\n+      // Check that each operand's concatenation dimension is divisible by the\n+      // tile size along this dimension.\n+      ConstraintExpression divisibility_constraints =\n+          ConstraintExpression::GetAlwaysSatisfied();\n+\n+      // The last operand of the concat does not require the divisibility\n+      // constraint.\n+      for (int operand_id = 0; operand_id < hlo->operand_count() - 1;\n+           ++operand_id) {\n+        const HloInstruction* operand = hlo->operand(operand_id);\n+        AffineExpr operand_concat_dimension = mlir::getAffineConstantExpr(\n+            operand->shape().dimensions(concatenate_dimension_index), ctx);\n+        ConstraintExpression::Constraint divisibility_constraint{\n+            operand_concat_dimension % concatenate_dimension_map_parameter,\n+            Interval{0, 0}};\n+        divisibility_constraints =\n+            divisibility_constraints && divisibility_constraint;\n+      }\n+\n+      result.push_back(\n+          CustomConstraints{size_map, std::move(divisibility_constraints)});\n+\n+      AffineMap identity_map =\n+          AffineMap::getMultiDimIdentityMap(size_map.getNumDims(), ctx);\n+\n+      // Check that the offset along the contracting dimension is 0.\n+      ConstraintExpression::Constraint offset_constraint{\n+          instruction->symbolic_tile().offset_map().getResult(\n+              concatenate_dimension_index),\n+          Interval{0, 0}};\n+      result.push_back(CustomConstraints{\n+          identity_map, ConstraintExpression(offset_constraint)});\n+\n+      // Check that the stride along the contracting dimension is 1.\n+      ConstraintExpression::Constraint stride_constraint{\n+          instruction->symbolic_tile().stride_map().getResult(\n+              concatenate_dimension_index),\n+          Interval{1, 1}};\n+      result.push_back(CustomConstraints{\n+          identity_map, ConstraintExpression(stride_constraint)});\n+      continue;\n+    }\n+  }\n+\n+  return result;\n+}\n+\n+std::unique_ptr<TiledEmitterConstraints> TiledEmitterConstraints::Create(\n+    const std::vector<std::unique_ptr<SymbolicTiledHloInstruction>>&\n+        instructions,\n+    const HloFusionAdaptor& fusion_adaptor) {\n+  std::vector<CustomConstraints> custom_constraints =\n+      DeriveCustomConstraints(instructions, fusion_adaptor);\n+\n+  return std::unique_ptr<TiledEmitterConstraints>(absl::WrapUnique(\n+      new TiledEmitterConstraints(std::move(custom_constraints))));\n+}\n+\n+EmitterSpecificConstraintsBuilder TiledEmitterConstraints::GetBuilder() {\n+  return [=](const std::vector<std::unique_ptr<SymbolicTiledHloInstruction>>&\n+                 instructions,\n+             const HloFusionAdaptor& fusion_adaptor) {\n+    return Create(instructions, fusion_adaptor);\n+  };\n+}\n+\n+absl::StatusOr<bool> TiledEmitterConstraints::ParametersSatisfyConstraints(\n+    absl::Span<const int64_t> tile_parameters) const {\n+  // Ensure that we satisfy the custom constraints we derived when padding tile\n+  // sizes to a power of 2. This is a workaround while nested fusions are not\n+  // landed.\n+  //\n+  // TODO(b/365727080): get rid of this once tiling is using power of twos\n+  // everywhere, including when propagating into the prologue of reductions.\n+  VLOG(5) << \"Checking custom constraints for tile parameters: \"\n+          << absl::StrJoin(tile_parameters, \", \");\n+  for (const auto& custom_constraint : custom_constraints_) {\n+    VLOG(5) << \"Checking custom constraint: transform  \"\n+            << xla::ToString(custom_constraint.tile_parameters_transform)\n+            << \" constraints \" << custom_constraint.constraints.ToString();\n+    llvm::SmallVector<int64_t> transformed_tile_parameters =\n+        EvaluateAffineMap(custom_constraint.tile_parameters_transform,\n+                          /*dim_values=*/tile_parameters);\n+    if (!custom_constraint.constraints.IsSatisfiedBy(\n+            xtile::GetPaddedTileSizes(transformed_tile_parameters))) {\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+}  // namespace xla"
        },
        {
            "sha": "6ea21780a2d51b5bc5e5fc78a5a9e90e641dab7e",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/tiled_emitter_constraints.h",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftiled_emitter_constraints.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftiled_emitter_constraints.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftiled_emitter_constraints.h?ref=5186ef0daabde2ff31bf3fd00d472679183fbe66",
            "patch": "@@ -0,0 +1,88 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_BACKENDS_GPU_CODEGEN_TRITON_TILED_EMITTER_CONSTRAINTS_H_\n+#define XLA_BACKENDS_GPU_CODEGEN_TRITON_TILED_EMITTER_CONSTRAINTS_H_\n+\n+#include <cstdint>\n+#include <memory>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"mlir/IR/AffineMap.h\"\n+#include \"xla/codegen/tiling/constraint_expression.h\"\n+#include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n+#include \"xla/codegen/tiling/symbolic_tiled_hlo_instruction.h\"\n+#include \"xla/hlo/utils/hlo_traversal.h\"\n+\n+namespace xla {\n+\n+// Constraints that are intrinsic to the tiled emitter itself that would\n+// otherwise result in tiling that would not be possible to emit.\n+class TiledEmitterConstraints : public EmitterSpecificConstraints {\n+ public:\n+  static std::unique_ptr<TiledEmitterConstraints> Create(\n+      const std::vector<std::unique_ptr<SymbolicTiledHloInstruction>>&,\n+      const HloFusionAdaptor&);\n+\n+  static EmitterSpecificConstraintsBuilder GetBuilder();\n+\n+  absl::StatusOr<bool> ParametersSatisfyConstraints(\n+      absl::Span<const int64_t> tile_parameters) const override;\n+\n+ private:\n+  // Holds a constraint expression over derived parameters (d'0, ..., d'm) where\n+  //   (d'0, ..., d'm) = tile_parameters_transform(tile_parameters).\n+  struct CustomConstraints {\n+    mlir::AffineMap tile_parameters_transform;\n+    ConstraintExpression constraints;\n+  };\n+\n+  explicit TiledEmitterConstraints(\n+      std::vector<CustomConstraints> custom_constraints)\n+      : custom_constraints_(std::move(custom_constraints)) {}\n+\n+  // Derives a vector of `CustomConstraints` to be checked within\n+  // `ParametersSatisfyConstraints` from a vector of\n+  // `SymbolicTiledHloInstruction`s representing a symbolically tiled HLO\n+  // computation. The fusion adaptor is used to figure out which instructions\n+  // within the computation are operands of the fusion.\n+  //\n+  // Currently, this is used to work around an issue with reshapes/bitcasts when\n+  // instructions are tiled with non-power-of-2 shapes. The resulting custom\n+  // constraints contain\n+  //   * the reshape/bitcast's tile size map; this to allow deriving the\n+  //     output tile sizes for the reshape/bitcast instruction;\n+  //   * the constraint expression corresponding to the SymbolicTile derived\n+  //     from the reshape/bitcast instruction's output-to-input indexing map\n+  //     \"in a vacuum\" (i.e., without composing with any other indexing map).\n+  //\n+  // TODO(b/365727080): move tile derivation to support power of 2 tiles\n+  // everywhere, and deprecate this.\n+  static std::vector<CustomConstraints> DeriveCustomConstraints(\n+      const std::vector<std::unique_ptr<SymbolicTiledHloInstruction>>&\n+          instructions,\n+      const HloFusionAdaptor& fusion_adaptor);\n+\n+  // Custom emitter-specific constraints to check in\n+  // `ParametersSatisfyConstraints`.\n+  std::vector<CustomConstraints> custom_constraints_;\n+};\n+\n+}  // namespace xla\n+\n+#endif  // XLA_BACKENDS_GPU_CODEGEN_TRITON_TILED_EMITTER_CONSTRAINTS_H_"
        },
        {
            "sha": "4cfa4f7507acde2158e9758517190ef716ad1aa7",
            "filename": "third_party/xla/xla/backends/gpu/codegen/triton/tiled_emitter_constraints_test.cc",
            "status": "added",
            "additions": 285,
            "deletions": 0,
            "changes": 285,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftiled_emitter_constraints_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftiled_emitter_constraints_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcodegen%2Ftriton%2Ftiled_emitter_constraints_test.cc?ref=5186ef0daabde2ff31bf3fd00d472679183fbe66",
            "patch": "@@ -0,0 +1,285 @@\n+/* Copyright 2024 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/gpu/codegen/triton/tiled_emitter_constraints.h\"\n+\n+#include <memory>\n+#include <optional>\n+#include <utility>\n+#include <variant>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status_matchers.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n+#include \"xla/codegen/tiling/tiling_specification.h\"\n+#include \"xla/hlo/ir/hlo_computation.h\"\n+#include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/hlo/testlib/hlo_hardware_independent_test_base.h\"\n+#include \"xla/hlo/testlib/verified_hlo_module.h\"\n+#include \"xla/service/instruction_fusion.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/test.h\"\n+\n+namespace xla {\n+namespace {\n+\n+class TiledEmitterConstraintsTest : public HloHardwareIndependentTestBase {\n+ public:\n+  std::optional<SymbolicTileAnalysis> TryAnalyzeModule(\n+      HloModule* module, bool with_tiled_emitter_specific_constraints = true) {\n+    EmitterSpecificConstraintsBuilder constraints_builder = nullptr;\n+\n+    if (with_tiled_emitter_specific_constraints) {\n+      constraints_builder = TiledEmitterConstraints::GetBuilder();\n+    }\n+\n+    SymbolicTileAnalysisOrError analysis_or_error =\n+        SymbolicTileAnalysis::AnalyzeComputation(\n+            *module->entry_computation()\n+                 ->root_instruction()\n+                 ->fused_instructions_computation(),\n+            &mlir_context_, constraints_builder);\n+\n+    if (std::holds_alternative<SymbolicTileAnalysis>(analysis_or_error)) {\n+      return std::get<SymbolicTileAnalysis>(std::move(analysis_or_error));\n+    }\n+    VLOG(1) << \"Cannot analyze module: \"\n+            << std::get<FusionDecision>(analysis_or_error).Explain();\n+    return std::nullopt;\n+  }\n+\n+  mlir::MLIRContext mlir_context_;\n+};\n+\n+TEST_F(TiledEmitterConstraintsTest, CustomReshapeConstraintsAreEnforced) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+triton_computation {\n+  p = s8[36] parameter(0)\n+  ROOT bitcast = s8[6,6] bitcast(p)\n+}\n+\n+ENTRY entry_computation {\n+  p = s8[36] parameter(0)\n+  ROOT fusion = s8[6,6] fusion(p), kind=kCustom, calls=triton_computation\n+})\"));\n+\n+  std::optional<SymbolicTileAnalysis> analysis_without_tiling_constraints =\n+      TryAnalyzeModule(module.get(),\n+                       /*with_tiled_emitter_specific_constraints=*/false);\n+  ASSERT_TRUE(analysis_without_tiling_constraints.has_value());\n+  const HloInstruction* fusion_root =\n+      module->entry_computation()->root_instruction()->fused_expression_root();\n+\n+  Tiling tiling({{fusion_root, FlatTiling({2, 6})}});\n+\n+  // (2, 6) is a theoretically valid tiling for this reshape, so\n+  // SymbolicTileAnalysis should allow it.\n+  EXPECT_THAT(\n+      analysis_without_tiling_constraints->ParametersSatisfyConstraints(tiling),\n+      absl_testing::IsOkAndHolds(true));\n+\n+  std::optional<SymbolicTileAnalysis> analysis_with_tiling_constraints =\n+      TryAnalyzeModule(module.get(),\n+                       /*with_tiled_emitter_specific_constraints=*/true);\n+\n+  ASSERT_TRUE(analysis_with_tiling_constraints.has_value());\n+\n+  // (2, 6) is a theoretically valid tiling for this reshape, but it won't\n+  // work because of Triton's power of two restriction. Thus, we should reject\n+  // it here.\n+  EXPECT_THAT(\n+      analysis_with_tiling_constraints->ParametersSatisfyConstraints(tiling),\n+      absl_testing::IsOkAndHolds(false));\n+\n+  // However, (1, 6) is valid and should still work.\n+  EXPECT_THAT(analysis_with_tiling_constraints->ParametersSatisfyConstraints(\n+                  Tiling({{fusion_root, FlatTiling({1, 6})}})),\n+              absl_testing::IsOkAndHolds(true));\n+}\n+\n+TEST_F(TiledEmitterConstraintsTest,\n+       CustomConcatenateSizeConstraintsAreEnforced) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+concatenate {\n+  p0 = bf16[8] parameter(0)\n+  p1 = bf16[8] parameter(1)\n+  p2 = bf16[4] parameter(2)\n+  ROOT concatenate = bf16[20] concatenate(p0, p1, p2), dimensions={0}\n+}\n+\n+ENTRY main {\n+  p0 = bf16[8] parameter(0)\n+  p1 = bf16[8] parameter(1)\n+  p2 = bf16[4] parameter(2)\n+  ROOT fusion = bf16[20] fusion(p0, p1, p2),\n+    kind=kCustom, calls=concatenate, backend_config={\"fusion_backend_config\":{\n+      \"kind\":\"__triton_nested_gemm_fusion\"}}\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis_without_tiling_constraints =\n+      TryAnalyzeModule(module.get(),\n+                       /*with_tiled_emitter_specific_constraints=*/false);\n+  ASSERT_TRUE(analysis_without_tiling_constraints.has_value());\n+  const HloInstruction* fusion_root =\n+      module->entry_computation()->root_instruction()->fused_expression_root();\n+\n+  // (16,) is a theoretically valid tiling for this concatenate, so\n+  // SymbolicTileAnalysis should allow it.\n+  EXPECT_THAT(analysis_without_tiling_constraints->ParametersSatisfyConstraints(\n+                  Tiling({{fusion_root, FlatTiling({16})}})),\n+              absl_testing::IsOkAndHolds(true));\n+\n+  std::optional<SymbolicTileAnalysis> analysis_with_tiling_constraints =\n+      TryAnalyzeModule(module.get(),\n+                       /*with_tiled_emitter_specific_constraints=*/true);\n+\n+  ASSERT_TRUE(analysis_with_tiling_constraints.has_value());\n+\n+  // (16,) is a theoretically valid tiling for this concatenate, but it won't\n+  // work in our lowering for now, because we want to be loading from a single\n+  // operand at a time, and it doesn't divide each operand's concatenation\n+  // dimension. We want to reject it here.\n+  //\n+  // Note: this is perfectly OK to expand later as our codegen improves to\n+  // handle this case.\n+  EXPECT_THAT(analysis_with_tiling_constraints->ParametersSatisfyConstraints(\n+                  Tiling({{fusion_root, FlatTiling({16})}})),\n+              absl_testing::IsOkAndHolds(false));\n+\n+  // However, (8,) is valid and should still work.\n+  EXPECT_THAT(analysis_with_tiling_constraints->ParametersSatisfyConstraints(\n+                  Tiling({{fusion_root, FlatTiling({8})}})),\n+              absl_testing::IsOkAndHolds(true));\n+}\n+\n+TEST_F(TiledEmitterConstraintsTest,\n+       ConcatenateConstrainsOffsetToBeZeroAlongConcatenationDimension) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+concatenate {\n+  p0 = bf16[16] parameter(0)\n+  p1 = bf16[16] parameter(1)\n+  p2 = bf16[16] parameter(2)\n+  concatenate = bf16[48] concatenate(p0, p1, p2), dimensions={0}\n+  ROOT slice = bf16[24] slice(concatenate), slice={[24:48]}\n+}\n+\n+ENTRY main {\n+  p0 = bf16[16] parameter(0)\n+  p1 = bf16[16] parameter(1)\n+  p2 = bf16[16] parameter(2)\n+  ROOT fusion = bf16[24] fusion(p0, p1, p2),\n+    kind=kCustom, calls=concatenate, backend_config={\"fusion_backend_config\":{\n+      \"kind\":\"__triton_nested_gemm_fusion\"}}\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis_without_tiling_constraints =\n+      TryAnalyzeModule(module.get(),\n+                       /*with_tiled_emitter_specific_constraints=*/false);\n+  ASSERT_TRUE(analysis_without_tiling_constraints.has_value());\n+  const HloInstruction* fusion_root =\n+      module->entry_computation()->root_instruction()->fused_expression_root();\n+\n+  // (8,) is a theoretically valid tiling for this concatenate, and one that\n+  // works for all operands, so SymbolicTileAnalysis should allow it.\n+  EXPECT_THAT(analysis_without_tiling_constraints->ParametersSatisfyConstraints(\n+                  Tiling({{fusion_root, FlatTiling({8})}})),\n+              absl_testing::IsOkAndHolds(true));\n+\n+  std::optional<SymbolicTileAnalysis> analysis_with_tiling_constraints =\n+      TryAnalyzeModule(module.get(),\n+                       /*with_tiled_emitter_specific_constraints=*/true);\n+\n+  ASSERT_TRUE(analysis_with_tiling_constraints.has_value());\n+\n+  // (8,) is a theoretically valid tiling for this concatenate, but the\n+  // constraints enforce that the offset along the concatenation dimension be 0.\n+  // Here, it is 24, so we expect the tiling to be rejected.\n+  //\n+  // Note: this is perfectly OK to expand later as our codegen improves to\n+  // handle this case.\n+  EXPECT_THAT(analysis_with_tiling_constraints->ParametersSatisfyConstraints(\n+                  Tiling({{fusion_root, FlatTiling({8})}})),\n+              absl_testing::IsOkAndHolds(false));\n+\n+  // Even the smallest tiling, (1,) should be rejected here. (This is\n+  // unnecessary in theory, but a sanity check for the implementation).\n+  EXPECT_THAT(analysis_with_tiling_constraints->ParametersSatisfyConstraints(\n+                  Tiling({{fusion_root, FlatTiling({1})}})),\n+              absl_testing::IsOkAndHolds(false));\n+}\n+\n+TEST_F(TiledEmitterConstraintsTest,\n+       ConcatenateConstrainsStrideToBeOneAlongConcatenationDimension) {\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(R\"(\n+concatenate {\n+  p0 = bf16[16] parameter(0)\n+  p1 = bf16[16] parameter(1)\n+  p2 = bf16[16] parameter(2)\n+  concatenate = bf16[48] concatenate(p0, p1, p2), dimensions={0}\n+  ROOT slice = bf16[24] slice(concatenate), slice={[0:48:2]}\n+}\n+\n+ENTRY main {\n+  p0 = bf16[16] parameter(0)\n+  p1 = bf16[16] parameter(1)\n+  p2 = bf16[16] parameter(2)\n+  ROOT fusion = bf16[24] fusion(p0, p1, p2),\n+    kind=kCustom, calls=concatenate, backend_config={\"fusion_backend_config\":{\n+      \"kind\":\"__triton_nested_gemm_fusion\"}}\n+})\"));\n+  std::optional<SymbolicTileAnalysis> analysis_without_tiling_constraints =\n+      TryAnalyzeModule(module.get(),\n+                       /*with_tiled_emitter_specific_constraints=*/false);\n+  ASSERT_TRUE(analysis_without_tiling_constraints.has_value());\n+  const HloInstruction* fusion_root =\n+      module->entry_computation()->root_instruction()->fused_expression_root();\n+\n+  // (8,) is a theoretically valid tiling for this concatenate, and one that\n+  // works for all operands, so SymbolicTileAnalysis should allow it.\n+  EXPECT_THAT(analysis_without_tiling_constraints->ParametersSatisfyConstraints(\n+                  Tiling({{fusion_root, FlatTiling({8})}})),\n+              absl_testing::IsOkAndHolds(true));\n+\n+  std::optional<SymbolicTileAnalysis> analysis_with_tiling_constraints =\n+      TryAnalyzeModule(module.get(),\n+                       /*with_tiled_emitter_specific_constraints=*/true);\n+\n+  ASSERT_TRUE(analysis_with_tiling_constraints.has_value());\n+\n+  // (8,) is a theoretically valid tiling for this concatenate, but the\n+  // constraints enforce that the stride along the concatenation dimension be 1.\n+  // Here, it is 2, so we expect the tiling to be rejected.\n+  //\n+  // Note: this is perfectly OK to expand later as our codegen improves to\n+  // handle this case.\n+  EXPECT_THAT(analysis_with_tiling_constraints->ParametersSatisfyConstraints(\n+                  Tiling({{fusion_root, FlatTiling({8})}})),\n+              absl_testing::IsOkAndHolds(false));\n+\n+  // Even the smallest tiling, (1,) should be rejected here. (This is\n+  // unnecessary in theory, but a sanity check for the implementation).\n+  EXPECT_THAT(analysis_with_tiling_constraints->ParametersSatisfyConstraints(\n+                  Tiling({{fusion_root, FlatTiling({1})}})),\n+              absl_testing::IsOkAndHolds(false));\n+}\n+\n+}  // namespace\n+}  // namespace xla"
        },
        {
            "sha": "61c46d5ed046939306539f07b98b12e894990cc9",
            "filename": "third_party/xla/xla/service/gpu/model/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2FBUILD?ref=5186ef0daabde2ff31bf3fd00d472679183fbe66",
            "patch": "@@ -614,14 +614,14 @@ cc_library(\n     deps = [\n         \"//xla:shape_util\",\n         \"//xla:util\",\n+        \"//xla/backends/gpu/codegen/triton:tiled_emitter_constraints\",\n         \"//xla/codegen/tiling:affine_map_evaluator\",\n         \"//xla/codegen/tiling:constraint_expression\",\n         \"//xla/codegen/tiling:symbolic_tile\",\n         \"//xla/codegen/tiling:symbolic_tile_analysis\",\n         \"//xla/codegen/tiling:symbolic_tiled_hlo_instruction\",\n         \"//xla/hlo/analysis:indexing_analysis\",\n         \"//xla/hlo/analysis:interval\",\n-        \"//xla/hlo/analysis:symbolic_expr\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/utils:hlo_traversal\",\n         \"//xla/stream_executor:device_description\","
        },
        {
            "sha": "71ab8bc4cc20b9db78703a852c2640f2c3964887",
            "filename": "third_party/xla/xla/service/gpu/model/triton_emitter_constraints.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 92,
            "changes": 99,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Ftriton_emitter_constraints.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Ftriton_emitter_constraints.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Ftriton_emitter_constraints.cc?ref=5186ef0daabde2ff31bf3fd00d472679183fbe66",
            "patch": "@@ -17,7 +17,6 @@ limitations under the License.\n \n #include <cstdint>\n #include <memory>\n-#include <optional>\n #include <utility>\n #include <vector>\n \n@@ -34,17 +33,14 @@ limitations under the License.\n #include \"llvm/Support/MathExtras.h\"\n #include \"mlir/IR/AffineExpr.h\"\n #include \"mlir/IR/AffineMap.h\"\n-#include \"mlir/IR/MLIRContext.h\"\n+#include \"xla/backends/gpu/codegen/triton/tiled_emitter_constraints.h\"\n #include \"xla/codegen/tiling/affine_map_evaluator.h\"\n #include \"xla/codegen/tiling/constraint_expression.h\"\n #include \"xla/codegen/tiling/symbolic_tile.h\"\n #include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n #include \"xla/codegen/tiling/symbolic_tiled_hlo_instruction.h\"\n-#include \"xla/hlo/analysis/indexing_analysis.h\"\n-#include \"xla/hlo/analysis/indexing_map.h\"\n #include \"xla/hlo/analysis/indexing_map_serialization.h\"\n #include \"xla/hlo/analysis/interval.h\"\n-#include \"xla/hlo/analysis/symbolic_expr.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n #include \"xla/hlo/utils/hlo_traversal.h\"\n@@ -59,7 +55,6 @@ namespace {\n \n using ::mlir::AffineExpr;\n using ::mlir::AffineMap;\n-using ::mlir::MLIRContext;\n \n // Triton enforces that all tensors in the program have less than 1048576\n // elements, otherwise it will fail to compile. (See `TRITON_MAX_TENSOR_NUMEL`\n@@ -112,90 +107,6 @@ TritonEmitterConstraints::DeriveCustomConstraints(\n       }\n       continue;\n     }\n-\n-    // Construct custom constraints for parameters of bitcasts and reshapes\n-    // within `instructions`.\n-    if (hlo->opcode() == HloOpcode::kReshape ||\n-        hlo->opcode() == HloOpcode::kBitcast) {\n-      MLIRContext* ctx = instruction->symbolic_tile().size_map().getContext();\n-\n-      // TODO(b/446856820): Remove this once we use SymbolicMap here and\n-      // therefore we can get the context directly.\n-      IndexingMap reshape_indexing_map =\n-          ComputeOutputToInputIndexing(hlo, /*output_id=*/0, ctx)\n-              .indexing_maps[0]\n-              .begin()\n-              ->map();\n-\n-      std::optional<SymbolicTile> reshape_symbolic_tile =\n-          SymbolicTile::FromIndexingMap(reshape_indexing_map);\n-\n-      // Since we managed to create a `SymbolicTiledHloInstruction` for this\n-      // instruction, it should never be the case that we fail to derive a\n-      // `SymbolicTile`, so we `CHECK`. This is enforced by checks in\n-      // `SymbolicTileAnalysis`'s internal function\n-      // `ShouldProceedWithSymbolicTileDerivation`.\n-      CHECK(reshape_symbolic_tile.has_value());\n-\n-      ConstraintExpression reshape_constraints =\n-          reshape_symbolic_tile->constraints();\n-      result.push_back(\n-          CustomConstraints{instruction->symbolic_tile().size_map(),\n-                            std::move(reshape_constraints)});\n-      continue;\n-    }\n-\n-    // Construct emitter-specific constraints for concatenates. This allows\n-    // filtering for tile sizes that divide the concatenated dimension for all\n-    // the operands exactly.\n-    if (hlo->opcode() == HloOpcode::kConcatenate) {\n-      AffineMap size_map = instruction->symbolic_tile().size_map();\n-      MLIRContext* ctx = size_map.getContext();\n-      int concatenate_dimension_index = hlo->concatenate_dimension();\n-      AffineExpr concatenate_dimension_map_parameter =\n-          mlir::getAffineDimExpr(concatenate_dimension_index, ctx);\n-\n-      // Check that each operand's concatenation dimension is divisible by the\n-      // tile size along this dimension.\n-      ConstraintExpression divisibility_constraints =\n-          ConstraintExpression::GetAlwaysSatisfied();\n-\n-      // The last operand of the concat does not require the divisibility\n-      // constraint.\n-      for (int operand_id = 0; operand_id < hlo->operand_count() - 1;\n-           ++operand_id) {\n-        const HloInstruction* operand = hlo->operand(operand_id);\n-        AffineExpr operand_concat_dimension = mlir::getAffineConstantExpr(\n-            operand->shape().dimensions(concatenate_dimension_index), ctx);\n-        ConstraintExpression::Constraint divisibility_constraint{\n-            operand_concat_dimension % concatenate_dimension_map_parameter,\n-            Interval{0, 0}};\n-        divisibility_constraints =\n-            divisibility_constraints && divisibility_constraint;\n-      }\n-\n-      result.push_back(\n-          CustomConstraints{size_map, std::move(divisibility_constraints)});\n-\n-      AffineMap identity_map =\n-          AffineMap::getMultiDimIdentityMap(size_map.getNumDims(), ctx);\n-\n-      // Check that the offset along the contracting dimension is 0.\n-      ConstraintExpression::Constraint offset_constraint{\n-          instruction->symbolic_tile().offset_map().getResult(\n-              concatenate_dimension_index),\n-          Interval{0, 0}};\n-      result.push_back(CustomConstraints{\n-          identity_map, ConstraintExpression(offset_constraint)});\n-\n-      // Check that the stride along the contracting dimension is 1.\n-      ConstraintExpression::Constraint stride_constraint{\n-          instruction->symbolic_tile().stride_map().getResult(\n-              concatenate_dimension_index),\n-          Interval{1, 1}};\n-      result.push_back(CustomConstraints{\n-          identity_map, ConstraintExpression(stride_constraint)});\n-    }\n   }\n \n   return result;\n@@ -231,12 +142,15 @@ TritonEmitterConstraints::GetBuilder(\n     llvm::SmallVector<AffineMap, 4> tile_size_maps(\n         unique_tile_size_maps.begin(), unique_tile_size_maps.end());\n \n+    std::unique_ptr<TiledEmitterConstraints> tiled_emitter_constraints =\n+        TiledEmitterConstraints::Create(instructions, fusion_adaptor);\n+\n     return std::unique_ptr<TritonEmitterConstraints>(\n         absl::WrapUnique(new TritonEmitterConstraints(\n             std::move(tile_size_maps), std::move(root_infos),\n             std::move(custom_constraints),\n             /*root_shape=*/instructions.back()->hlo()->shape(),\n-            device_description)));\n+            device_description, std::move(tiled_emitter_constraints))));\n   };\n }\n \n@@ -345,7 +259,8 @@ absl::StatusOr<bool> TritonEmitterConstraints::ParametersSatisfyConstraints(\n     }\n   }\n \n-  return true;\n+  return tiled_emitter_constraints_->ParametersSatisfyConstraints(\n+      tile_parameters);\n }\n \n }  // namespace gpu"
        },
        {
            "sha": "3d091730918d1f3de41504eba64a73457ad59fec",
            "filename": "third_party/xla/xla/service/gpu/model/triton_emitter_constraints.h",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Ftriton_emitter_constraints.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Ftriton_emitter_constraints.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Ftriton_emitter_constraints.h?ref=5186ef0daabde2ff31bf3fd00d472679183fbe66",
            "patch": "@@ -22,6 +22,7 @@ limitations under the License.\n #include \"absl/types/span.h\"\n #include \"llvm/ADT/SmallVector.h\"\n #include \"mlir/IR/AffineMap.h\"\n+#include \"xla/backends/gpu/codegen/triton/tiled_emitter_constraints.h\"\n #include \"xla/codegen/tiling/constraint_expression.h\"\n #include \"xla/codegen/tiling/symbolic_tile_analysis.h\"\n #include \"xla/codegen/tiling/symbolic_tiled_hlo_instruction.h\"\n@@ -66,12 +67,14 @@ class TritonEmitterConstraints : public EmitterSpecificConstraints {\n       llvm::SmallVector<mlir::AffineMap, 4> tile_size_maps,\n       llvm::SmallVector<RootTileInfo, 2> roots,\n       std::vector<CustomConstraints> custom_constraints,\n-      const Shape& root_shape, const se::DeviceDescription& device_info)\n+      const Shape& root_shape, const se::DeviceDescription& device_info,\n+      std::unique_ptr<TiledEmitterConstraints> tiled_emitter_constraints)\n       : tile_size_maps_(std::move(tile_size_maps)),\n         roots_(std::move(roots)),\n         custom_constraints_(std::move(custom_constraints)),\n         root_shape_(root_shape),\n-        device_info_(device_info) {}\n+        device_info_(device_info),\n+        tiled_emitter_constraints_(std::move(tiled_emitter_constraints)) {}\n \n   // Derives a vector of `CustomConstraints` to be checked within\n   // `ParametersSatisfyConstraints` from a vector of\n@@ -114,6 +117,8 @@ class TritonEmitterConstraints : public EmitterSpecificConstraints {\n   Shape root_shape_;\n \n   se::DeviceDescription device_info_;\n+\n+  std::unique_ptr<TiledEmitterConstraints> tiled_emitter_constraints_;\n };\n \n }  // namespace gpu"
        },
        {
            "sha": "8be49e50bd197ae884d354959be6081d0b0da82c",
            "filename": "third_party/xla/xla/service/gpu/model/triton_emitter_constraints_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 243,
            "changes": 243,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Ftriton_emitter_constraints_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5186ef0daabde2ff31bf3fd00d472679183fbe66/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Ftriton_emitter_constraints_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Ftriton_emitter_constraints_test.cc?ref=5186ef0daabde2ff31bf3fd00d472679183fbe66",
            "patch": "@@ -196,249 +196,6 @@ ENTRY entry_computation {\n               absl_testing::IsOkAndHolds(false));\n }\n \n-TEST_F(TritonEmitterConstraintsTest, CustomReshapeConstraintsAreEnforced) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-triton_computation {\n-  p = s8[36] parameter(0)\n-  ROOT bitcast = s8[6,6] bitcast(p)\n-}\n-\n-ENTRY entry_computation {\n-  p = s8[36] parameter(0)\n-  ROOT fusion = s8[6,6] fusion(p), kind=kCustom, calls=triton_computation\n-})\"));\n-\n-  std::optional<SymbolicTileAnalysis> analysis_without_triton_constraints =\n-      TryAnalyzeModule(module.get(),\n-                       /*with_triton_emitter_specific_constraints=*/false);\n-  ASSERT_TRUE(analysis_without_triton_constraints.has_value());\n-  const HloInstruction* fusion_root =\n-      module->entry_computation()->root_instruction()->fused_expression_root();\n-\n-  Tiling tiling({{fusion_root, FlatTiling({2, 6})}});\n-\n-  // (2, 6) is a theoretically valid tiling for this reshape, so\n-  // SymbolicTileAnalysis should allow it.\n-  EXPECT_THAT(\n-      analysis_without_triton_constraints->ParametersSatisfyConstraints(tiling),\n-      absl_testing::IsOkAndHolds(true));\n-\n-  std::optional<SymbolicTileAnalysis> analysis_with_triton_constraints =\n-      TryAnalyzeModule(module.get(),\n-                       /*with_triton_emitter_specific_constraints=*/true);\n-\n-  ASSERT_TRUE(analysis_with_triton_constraints.has_value());\n-\n-  // (2, 6) is a theoretically valid tiling for this reshape, but it won't\n-  // work because of Triton's power of two restriction. Thus, we should reject\n-  // it here.\n-  EXPECT_THAT(\n-      analysis_with_triton_constraints->ParametersSatisfyConstraints(tiling),\n-      absl_testing::IsOkAndHolds(false));\n-\n-  // However, (1, 6) is valid and should still work.\n-  EXPECT_THAT(analysis_with_triton_constraints->ParametersSatisfyConstraints(\n-                  Tiling({{fusion_root, FlatTiling({1, 6})}})),\n-              absl_testing::IsOkAndHolds(true));\n-}\n-\n-TEST_F(TritonEmitterConstraintsTest,\n-       ReshapeConstraintsAreNotDerivedForFusionOperands) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-triton_computation {\n-  p = s8[6,6] parameter(0)\n-  ROOT add = s8[6,6] add(p, p)\n-}\n-\n-ENTRY entry_computation {\n-  p = s8[36] parameter(0)\n-  bitcast = s8[6,6] bitcast(p)\n-  ROOT fusion = s8[6,6] fusion(bitcast),\n-    kind=kCustom, calls=triton_computation\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis = TryAnalyzeModule(module.get());\n-  ASSERT_TRUE(analysis.has_value());\n-\n-  const HloComputation* triton_computation =\n-      FindComputation(module.get(), \"triton_computation\");\n-\n-  std::unique_ptr<EmitterSpecificConstraints> constraints =\n-      TritonEmitterConstraints::GetBuilder(device_description_)(\n-          analysis->GetSymbolicTiledHloComputation(),\n-          *HloFusionAdaptor::ForComputation(triton_computation));\n-  EXPECT_FALSE(reinterpret_cast<TritonEmitterConstraints*>(constraints.get())\n-                   ->HasCustomConstraints());\n-}\n-\n-TEST_F(TritonEmitterConstraintsTest,\n-       CustomConcatenateSizeConstraintsAreEnforced) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-concatenate {\n-  p0 = bf16[8] parameter(0)\n-  p1 = bf16[8] parameter(1)\n-  p2 = bf16[4] parameter(2)\n-  ROOT concatenate = bf16[20] concatenate(p0, p1, p2), dimensions={0}\n-}\n-\n-ENTRY main {\n-  p0 = bf16[8] parameter(0)\n-  p1 = bf16[8] parameter(1)\n-  p2 = bf16[4] parameter(2)\n-  ROOT fusion = bf16[20] fusion(p0, p1, p2),\n-    kind=kCustom, calls=concatenate, backend_config={\"fusion_backend_config\":{\n-      \"kind\":\"__triton_nested_gemm_fusion\"}}\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis_without_triton_constraints =\n-      TryAnalyzeModule(module.get(),\n-                       /*with_triton_emitter_specific_constraints=*/false);\n-  ASSERT_TRUE(analysis_without_triton_constraints.has_value());\n-  const HloInstruction* fusion_root =\n-      module->entry_computation()->root_instruction()->fused_expression_root();\n-\n-  // (16,) is a theoretically valid tiling for this concatenate, so\n-  // SymbolicTileAnalysis should allow it.\n-  EXPECT_THAT(analysis_without_triton_constraints->ParametersSatisfyConstraints(\n-                  Tiling({{fusion_root, FlatTiling({16})}})),\n-              absl_testing::IsOkAndHolds(true));\n-\n-  std::optional<SymbolicTileAnalysis> analysis_with_triton_constraints =\n-      TryAnalyzeModule(module.get(),\n-                       /*with_triton_emitter_specific_constraints=*/true);\n-\n-  ASSERT_TRUE(analysis_with_triton_constraints.has_value());\n-\n-  // (16,) is a theoretically valid tiling for this concatenate, but it won't\n-  // work in our lowering for now, because we want to be loading from a single\n-  // operand at a time, and it doesn't divide each operand's concatenation\n-  // dimension. We want to reject it here.\n-  //\n-  // Note: this is perfectly OK to expand later as our codegen improves to\n-  // handle this case.\n-  EXPECT_THAT(analysis_with_triton_constraints->ParametersSatisfyConstraints(\n-                  Tiling({{fusion_root, FlatTiling({16})}})),\n-              absl_testing::IsOkAndHolds(false));\n-\n-  // However, (8,) is valid and should still work.\n-  EXPECT_THAT(analysis_with_triton_constraints->ParametersSatisfyConstraints(\n-                  Tiling({{fusion_root, FlatTiling({8})}})),\n-              absl_testing::IsOkAndHolds(true));\n-}\n-\n-TEST_F(TritonEmitterConstraintsTest,\n-       ConcatenateConstrainsOffsetToBeZeroAlongConcatenationDimension) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-concatenate {\n-  p0 = bf16[16] parameter(0)\n-  p1 = bf16[16] parameter(1)\n-  p2 = bf16[16] parameter(2)\n-  concatenate = bf16[48] concatenate(p0, p1, p2), dimensions={0}\n-  ROOT slice = bf16[24] slice(concatenate), slice={[24:48]}\n-}\n-\n-ENTRY main {\n-  p0 = bf16[16] parameter(0)\n-  p1 = bf16[16] parameter(1)\n-  p2 = bf16[16] parameter(2)\n-  ROOT fusion = bf16[24] fusion(p0, p1, p2),\n-    kind=kCustom, calls=concatenate, backend_config={\"fusion_backend_config\":{\n-      \"kind\":\"__triton_nested_gemm_fusion\"}}\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis_without_triton_constraints =\n-      TryAnalyzeModule(module.get(),\n-                       /*with_triton_emitter_specific_constraints=*/false);\n-  ASSERT_TRUE(analysis_without_triton_constraints.has_value());\n-  const HloInstruction* fusion_root =\n-      module->entry_computation()->root_instruction()->fused_expression_root();\n-\n-  // (8,) is a theoretically valid tiling for this concatenate, and one that\n-  // works for all operands, so SymbolicTileAnalysis should allow it.\n-  EXPECT_THAT(analysis_without_triton_constraints->ParametersSatisfyConstraints(\n-                  Tiling({{fusion_root, FlatTiling({8})}})),\n-              absl_testing::IsOkAndHolds(true));\n-\n-  std::optional<SymbolicTileAnalysis> analysis_with_triton_constraints =\n-      TryAnalyzeModule(module.get(),\n-                       /*with_triton_emitter_specific_constraints=*/true);\n-\n-  ASSERT_TRUE(analysis_with_triton_constraints.has_value());\n-\n-  // (8,) is a theoretically valid tiling for this concatenate, but the\n-  // constraints enforce that the offset along the concatenation dimension be 0.\n-  // Here, it is 24, so we expect the tiling to be rejected.\n-  //\n-  // Note: this is perfectly OK to expand later as our codegen improves to\n-  // handle this case.\n-  EXPECT_THAT(analysis_with_triton_constraints->ParametersSatisfyConstraints(\n-                  Tiling({{fusion_root, FlatTiling({8})}})),\n-              absl_testing::IsOkAndHolds(false));\n-\n-  // Even the smallest tiling, (1,) should be rejected here. (This is\n-  // unnecessary in theory, but a sanity check for the implementation).\n-  EXPECT_THAT(analysis_with_triton_constraints->ParametersSatisfyConstraints(\n-                  Tiling({{fusion_root, FlatTiling({1})}})),\n-              absl_testing::IsOkAndHolds(false));\n-}\n-\n-TEST_F(TritonEmitterConstraintsTest,\n-       ConcatenateConstrainsStrideToBeOneAlongConcatenationDimension) {\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n-                          ParseAndReturnVerifiedModule(R\"(\n-concatenate {\n-  p0 = bf16[16] parameter(0)\n-  p1 = bf16[16] parameter(1)\n-  p2 = bf16[16] parameter(2)\n-  concatenate = bf16[48] concatenate(p0, p1, p2), dimensions={0}\n-  ROOT slice = bf16[24] slice(concatenate), slice={[0:48:2]}\n-}\n-\n-ENTRY main {\n-  p0 = bf16[16] parameter(0)\n-  p1 = bf16[16] parameter(1)\n-  p2 = bf16[16] parameter(2)\n-  ROOT fusion = bf16[24] fusion(p0, p1, p2),\n-    kind=kCustom, calls=concatenate, backend_config={\"fusion_backend_config\":{\n-      \"kind\":\"__triton_nested_gemm_fusion\"}}\n-})\"));\n-  std::optional<SymbolicTileAnalysis> analysis_without_triton_constraints =\n-      TryAnalyzeModule(module.get(),\n-                       /*with_triton_emitter_specific_constraints=*/false);\n-  ASSERT_TRUE(analysis_without_triton_constraints.has_value());\n-  const HloInstruction* fusion_root =\n-      module->entry_computation()->root_instruction()->fused_expression_root();\n-\n-  // (8,) is a theoretically valid tiling for this concatenate, and one that\n-  // works for all operands, so SymbolicTileAnalysis should allow it.\n-  EXPECT_THAT(analysis_without_triton_constraints->ParametersSatisfyConstraints(\n-                  Tiling({{fusion_root, FlatTiling({8})}})),\n-              absl_testing::IsOkAndHolds(true));\n-\n-  std::optional<SymbolicTileAnalysis> analysis_with_triton_constraints =\n-      TryAnalyzeModule(module.get(),\n-                       /*with_triton_emitter_specific_constraints=*/true);\n-\n-  ASSERT_TRUE(analysis_with_triton_constraints.has_value());\n-\n-  // (8,) is a theoretically valid tiling for this concatenate, but the\n-  // constraints enforce that the stride along the concatenation dimension be 1.\n-  // Here, it is 2, so we expect the tiling to be rejected.\n-  //\n-  // Note: this is perfectly OK to expand later as our codegen improves to\n-  // handle this case.\n-  EXPECT_THAT(analysis_with_triton_constraints->ParametersSatisfyConstraints(\n-                  Tiling({{fusion_root, FlatTiling({8})}})),\n-              absl_testing::IsOkAndHolds(false));\n-\n-  // Even the smallest tiling, (1,) should be rejected here. (This is\n-  // unnecessary in theory, but a sanity check for the implementation).\n-  EXPECT_THAT(analysis_with_triton_constraints->ParametersSatisfyConstraints(\n-                  Tiling({{fusion_root, FlatTiling({1})}})),\n-              absl_testing::IsOkAndHolds(false));\n-}\n-\n TEST_F(TritonEmitterConstraintsTest, FusionHasValidTileSizes) {\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n                           ParseAndReturnVerifiedModule(R\"("
        }
    ],
    "stats": {
        "total": 983,
        "additions": 643,
        "deletions": 340
    }
}