{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 829395005",
    "sha": "a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
    "files": [
        {
            "sha": "dbad9888c99caa4014ea72211f098e0e34179f10",
            "filename": "tensorflow/core/debug/bfc_dump_reader.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fbfc_dump_reader.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fbfc_dump_reader.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fbfc_dump_reader.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -23,9 +23,9 @@ limitations under the License.\n #include \"tensorflow/core/util/command_line_flags.h\"\n \n namespace tensorflow {\n-MemoryDump ReadDumpFile(const string& fname) {\n+MemoryDump ReadDumpFile(const std::string& fname) {\n   absl::Status status;\n-  uint64 file_size = 0;\n+  uint64_t file_size = 0;\n   status = Env::Default()->GetFileSize(fname, &file_size);\n   if (!status.ok()) {\n     LOG(ERROR) << \"Failed to get size of \" << fname;\n@@ -66,7 +66,7 @@ MemoryDump FilterByChunkType(MemoryDump md, const char chunk_type) {\n   return filtered;\n }\n \n-void PrintChunk(const MemChunk& mc, const uint64 ac_offset, bool freed_at,\n+void PrintChunk(const MemChunk& mc, const uint64_t ac_offset, bool freed_at,\n                 const int64_t total_bytes, int64_t* cumulative_bytes) {\n   // A size class corresponding approximately to log base 100.\n   int size_class = floor(0.5 * log10(static_cast<double>(mc.size())));\n@@ -120,7 +120,7 @@ void PrintSortedChunks(\n   chunks.reserve(md.chunk_size());\n   int64_t total_bytes = 0;\n   int64_t cumulative_bytes = 0;\n-  uint64 max_action_count = 0;\n+  uint64_t max_action_count = 0;\n   for (auto& it : md.chunk()) {\n     chunks.push_back(&it);\n     total_bytes += it.size();\n@@ -129,7 +129,7 @@ void PrintSortedChunks(\n     }\n   }\n   sort(chunks.begin(), chunks.end(), compare);\n-  uint64 last_end = 0;\n+  uint64_t last_end = 0;\n   for (int i = 0; i < chunks.size(); ++i) {\n     const MemChunk* c = chunks[i];\n     if (by_addr && i > 0 && last_end != c->address()) {\n@@ -174,12 +174,12 @@ void PrintChunksBySize(const MemoryDump& md, bool by_age, bool freed_at) {\n       by_age, freed_at, false /*by_addr*/);\n }\n \n-void PrintChunksByOpName(const MemoryDump& md, const string& op_name,\n+void PrintChunksByOpName(const MemoryDump& md, const std::string& op_name,\n                          bool by_age, bool freed_at) {\n   printf(\"------------Chunks matching \\\"%s\\\":----------------------\\n\",\n          op_name.c_str());\n   MemoryDump filtered;\n-  uint64 total_bytes = 0;\n+  uint64_t total_bytes = 0;\n   filtered.set_allocator_name(md.allocator_name());\n   for (const auto& it : md.bin_summary()) {\n     *filtered.add_bin_summary() = it;\n@@ -203,7 +203,7 @@ void PrintChunksByOpName(const MemoryDump& md, const string& op_name,\n void PrintSizeHistory(const MemoryDump& md, bool by_age) {\n   printf(\"------------Allocated Bytes by Action Count--------\\n\");\n   printf(\"num snapshots: %d\\n\", md.snap_shot_size());\n-  uint64 max_action_count = 0;\n+  uint64_t max_action_count = 0;\n   if (by_age) {\n     for (auto& it : md.snap_shot()) {\n       if (it.action_count() > max_action_count) {"
        },
        {
            "sha": "5ee0d53d5076246468c45c2f0593b42c981dfae9",
            "filename": "tensorflow/core/debug/debug_callback_registry.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_callback_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_callback_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_callback_registry.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -28,20 +28,20 @@ DebugCallbackRegistry* DebugCallbackRegistry::singleton() {\n   return instance_;\n }\n \n-void DebugCallbackRegistry::RegisterCallback(const string& key,\n+void DebugCallbackRegistry::RegisterCallback(const std::string& key,\n                                              EventCallback callback) {\n   mutex_lock lock(mu_);\n   keyed_callback_[key] = std::move(callback);\n }\n \n DebugCallbackRegistry::EventCallback* DebugCallbackRegistry::GetCallback(\n-    const string& key) {\n+    const std::string& key) {\n   mutex_lock lock(mu_);\n   auto iter = keyed_callback_.find(key);\n   return iter == keyed_callback_.end() ? nullptr : &iter->second;\n }\n \n-void DebugCallbackRegistry::UnregisterCallback(const string& key) {\n+void DebugCallbackRegistry::UnregisterCallback(const std::string& key) {\n   mutex_lock lock(mu_);\n   keyed_callback_.erase(key);\n }"
        },
        {
            "sha": "c3cf8d665af9d9babdb5ea5718bf77deab1e4dc4",
            "filename": "tensorflow/core/debug/debug_callback_registry.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_callback_registry.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_callback_registry.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_callback_registry.h?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -45,14 +45,14 @@ class DebugCallbackRegistry {\n   static DebugCallbackRegistry* singleton();\n \n   // Returns the registered callback, or nullptr, for key.\n-  EventCallback* GetCallback(const string& key);\n+  EventCallback* GetCallback(const std::string& key);\n \n   // Associates callback with key.  This must be called by clients observing\n   // nodes to be exported by this callback router before running a session.\n-  void RegisterCallback(const string& key, EventCallback callback);\n+  void RegisterCallback(const std::string& key, EventCallback callback);\n \n   // Removes the callback associated with key.\n-  void UnregisterCallback(const string& key);\n+  void UnregisterCallback(const std::string& key);\n \n  private:\n   DebugCallbackRegistry();\n@@ -61,7 +61,7 @@ class DebugCallbackRegistry {\n   mutex mu_;\n \n   // Maps debug_url keys to callbacks for routing observed tensors.\n-  std::map<string, EventCallback> keyed_callback_ TF_GUARDED_BY(mu_);\n+  std::map<std::string, EventCallback> keyed_callback_ TF_GUARDED_BY(mu_);\n \n   static DebugCallbackRegistry* instance_;\n };"
        },
        {
            "sha": "9b0fc5c517c17016755f4bb7fd3e14d1636376c7",
            "filename": "tensorflow/core/debug/debug_graph_utils.cc",
            "status": "modified",
            "additions": 58,
            "deletions": 55,
            "changes": 113,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_graph_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_graph_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_graph_utils.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -30,8 +30,8 @@ namespace tensorflow {\n namespace {\n \n // TODO(cais): Switch to safe_strtob when available.\n-absl::Status ParseBoolString(const string& bool_str, bool* bool_val) {\n-  const string lower_bool_str = absl::AsciiStrToLower(bool_str);\n+absl::Status ParseBoolString(const std::string& bool_str, bool* bool_val) {\n+  const std::string lower_bool_str = absl::AsciiStrToLower(bool_str);\n   if (lower_bool_str == \"false\" || lower_bool_str == \"f\" ||\n       lower_bool_str == \"0\") {\n     *bool_val = false;\n@@ -60,15 +60,15 @@ absl::Status DebugNodeInserter::InsertNodes(\n   }\n \n   // Debug ops and URLs for wildcard node names (if any).\n-  std::vector<string> default_debug_ops;\n-  std::vector<string> default_debug_urls;\n+  std::vector<std::string> default_debug_ops;\n+  std::vector<std::string> default_debug_urls;\n \n   // A map from tensor name (e.g., \"node_a:0\") to list of debug op names\n   // (e.g., {\"DebugIdentity\", \"DebugNanCount\"})\n-  std::unordered_map<string, std::vector<string>> tensor_watches;\n+  std::unordered_map<std::string, std::vector<std::string>> tensor_watches;\n   // A map from tensor name to debug_url.\n-  std::unordered_map<string, std::vector<string>> tensor_watch_urls;\n-  std::unordered_map<string, bool> tensor_tolerate_failures;\n+  std::unordered_map<std::string, std::vector<std::string>> tensor_watch_urls;\n+  std::unordered_map<std::string, bool> tensor_tolerate_failures;\n \n   // Cache the proto content for fast lookup later\n   for (const DebugTensorWatch& watch : watches) {\n@@ -105,20 +105,20 @@ absl::Status DebugNodeInserter::InsertNodes(\n       }\n     }\n \n-    string tensor_name =\n+    std::string tensor_name =\n         absl::StrCat(watch.node_name(), \":\", watch.output_slot());\n \n-    std::vector<string> debug_ops;\n-    for (const string& debug_op : watch.debug_ops()) {\n+    std::vector<std::string> debug_ops;\n+    for (const std::string& debug_op : watch.debug_ops()) {\n       debug_ops.push_back(debug_op);\n     }\n \n     tensor_watches[tensor_name] = debug_ops;\n     tensor_tolerate_failures[tensor_name] =\n         watch.tolerate_debug_op_creation_failures();\n \n-    std::vector<string> urls;\n-    for (const string& url : watch.debug_urls()) {\n+    std::vector<std::string> urls;\n+    for (const std::string& url : watch.debug_urls()) {\n       urls.push_back(url);\n     }\n     tensor_watch_urls[tensor_name] = urls;\n@@ -148,7 +148,7 @@ absl::Status DebugNodeInserter::InsertNodes(\n     // Iterate through all output slots of the node.\n     for (int src_output_slot = 0; src_output_slot < src_node->num_outputs();\n          ++src_output_slot) {\n-      const string tensor_name =\n+      const std::string tensor_name =\n           absl::StrCat(src_node->name(), \":\", src_output_slot);\n       const bool explicit_tensor_match =\n           tensor_watches.find(tensor_name) != tensor_watches.end();\n@@ -176,10 +176,10 @@ absl::Status DebugNodeInserter::InsertNodes(\n                                              src_output_slot, &memory_type));\n \n       // Create the copy node for the watched tensor.\n-      const std::vector<string> debug_ops = explicit_tensor_match\n-                                                ? tensor_watches[tensor_name]\n-                                                : default_debug_ops;\n-      const std::vector<string> debug_urls =\n+      const std::vector<std::string> debug_ops =\n+          explicit_tensor_match ? tensor_watches[tensor_name]\n+                                : default_debug_ops;\n+      const std::vector<std::string> debug_urls =\n           explicit_tensor_match ? tensor_watch_urls[tensor_name]\n                                 : default_debug_urls;\n       Node* copy_node;\n@@ -200,7 +200,7 @@ absl::Status DebugNodeInserter::InsertNodes(\n       // Create all requested debug nodes and their edges to the Copy node.\n       std::vector<Node*> debug_nodes;\n       for (size_t i = 0; i < debug_ops.size(); ++i) {\n-        const string& debug_op_name = debug_ops[i];\n+        const std::string& debug_op_name = debug_ops[i];\n \n         Node* debug_node;\n         absl::Status debug_s = CreateDebugNode(\n@@ -280,17 +280,17 @@ void DebugNodeInserter::DeparallelizeWhileLoops(Graph* graph, Device* device) {\n }\n \n // static\n-const string DebugNodeInserter::GetCopyNodeName(const string& node_name,\n-                                                const int output_slot) {\n+const std::string DebugNodeInserter::GetCopyNodeName(\n+    const std::string& node_name, const int output_slot) {\n   // For example, if the watched node is named \"node1\" and the output slot\n   // is 0, the debug node will be called: __copy_node1_0\n   return absl::StrCat(\"__copy_\", node_name, \"_\", output_slot);\n }\n \n // static\n-const string DebugNodeInserter::GetDebugNodeName(const string& tensor_name,\n-                                                 const int debug_op_num,\n-                                                 const string& debug_op_name) {\n+const std::string DebugNodeInserter::GetDebugNodeName(\n+    const std::string& tensor_name, const int debug_op_num,\n+    const std::string& debug_op_name) {\n   // For example, if the watched node is named \"node1\" and the debug op that\n   // watches the output slot of node1 is of the type \"DebugNanCount\", the\n   // debug node will be called: __dbg_node1_0_0_DebugNanCount.\n@@ -301,23 +301,24 @@ const string DebugNodeInserter::GetDebugNodeName(const string& tensor_name,\n // static\n absl::Status DebugNodeInserter::CreateCopyNode(\n     Graph* graph, const DeviceType device_type, const bool is_host_memory,\n-    const string& src_node_name, const int src_output, const DataType src_dt,\n-    const string& tensor_name, const std::vector<string>& debug_ops,\n-    const std::vector<string>& debug_urls, Node** copy_node) {\n-  const string kGatedGrpcAttributeKey = \"gated_grpc\";\n+    const std::string& src_node_name, const int src_output,\n+    const DataType src_dt, const std::string& tensor_name,\n+    const std::vector<std::string>& debug_ops,\n+    const std::vector<std::string>& debug_urls, Node** copy_node) {\n+  const std::string kGatedGrpcAttributeKey = \"gated_grpc\";\n \n   NodeDef node_def;\n   const KernelDef* kdef;\n \n-  const string copy_op_name = is_host_memory ? \"CopyHost\" : \"Copy\";\n-  const string copy_node_name = GetCopyNodeName(src_node_name, src_output);\n+  const std::string copy_op_name = is_host_memory ? \"CopyHost\" : \"Copy\";\n+  const std::string copy_node_name = GetCopyNodeName(src_node_name, src_output);\n \n   // Cross debug_ops and debug_urls to get the list of debug ops and watches.\n-  std::vector<string> debug_ops_spec;\n-  for (const string& debug_op : debug_ops) {\n-    for (const string& debug_url : debug_urls) {\n-      string debug_op_name_proper;\n-      std::unordered_map<string, string> custom_attributes;\n+  std::vector<std::string> debug_ops_spec;\n+  for (const std::string& debug_op : debug_ops) {\n+    for (const std::string& debug_url : debug_urls) {\n+      std::string debug_op_name_proper;\n+      std::unordered_map<std::string, std::string> custom_attributes;\n       TF_RETURN_IF_ERROR(ParseDebugOpName(debug_op, &debug_op_name_proper,\n                                           &custom_attributes));\n \n@@ -363,38 +364,39 @@ absl::Status DebugNodeInserter::CreateCopyNode(\n \n // static\n absl::Status DebugNodeInserter::ParseDebugOpName(\n-    const string& debug_op_name, string* debug_op_name_proper,\n-    std::unordered_map<string, string>* attributes) {\n+    const std::string& debug_op_name, std::string* debug_op_name_proper,\n+    std::unordered_map<std::string, std::string>* attributes) {\n   const size_t l_index = debug_op_name.find('(');\n   const size_t r_index = debug_op_name.find(')');\n-  if (l_index == string::npos && r_index == string::npos) {\n+  if (l_index == std::string::npos && r_index == std::string::npos) {\n     *debug_op_name_proper = debug_op_name;\n   } else {\n-    if (l_index == string::npos || l_index == 0 ||\n+    if (l_index == std::string::npos || l_index == 0 ||\n         r_index != debug_op_name.size() - 1) {\n       return absl::InvalidArgumentError(\n           absl::StrCat(\"Malformed debug op name \\\"\", debug_op_name, \"\\\"\"));\n     }\n \n     *debug_op_name_proper = debug_op_name.substr(0, l_index);\n-    string arguments = debug_op_name.substr(l_index + 1, r_index - l_index - 1);\n+    std::string arguments =\n+        debug_op_name.substr(l_index + 1, r_index - l_index - 1);\n \n-    std::vector<string> attribute_segs = str_util::Split(arguments, \";\");\n-    for (const string& attribute_seg : attribute_segs) {\n+    std::vector<std::string> attribute_segs = str_util::Split(arguments, \";\");\n+    for (const std::string& attribute_seg : attribute_segs) {\n       absl::string_view seg(attribute_seg);\n       str_util::RemoveWhitespaceContext(&seg);\n       if (seg.empty()) {\n         continue;\n       }\n \n       const size_t eq_index = seg.find('=');\n-      if (eq_index == string::npos) {\n+      if (eq_index == std::string::npos) {\n         return absl::InvalidArgumentError(absl::StrCat(\n             \"Malformed attributes in debug op name \\\"\", debug_op_name, \"\\\"\"));\n       }\n \n-      const string key(seg.substr(0, eq_index));\n-      const string value(\n+      const std::string key(seg.substr(0, eq_index));\n+      const std::string value(\n           seg.substr(eq_index + 1, attribute_seg.size() - eq_index - 1));\n       if (key.empty() || value.empty()) {\n         return absl::InvalidArgumentError(absl::StrCat(\n@@ -415,17 +417,18 @@ absl::Status DebugNodeInserter::ParseDebugOpName(\n \n // static\n absl::Status DebugNodeInserter::SetDebugNodeAttributes(\n-    Node* debug_node, const std::unordered_map<string, string>& attributes) {\n-  std::unordered_set<string> unfulfilled_keys;\n+    Node* debug_node,\n+    const std::unordered_map<std::string, std::string>& attributes) {\n+  std::unordered_set<std::string> unfulfilled_keys;\n   for (const auto& item : attributes) {\n     unfulfilled_keys.insert(item.first);\n   }\n \n   for (const auto& attr : debug_node->op_def().attr()) {\n     if (attributes.find(attr.name()) != attributes.end()) {\n-      const string& attr_value = attributes.at(attr.name());\n+      const std::string& attr_value = attributes.at(attr.name());\n       if (attr.type() == \"string\") {\n-        debug_node->AddAttr<string>(attr.name(), attr_value);\n+        debug_node->AddAttr<std::string>(attr.name(), attr_value);\n       } else if (attr.type() == \"float\") {\n         float float_value = 0.0;\n         if (!absl::SimpleAtof(attr_value, &float_value)) {\n@@ -472,19 +475,19 @@ absl::Status DebugNodeInserter::SetDebugNodeAttributes(\n \n // static\n absl::Status DebugNodeInserter::CreateDebugNode(\n-    Graph* graph, const Device& device, const string& src_copy_node_name,\n-    const DataType src_dt, const string& tensor_name,\n-    const std::vector<string>& debug_urls, const int debug_op_num,\n-    const string& debug_op_name, Node** debug_node) {\n+    Graph* graph, const Device& device, const std::string& src_copy_node_name,\n+    const DataType src_dt, const std::string& tensor_name,\n+    const std::vector<std::string>& debug_urls, const int debug_op_num,\n+    const std::string& debug_op_name, Node** debug_node) {\n   NodeDef node_def;\n   const KernelDef* kdef;\n \n-  string debug_op_name_proper;\n-  std::unordered_map<string, string> custom_attributes;\n+  std::string debug_op_name_proper;\n+  std::unordered_map<std::string, std::string> custom_attributes;\n   TF_RETURN_IF_ERROR(ParseDebugOpName(debug_op_name, &debug_op_name_proper,\n                                       &custom_attributes));\n \n-  const string debug_node_name =\n+  const std::string debug_node_name =\n       GetDebugNodeName(tensor_name, debug_op_num, debug_op_name_proper);\n   auto builder = NodeDefBuilder(debug_node_name, debug_op_name_proper)\n                      .Input(src_copy_node_name, 0, src_dt)"
        },
        {
            "sha": "9552becbe7b27c51d845e37c6d7cb856b7882f6d",
            "filename": "tensorflow/core/debug/debug_graph_utils.h",
            "status": "modified",
            "additions": 17,
            "deletions": 15,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_graph_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_graph_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_graph_utils.h?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -82,20 +82,21 @@ class DebugNodeInserter {\n   static void DeparallelizeWhileLoops(Graph* graph, Device* device);\n \n   // Get canonical name of a copy node.\n-  static const string GetCopyNodeName(const string& node_name,\n-                                      const int output_slot);\n+  static const std::string GetCopyNodeName(const std::string& node_name,\n+                                           const int output_slot);\n \n   // Get canonical name of a debug node.\n-  static const string GetDebugNodeName(const string& tensor_name,\n-                                       const int debug_op_num,\n-                                       const string& debug_op_name);\n+  static const std::string GetDebugNodeName(const std::string& tensor_name,\n+                                            const int debug_op_num,\n+                                            const std::string& debug_op_name);\n \n  private:\n   static absl::Status CreateCopyNode(\n       Graph* graph, const DeviceType device_type, const bool is_host_memory,\n-      const string& src_node_name, const int src_output, const DataType src_dt,\n-      const string& tensor_name, const std::vector<string>& debug_ops,\n-      const std::vector<string>& debug_urls, Node** copy_node);\n+      const std::string& src_node_name, const int src_output,\n+      const DataType src_dt, const std::string& tensor_name,\n+      const std::vector<std::string>& debug_ops,\n+      const std::vector<std::string>& debug_urls, Node** copy_node);\n \n   // Parse the debug_op_name string to extract proper op name and attributes.\n   // debug_op_name can be the proper op name only, e.g., \"DebugNumericSummary\".\n@@ -104,17 +105,18 @@ class DebugNodeInserter {\n   // with semicolons (\";\"), which optional whitespace in between, e.g.,\n   // \"DebugNumericSummary(mute_if_healthy=true, lower_bound=-100.0)\".\n   static absl::Status ParseDebugOpName(\n-      const string& debug_op_name, string* debug_op_name_proper,\n-      std::unordered_map<string, string>* attributes);\n+      const std::string& debug_op_name, std::string* debug_op_name_proper,\n+      std::unordered_map<std::string, std::string>* attributes);\n \n   static absl::Status SetDebugNodeAttributes(\n-      Node* debug_node, const std::unordered_map<string, string>& attributes);\n+      Node* debug_node,\n+      const std::unordered_map<std::string, std::string>& attributes);\n \n   static absl::Status CreateDebugNode(\n-      Graph* graph, const Device& device, const string& src_copy_node_name,\n-      const DataType src_dt, const string& tensor_name,\n-      const std::vector<string>& debug_urls, const int debug_op_num,\n-      const string& debug_op_name, Node** debug_node);\n+      Graph* graph, const Device& device, const std::string& src_copy_node_name,\n+      const DataType src_dt, const std::string& tensor_name,\n+      const std::vector<std::string>& debug_urls, const int debug_op_num,\n+      const std::string& debug_op_name, Node** debug_node);\n   // TODO(cais): Cut down the number of args to this method.\n \n   friend class DebugGraphUtilsTest;"
        },
        {
            "sha": "d1184d5d18c498c2ecf656851debaf845bd75b6e",
            "filename": "tensorflow/core/debug/debug_graph_utils_test.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 16,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_graph_utils_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_graph_utils_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_graph_utils_test.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -25,25 +25,25 @@ namespace tensorflow {\n class DebugGraphUtilsTest : public ::testing::Test {\n  protected:\n   absl::Status ParseDebugOpName(\n-      const string& debug_op_name, string* debug_op_name_proper,\n-      std::unordered_map<string, string>* attributes) {\n+      const std::string& debug_op_name, std::string* debug_op_name_proper,\n+      std::unordered_map<std::string, std::string>* attributes) {\n     return DebugNodeInserter::ParseDebugOpName(\n         debug_op_name, debug_op_name_proper, attributes);\n   }\n };\n \n TEST_F(DebugGraphUtilsTest, TestParseNoAttributeDebugOpName) {\n-  string debug_op_name_proper;\n-  std::unordered_map<string, string> attributes;\n+  std::string debug_op_name_proper;\n+  std::unordered_map<std::string, std::string> attributes;\n   TF_ASSERT_OK(\n       ParseDebugOpName(\"DebugIdentity\", &debug_op_name_proper, &attributes));\n   ASSERT_EQ(\"DebugIdentity\", debug_op_name_proper);\n   ASSERT_EQ(0, attributes.size());\n }\n \n TEST_F(DebugGraphUtilsTest, TestMalformedDebugOpName) {\n-  string debug_op_name_proper;\n-  std::unordered_map<string, string> attributes;\n+  std::string debug_op_name_proper;\n+  std::unordered_map<std::string, std::string> attributes;\n \n   absl::Status s = ParseDebugOpName(\"(mute_if_healthy=true)\",\n                                     &debug_op_name_proper, &attributes);\n@@ -59,8 +59,8 @@ TEST_F(DebugGraphUtilsTest, TestMalformedDebugOpName) {\n }\n \n TEST_F(DebugGraphUtilsTest, TestDebugOpNameWithMalformedAttributes) {\n-  string debug_op_name_proper;\n-  std::unordered_map<string, string> attributes;\n+  std::string debug_op_name_proper;\n+  std::unordered_map<std::string, std::string> attributes;\n \n   absl::Status s = ParseDebugOpName(\"DebugNumericSummary(=)\",\n                                     &debug_op_name_proper, &attributes);\n@@ -89,8 +89,8 @@ TEST_F(DebugGraphUtilsTest, TestDebugOpNameWithMalformedAttributes) {\n }\n \n TEST_F(DebugGraphUtilsTest, TestValidDebugOpNameWithSingleAttribute) {\n-  string debug_op_name_proper;\n-  std::unordered_map<string, string> attributes;\n+  std::string debug_op_name_proper;\n+  std::unordered_map<std::string, std::string> attributes;\n \n   TF_ASSERT_OK(ParseDebugOpName(\"DebugNumericSummary()\", &debug_op_name_proper,\n                                 &attributes));\n@@ -106,8 +106,8 @@ TEST_F(DebugGraphUtilsTest, TestValidDebugOpNameWithSingleAttribute) {\n }\n \n TEST_F(DebugGraphUtilsTest, TestValidDebugOpNameWithMoreThanOneAttributes) {\n-  string debug_op_name_proper;\n-  std::unordered_map<string, string> attributes;\n+  std::string debug_op_name_proper;\n+  std::unordered_map<std::string, std::string> attributes;\n   TF_ASSERT_OK(ParseDebugOpName(\n       \"DebugNumericSummary(mute_if_healthy=true; threshold=300.0)\",\n       &debug_op_name_proper, &attributes));\n@@ -128,8 +128,8 @@ TEST_F(DebugGraphUtilsTest, TestValidDebugOpNameWithMoreThanOneAttributes) {\n }\n \n TEST_F(DebugGraphUtilsTest, TestValidDebugOpNameWithMoreDuplicateAttributes) {\n-  string debug_op_name_proper;\n-  std::unordered_map<string, string> attributes;\n+  std::string debug_op_name_proper;\n+  std::unordered_map<std::string, std::string> attributes;\n   absl::Status s = ParseDebugOpName(\n       \"DebugNumericSummary(mute_if_healthy=true; lower_bound=3; \"\n       \"mute_if_healthy=false;)\",\n@@ -138,8 +138,8 @@ TEST_F(DebugGraphUtilsTest, TestValidDebugOpNameWithMoreDuplicateAttributes) {\n }\n \n TEST_F(DebugGraphUtilsTest, TestValidDebugOpNameWithWhitespaceInAttributes) {\n-  string debug_op_name_proper;\n-  std::unordered_map<string, string> attributes;\n+  std::string debug_op_name_proper;\n+  std::unordered_map<std::string, std::string> attributes;\n \n   TF_ASSERT_OK(ParseDebugOpName(\n       \"DebugNumericSummary(  mute_if_healthy=true; threshold=300.0  )\","
        },
        {
            "sha": "19c79a04d2123da3bb91ee28642513a050d88c41",
            "filename": "tensorflow/core/debug/debug_grpc_io_utils_test.cc",
            "status": "modified",
            "additions": 28,
            "deletions": 27,
            "changes": 55,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_grpc_io_utils_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_grpc_io_utils_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_grpc_io_utils_test.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -34,7 +34,7 @@ class GrpcDebugTest : public ::testing::Test {\n  protected:\n   struct ServerData {\n     int port;\n-    string url;\n+    std::string url;\n     std::unique_ptr<test::TestEventListenerImpl> server;\n     std::unique_ptr<thread::ThreadPool> thread_pool;\n   };\n@@ -86,7 +86,7 @@ TEST_F(GrpcDebugTest, ConnectionTimeoutWorks) {\n   SetChannelConnectionTimeoutMicros(kShortTimeoutMicros);\n   ASSERT_EQ(kShortTimeoutMicros, GetChannelConnectionTimeoutMicros());\n \n-  const string& kInvalidGrpcUrl =\n+  const std::string& kInvalidGrpcUrl =\n       absl::StrCat(\"grpc://localhost:\", testing::PickUnusedPortOrDie());\n   Tensor tensor(DT_FLOAT, TensorShape({1, 1}));\n   tensor.flat<float>()(0) = 42.0;\n@@ -98,10 +98,11 @@ TEST_F(GrpcDebugTest, ConnectionTimeoutWorks) {\n   TF_ASSERT_OK(DebugIO::CloseDebugURL(kInvalidGrpcUrl));\n \n   ASSERT_FALSE(publish_status.ok());\n-  const string expected_error_msg = strings::StrCat(\n+  const std::string expected_error_msg = strings::StrCat(\n       \"Failed to connect to gRPC channel at \", kInvalidGrpcUrl.substr(7),\n       \" within a timeout of \", kShortTimeoutMicros / 1e6, \" s\");\n-  ASSERT_NE(string::npos, publish_status.message().find(expected_error_msg));\n+  ASSERT_NE(std::string::npos,\n+            publish_status.message().find(expected_error_msg));\n }\n \n TEST_F(GrpcDebugTest, ConnectionToDelayedStartingServerWorks) {\n@@ -149,7 +150,7 @@ TEST_F(GrpcDebugTest, SendSingleDebugTensorViaGrpcTest) {\n \n TEST_F(GrpcDebugTest, SendDebugTensorWithLargeStringAtIndex0ViaGrpcTest) {\n   Tensor tensor(DT_STRING, TensorShape({1, 1}));\n-  tensor.flat<tstring>()(0) = string(5000 * 1024, 'A');\n+  tensor.flat<tstring>()(0) = std::string(5000 * 1024, 'A');\n   const DebugNodeKey kDebugNodeKey(\"/job:localhost/replica:0/task:0/cpu:0\",\n                                    \"foo_tensor\", 0, \"DebugIdentity\");\n   const absl::Status status = DebugIO::PublishDebugTensor(\n@@ -158,14 +159,14 @@ TEST_F(GrpcDebugTest, SendDebugTensorWithLargeStringAtIndex0ViaGrpcTest) {\n   ASSERT_NE(status.message().find(\"string value at index 0 from debug \"\n                                   \"node foo_tensor:0:DebugIdentity does \"\n                                   \"not fit gRPC message size limit\"),\n-            string::npos);\n+            std::string::npos);\n   TF_ASSERT_OK(DebugIO::CloseDebugURL(server_data_.url));\n }\n \n TEST_F(GrpcDebugTest, SendDebugTensorWithLargeStringAtIndex1ViaGrpcTest) {\n   Tensor tensor(DT_STRING, TensorShape({1, 2}));\n   tensor.flat<tstring>()(0) = \"A\";\n-  tensor.flat<tstring>()(1) = string(5000 * 1024, 'A');\n+  tensor.flat<tstring>()(1) = std::string(5000 * 1024, 'A');\n   const DebugNodeKey kDebugNodeKey(\"/job:localhost/replica:0/task:0/cpu:0\",\n                                    \"foo_tensor\", 0, \"DebugIdentity\");\n   const absl::Status status = DebugIO::PublishDebugTensor(\n@@ -174,7 +175,7 @@ TEST_F(GrpcDebugTest, SendDebugTensorWithLargeStringAtIndex1ViaGrpcTest) {\n   ASSERT_NE(status.message().find(\"string value at index 1 from debug \"\n                                   \"node foo_tensor:0:DebugIdentity does \"\n                                   \"not fit gRPC message size limit\"),\n-            string::npos);\n+            std::string::npos);\n   TF_ASSERT_OK(DebugIO::CloseDebugURL(server_data_.url));\n }\n \n@@ -197,7 +198,7 @@ TEST_F(GrpcDebugTest, SendMultipleDebugTensorsSynchronizedViaGrpcTest) {\n   int tensor_count TF_GUARDED_BY(mu) = 0;\n   std::vector<absl::Status> statuses TF_GUARDED_BY(mu);\n \n-  const std::vector<string> urls({server_data_.url});\n+  const std::vector<std::string> urls({server_data_.url});\n \n   // Set up the concurrent tasks of sending Tensors via an Event stream to the\n   // server.\n@@ -210,7 +211,7 @@ TEST_F(GrpcDebugTest, SendMultipleDebugTensorsSynchronizedViaGrpcTest) {\n     }\n \n     // Different concurrent tasks will send different tensors.\n-    const uint64 wall_time = Env::Default()->NowMicros();\n+    const uint64_t wall_time = Env::Default()->NowMicros();\n     absl::Status publish_status = DebugIO::PublishDebugTensor(\n         DebugNodeKey(\"/job:localhost/replica:0/task:0/cpu:0\",\n                      absl::StrCat(\"synchronized_node_\", this_count), 0,\n@@ -247,7 +248,7 @@ TEST_F(GrpcDebugTest, SendMultipleDebugTensorsSynchronizedViaGrpcTest) {\n   // One prep tensor plus kSends concurrent tensors are expected.\n   ASSERT_EQ(kSends, server_data_.server->node_names.size());\n   for (size_t i = 0; i < server_data_.server->node_names.size(); ++i) {\n-    std::vector<string> items =\n+    std::vector<std::string> items =\n         str_util::Split(server_data_.server->node_names[i], '_');\n     int tensor_index;\n     strings::safe_strto32(items[2], &tensor_index);\n@@ -267,10 +268,10 @@ TEST_F(GrpcDebugTest, SendDebugTensorsThroughMultipleRoundsUsingGrpcGating) {\n   Tensor tensor(DT_INT32, TensorShape({1, 1}));\n   tensor.flat<int>()(0) = 42;\n \n-  const std::vector<string> urls({server_data_.url});\n+  const std::vector<std::string> urls({server_data_.url});\n   for (int i = 0; i < 3; ++i) {\n     server_data_.server->ClearReceivedDebugData();\n-    const uint64 wall_time = Env::Default()->NowMicros();\n+    const uint64_t wall_time = Env::Default()->NowMicros();\n \n     // On the 1st send (i == 0), gating is disabled, so data should be sent.\n     // On the 2nd send (i == 1), gating is enabled, and the server has enabled\n@@ -315,10 +316,10 @@ TEST_F(GrpcDebugTest, SendDebugTensorsThroughMultipleRoundsUnderReadWriteMode) {\n   Tensor tensor(DT_INT32, TensorShape({1, 1}));\n   tensor.flat<int>()(0) = 42;\n \n-  const std::vector<string> urls({server_data_.url});\n+  const std::vector<std::string> urls({server_data_.url});\n   for (int i = 0; i < 3; ++i) {\n     server_data_.server->ClearReceivedDebugData();\n-    const uint64 wall_time = Env::Default()->NowMicros();\n+    const uint64_t wall_time = Env::Default()->NowMicros();\n \n     // On the 1st send (i == 0), gating is disabled, so data should be sent.\n     // On the 2nd send (i == 1), gating is enabled, and the server has enabled\n@@ -367,8 +368,8 @@ TEST_F(GrpcDebugTest, TestGateDebugNodeOnEmptyEnabledSet) {\n }\n \n TEST_F(GrpcDebugTest, TestGateDebugNodeOnNonEmptyEnabledSet) {\n-  const string kGrpcUrl1 = \"grpc://localhost:3333\";\n-  const string kGrpcUrl2 = \"grpc://localhost:3334\";\n+  const std::string kGrpcUrl1 = \"grpc://localhost:3333\";\n+  const std::string kGrpcUrl2 = \"grpc://localhost:3334\";\n \n   DebugGrpcIO::SetDebugNodeKeyGrpcState(\n       kGrpcUrl1, \"foo:0:DebugIdentity\",\n@@ -398,9 +399,9 @@ TEST_F(GrpcDebugTest, TestGateDebugNodeOnNonEmptyEnabledSet) {\n }\n \n TEST_F(GrpcDebugTest, TestGateDebugNodeOnMultipleEmptyEnabledSets) {\n-  const string kGrpcUrl1 = \"grpc://localhost:3333\";\n-  const string kGrpcUrl2 = \"grpc://localhost:3334\";\n-  const string kGrpcUrl3 = \"grpc://localhost:3335\";\n+  const std::string kGrpcUrl1 = \"grpc://localhost:3333\";\n+  const std::string kGrpcUrl2 = \"grpc://localhost:3334\";\n+  const std::string kGrpcUrl3 = \"grpc://localhost:3335\";\n \n   DebugGrpcIO::SetDebugNodeKeyGrpcState(\n       kGrpcUrl1, \"foo:0:DebugIdentity\",\n@@ -434,14 +435,14 @@ TEST_F(GrpcDebugTest, TestGateDebugNodeOnNonEmptyEnabledSetAndEmptyURLs) {\n       \"grpc://localhost:3333\", \"foo:0:DebugIdentity\",\n       EventReply::DebugOpStateChange::READ_ONLY);\n \n-  std::vector<string> debug_urls_1;\n+  std::vector<std::string> debug_urls_1;\n   ASSERT_FALSE(\n       DebugIO::IsDebugNodeGateOpen(\"foo:1:DebugIdentity\", debug_urls_1));\n }\n \n TEST_F(GrpcDebugTest, TestGateCopyNodeOnEmptyEnabledSet) {\n-  const string kGrpcUrl1 = \"grpc://localhost:3333\";\n-  const string kWatch1 = \"foo:0:DebugIdentity\";\n+  const std::string kGrpcUrl1 = \"grpc://localhost:3333\";\n+  const std::string kWatch1 = \"foo:0:DebugIdentity\";\n \n   ASSERT_FALSE(DebugIO::IsCopyNodeGateOpen(\n       {DebugWatchAndURLSpec(kWatch1, kGrpcUrl1, true)}));\n@@ -456,10 +457,10 @@ TEST_F(GrpcDebugTest, TestGateCopyNodeOnEmptyEnabledSet) {\n }\n \n TEST_F(GrpcDebugTest, TestGateCopyNodeOnNonEmptyEnabledSet) {\n-  const string kGrpcUrl1 = \"grpc://localhost:3333\";\n-  const string kGrpcUrl2 = \"grpc://localhost:3334\";\n-  const string kWatch1 = \"foo:0:DebugIdentity\";\n-  const string kWatch2 = \"foo:1:DebugIdentity\";\n+  const std::string kGrpcUrl1 = \"grpc://localhost:3333\";\n+  const std::string kGrpcUrl2 = \"grpc://localhost:3334\";\n+  const std::string kWatch1 = \"foo:0:DebugIdentity\";\n+  const std::string kWatch2 = \"foo:1:DebugIdentity\";\n   DebugGrpcIO::SetDebugNodeKeyGrpcState(\n       kGrpcUrl1, kWatch1, EventReply::DebugOpStateChange::READ_ONLY);\n "
        },
        {
            "sha": "0f3dfb8bb737f4f0adf2427c6edb56ead4642739",
            "filename": "tensorflow/core/debug/debug_grpc_testlib.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_grpc_testlib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_grpc_testlib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_grpc_testlib.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -44,11 +44,11 @@ ::grpc::Status TestEventListenerImpl::SendEvents(\n     } else if (event.has_summary()) {\n       const Summary::Value& val = event.summary().value(0);\n \n-      std::vector<string> name_items =\n+      std::vector<std::string> name_items =\n           tensorflow::str_util::Split(val.node_name(), ':');\n \n-      const string node_name = name_items[0];\n-      const string debug_op = name_items[2];\n+      const std::string node_name = name_items[0];\n+      const std::string debug_op = name_items[2];\n \n       const TensorProto& tensor_proto = val.tensor();\n       Tensor tensor(tensor_proto.dtype());\n@@ -156,7 +156,7 @@ void TestEventListenerImpl::StopServer() {\n   }\n }\n \n-bool PollTillFirstRequestSucceeds(const string& server_url,\n+bool PollTillFirstRequestSucceeds(const std::string& server_url,\n                                   const size_t max_attempts) {\n   const int kSleepDurationMicros = 100 * 1000;\n   size_t n_attempts = 0;\n@@ -168,7 +168,7 @@ bool PollTillFirstRequestSucceeds(const string& server_url,\n   prep_tensor.flat<float>()(0) = 42.0f;\n \n   while (n_attempts++ < max_attempts) {\n-    const uint64 wall_time = Env::Default()->NowMicros();\n+    const uint64_t wall_time = Env::Default()->NowMicros();\n     absl::Status publish_s = DebugIO::PublishDebugTensor(\n         DebugNodeKey(\"/job:localhost/replica:0/task:0/cpu:0\", \"prep_node\", 0,\n                      \"DebugIdentity\"),"
        },
        {
            "sha": "415ce6435c7bdf4f40059ce517698bccb06ac6a2",
            "filename": "tensorflow/core/debug/debug_grpc_testlib.h",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_grpc_testlib.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_grpc_testlib.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_grpc_testlib.h?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -48,12 +48,12 @@ class TestEventListenerImpl final : public grpc::EventListener::Service {\n       const EventReply::DebugOpStateChange::State new_state,\n       const DebugNodeKey& debug_node_key);\n \n-  std::vector<string> debug_metadata_strings;\n-  std::vector<string> encoded_graph_defs;\n-  std::vector<string> device_names;\n-  std::vector<string> node_names;\n-  std::vector<int32> output_slots;\n-  std::vector<string> debug_ops;\n+  std::vector<std::string> debug_metadata_strings;\n+  std::vector<std::string> encoded_graph_defs;\n+  std::vector<std::string> device_names;\n+  std::vector<std::string> node_names;\n+  std::vector<int32_t> output_slots;\n+  std::vector<std::string> debug_ops;\n   std::vector<Tensor> debug_tensors;\n \n  private:\n@@ -77,7 +77,7 @@ class TestEventListenerImpl final : public grpc::EventListener::Service {\n //\n // Returns:\n //   Whether the polling succeeded within max_attempts.\n-bool PollTillFirstRequestSucceeds(const string& server_url,\n+bool PollTillFirstRequestSucceeds(const std::string& server_url,\n                                   const size_t max_attempts);\n \n }  // namespace test"
        },
        {
            "sha": "430bc36ea1a96c3e66a030292ad58827c86af66e",
            "filename": "tensorflow/core/debug/debug_io_utils.cc",
            "status": "modified",
            "additions": 111,
            "deletions": 105,
            "changes": 216,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_io_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_io_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_io_utils.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -66,8 +66,8 @@ constexpr absl::string_view kDumpSubDirName = \"node-io-dump\";\n // shape). It does not set the value.tensor field, which should be set by the\n // caller separately.\n Event PrepareChunkEventProto(const DebugNodeKey& debug_node_key,\n-                             const uint64 wall_time_us, const size_t num_chunks,\n-                             const size_t chunk_index,\n+                             const uint64_t wall_time_us,\n+                             const size_t num_chunks, const size_t chunk_index,\n                              const DataType& tensor_dtype,\n                              const TensorShapeProto& tensor_shape) {\n   Event event;\n@@ -92,7 +92,7 @@ Event PrepareChunkEventProto(const DebugNodeKey& debug_node_key,\n   metadata.set_chunk_index(chunk_index);\n \n   // Encode the data in JSON.\n-  string json_output;\n+  std::string json_output;\n   tensorflow::protobuf::util::JsonPrintOptions json_options;\n   json_options.always_print_fields_with_no_presence = true;\n   auto status = tensorflow::protobuf::util::MessageToJsonString(\n@@ -120,7 +120,7 @@ Event PrepareChunkEventProto(const DebugNodeKey& debug_node_key,\n // (i.e., an estimate that is usually too large, but never too small under the\n // gRPC message size limit) of the Varint-encoded length, to workaround the lack\n // of a portable length function.\n-const size_t StringValMaxBytesInProto(const string& str) {\n+const size_t StringValMaxBytesInProto(const std::string& str) {\n #if defined(PLATFORM_GOOGLE)\n   return str.size() + DebugGrpcIO::kGrpcMaxVarintLengthSize;\n #else\n@@ -131,11 +131,12 @@ const size_t StringValMaxBytesInProto(const string& str) {\n // Breaks a string Tensor (represented as a TensorProto) as a vector of Event\n // protos.\n absl::Status WrapStringTensorAsEvents(const DebugNodeKey& debug_node_key,\n-                                      const uint64 wall_time_us,\n+                                      const uint64_t wall_time_us,\n                                       const size_t chunk_size_limit,\n                                       TensorProto* tensor_proto,\n                                       std::vector<Event>* events) {\n-  const protobuf::RepeatedPtrField<string>& strs = tensor_proto->string_val();\n+  const protobuf::RepeatedPtrField<std::string>& strs =\n+      tensor_proto->string_val();\n   const size_t num_strs = strs.size();\n   const size_t chunk_size_ub = chunk_size_limit > 0\n                                    ? chunk_size_limit\n@@ -191,7 +192,8 @@ absl::Status WrapStringTensorAsEvents(const DebugNodeKey& debug_node_key,\n // If chunk_size_limit <= 0, the tensor will not be broken into chunks, i.e., a\n // length-1 vector will be returned, regardless of the size of the tensor.\n absl::Status WrapTensorAsEvents(const DebugNodeKey& debug_node_key,\n-                                const Tensor& tensor, const uint64 wall_time_us,\n+                                const Tensor& tensor,\n+                                const uint64_t wall_time_us,\n                                 const size_t chunk_size_limit,\n                                 std::vector<Event>* events) {\n   TensorProto tensor_proto;\n@@ -237,10 +239,11 @@ absl::Status WrapTensorAsEvents(const DebugNodeKey& debug_node_key,\n // TOCTOU race condition is not of concern here due to the fact that tfdbg\n // sets parallel_iterations attribute of all while_loops to 1 to prevent\n // the same node from between executed multiple times concurrently.\n-string AppendTimestampToFilePath(const string& in, const uint64 timestamp) {\n-  string out = absl::StrCat(in, \"_\", timestamp);\n+std::string AppendTimestampToFilePath(const std::string& in,\n+                                      const uint64_t timestamp) {\n+  std::string out = absl::StrCat(in, \"_\", timestamp);\n \n-  uint64 i = 1;\n+  uint64_t i = 1;\n   while (Env::Default()->FileExists(out).ok()) {\n     out = strings::StrCat(in, \"_\", timestamp, \"-\", i);\n     ++i;\n@@ -251,11 +254,10 @@ string AppendTimestampToFilePath(const string& in, const uint64 timestamp) {\n #ifndef PLATFORM_WINDOWS\n // Publishes encoded GraphDef through a gRPC debugger stream, in chunks,\n // conforming to the gRPC message size limit.\n-absl::Status PublishEncodedGraphDefInChunks(const string& encoded_graph_def,\n-                                            const string& device_name,\n-                                            const int64_t wall_time,\n-                                            const string& debug_url) {\n-  const uint64 hash = ::tensorflow::Hash64(encoded_graph_def);\n+absl::Status PublishEncodedGraphDefInChunks(\n+    const std::string& encoded_graph_def, const std::string& device_name,\n+    const int64_t wall_time, const std::string& debug_url) {\n+  const uint64_t hash = ::tensorflow::Hash64(encoded_graph_def);\n   const size_t total_length = encoded_graph_def.size();\n   const size_t num_chunks =\n       static_cast<size_t>(std::ceil(static_cast<float>(total_length) /\n@@ -297,11 +299,12 @@ const char* const DebugIO::kGraphTag = \"graph_\";\n \n const char* const DebugIO::kHashTag = \"hash\";\n \n-absl::Status ReadEventFromFile(const string& dump_file_path, Event* event) {\n+absl::Status ReadEventFromFile(const std::string& dump_file_path,\n+                               Event* event) {\n   Env* env(Env::Default());\n \n-  string content;\n-  uint64 file_size = 0;\n+  std::string content;\n+  uint64_t file_size = 0;\n \n   absl::Status s = env->GetFileSize(dump_file_path, &file_size);\n   if (!s.ok()) {\n@@ -333,10 +336,11 @@ const char* const DebugIO::kMemoryURLScheme = \"memcbk://\";\n // Publishes debug metadata to a set of debug URLs.\n absl::Status DebugIO::PublishDebugMetadata(\n     const int64_t global_step, const int64_t session_run_index,\n-    const int64_t executor_step_index, const std::vector<string>& input_names,\n-    const std::vector<string>& output_names,\n-    const std::vector<string>& target_nodes,\n-    const std::unordered_set<string>& debug_urls) {\n+    const int64_t executor_step_index,\n+    const std::vector<std::string>& input_names,\n+    const std::vector<std::string>& output_names,\n+    const std::vector<std::string>& target_nodes,\n+    const std::unordered_set<std::string>& debug_urls) {\n   std::ostringstream oss;\n \n   // Construct a JSON string to carry the metadata.\n@@ -370,24 +374,24 @@ absl::Status DebugIO::PublishDebugMetadata(\n   oss << \"]\";\n   oss << \"}\";\n \n-  const string json_metadata = oss.str();\n+  const std::string json_metadata = oss.str();\n   Event event;\n   event.set_wall_time(static_cast<double>(Env::Default()->NowMicros()));\n   LogMessage* log_message = event.mutable_log_message();\n   log_message->set_message(json_metadata);\n \n   absl::Status status;\n-  for (const string& url : debug_urls) {\n+  for (const std::string& url : debug_urls) {\n     if (absl::StartsWith(absl::AsciiStrToLower(url), kGrpcURLScheme)) {\n #ifndef PLATFORM_WINDOWS\n       Event grpc_event;\n \n       // Determine the path (if any) in the grpc:// URL, and add it as a field\n       // of the JSON string.\n-      const string address = url.substr(strlen(DebugIO::kFileURLScheme));\n-      const string path = address.find('/') == string::npos\n-                              ? \"\"\n-                              : address.substr(address.find('/'));\n+      const std::string address = url.substr(strlen(DebugIO::kFileURLScheme));\n+      const std::string path = address.find('/') == std::string::npos\n+                                   ? \"\"\n+                                   : address.substr(address.find('/'));\n       grpc_event.set_wall_time(event.wall_time());\n       LogMessage* log_message_grpc = grpc_event.mutable_log_message();\n       log_message_grpc->set_message(\n@@ -400,8 +404,8 @@ absl::Status DebugIO::PublishDebugMetadata(\n       GRPC_OSS_WINDOWS_UNIMPLEMENTED_ERROR;\n #endif\n     } else if (absl::StartsWith(absl::AsciiStrToLower(url), kFileURLScheme)) {\n-      const string dump_root_dir = url.substr(strlen(kFileURLScheme));\n-      const string core_metadata_path = AppendTimestampToFilePath(\n+      const std::string dump_root_dir = url.substr(strlen(kFileURLScheme));\n+      const std::string core_metadata_path = AppendTimestampToFilePath(\n           io::JoinPath(\n               dump_root_dir,\n               absl::StrCat(DebugNodeKey::kMetadataFilePrefix,\n@@ -410,8 +414,8 @@ absl::Status DebugIO::PublishDebugMetadata(\n                                                           session_run_index)))),\n           Env::Default()->NowMicros());\n       status.Update(DebugFileIO::DumpEventProtoToFile(\n-          event, string(io::Dirname(core_metadata_path)),\n-          string(io::Basename(core_metadata_path))));\n+          event, std::string(io::Dirname(core_metadata_path)),\n+          std::string(io::Basename(core_metadata_path))));\n     }\n   }\n \n@@ -420,13 +424,13 @@ absl::Status DebugIO::PublishDebugMetadata(\n \n absl::Status DebugIO::PublishDebugTensor(\n     const DebugNodeKey& debug_node_key, const Tensor& tensor,\n-    const uint64 wall_time_us, const absl::Span<const string> debug_urls,\n+    const uint64_t wall_time_us, const absl::Span<const std::string> debug_urls,\n     const bool gated_grpc, const int64_t step_id) {\n   int32_t num_failed_urls = 0;\n   std::vector<absl::Status> fail_statuses;\n-  for (const string& url : debug_urls) {\n+  for (const std::string& url : debug_urls) {\n     if (absl::StartsWith(absl::AsciiStrToLower(url), kFileURLScheme)) {\n-      const string dump_root_dir = url.substr(strlen(kFileURLScheme));\n+      const std::string dump_root_dir = url.substr(strlen(kFileURLScheme));\n \n       const int64_t tensorBytes =\n           tensor.IsInitialized() ? tensor.TotalBytes() : 0;\n@@ -465,7 +469,7 @@ absl::Status DebugIO::PublishDebugTensor(\n       GRPC_OSS_WINDOWS_UNIMPLEMENTED_ERROR;\n #endif\n     } else if (absl::StartsWith(absl::AsciiStrToLower(url), kMemoryURLScheme)) {\n-      const string dump_root_dir = url.substr(strlen(kMemoryURLScheme));\n+      const std::string dump_root_dir = url.substr(strlen(kMemoryURLScheme));\n       auto* callback_registry = DebugCallbackRegistry::singleton();\n       auto* callback = callback_registry->GetCallback(dump_root_dir);\n       CHECK(callback) << \"No callback registered for: \" << dump_root_dir;\n@@ -479,7 +483,7 @@ absl::Status DebugIO::PublishDebugTensor(\n   if (num_failed_urls == 0) {\n     return absl::OkStatus();\n   } else {\n-    string error_message = strings::StrCat(\n+    std::string error_message = strings::StrCat(\n         \"Publishing to \", num_failed_urls, \" of \", debug_urls.size(),\n         \" debug target URLs failed, due to the following errors:\");\n     for (absl::Status& status : fail_statuses) {\n@@ -492,18 +496,19 @@ absl::Status DebugIO::PublishDebugTensor(\n \n absl::Status DebugIO::PublishDebugTensor(\n     const DebugNodeKey& debug_node_key, const Tensor& tensor,\n-    const uint64 wall_time_us, const absl::Span<const string> debug_urls) {\n+    const uint64_t wall_time_us,\n+    const absl::Span<const std::string> debug_urls) {\n   return PublishDebugTensor(debug_node_key, tensor, wall_time_us, debug_urls,\n                             false);\n }\n \n absl::Status DebugIO::PublishGraph(\n-    const Graph& graph, const string& device_name,\n-    const std::unordered_set<string>& debug_urls) {\n+    const Graph& graph, const std::string& device_name,\n+    const std::unordered_set<std::string>& debug_urls) {\n   GraphDef graph_def;\n   graph.ToGraphDef(&graph_def);\n \n-  string buf;\n+  std::string buf;\n   graph_def.SerializeToString(&buf);\n \n   const int64_t now_micros = Env::Default()->NowMicros();\n@@ -512,13 +517,13 @@ absl::Status DebugIO::PublishGraph(\n   event.set_graph_def(buf);\n \n   absl::Status status = absl::OkStatus();\n-  for (const string& debug_url : debug_urls) {\n+  for (const std::string& debug_url : debug_urls) {\n     if (absl::StartsWith(debug_url, kFileURLScheme)) {\n-      const string dump_root_dir =\n+      const std::string dump_root_dir =\n           io::JoinPath(debug_url.substr(strlen(kFileURLScheme)),\n                        DebugNodeKey::DeviceNameToDevicePath(device_name));\n-      const uint64 graph_hash = ::tensorflow::Hash64(buf);\n-      const string file_name =\n+      const uint64_t graph_hash = ::tensorflow::Hash64(buf);\n+      const std::string file_name =\n           strings::StrCat(DebugNodeKey::kMetadataFilePrefix, DebugIO::kGraphTag,\n                           DebugIO::kHashTag, graph_hash, \"_\", now_micros);\n \n@@ -556,10 +561,10 @@ bool DebugIO::IsCopyNodeGateOpen(\n #endif\n }\n \n-bool DebugIO::IsDebugNodeGateOpen(const string& watch_key,\n-                                  const std::vector<string>& debug_urls) {\n+bool DebugIO::IsDebugNodeGateOpen(const std::string& watch_key,\n+                                  const std::vector<std::string>& debug_urls) {\n #ifndef PLATFORM_WINDOWS\n-  for (const string& debug_url : debug_urls) {\n+  for (const std::string& debug_url : debug_urls) {\n     if (debug_url.compare(0, strlen(DebugIO::kGrpcURLScheme),\n                           DebugIO::kGrpcURLScheme)) {\n       return true;\n@@ -575,8 +580,8 @@ bool DebugIO::IsDebugNodeGateOpen(const string& watch_key,\n #endif\n }\n \n-bool DebugIO::IsDebugURLGateOpen(const string& watch_key,\n-                                 const string& debug_url) {\n+bool DebugIO::IsDebugURLGateOpen(const std::string& watch_key,\n+                                 const std::string& debug_url) {\n #ifndef PLATFORM_WINDOWS\n   if (debug_url != kGrpcURLScheme) {\n     return true;\n@@ -588,7 +593,7 @@ bool DebugIO::IsDebugURLGateOpen(const string& watch_key,\n #endif\n }\n \n-absl::Status DebugIO::CloseDebugURL(const string& debug_url) {\n+absl::Status DebugIO::CloseDebugURL(const std::string& debug_url) {\n   if (absl::StartsWith(debug_url, DebugIO::kGrpcURLScheme)) {\n #ifndef PLATFORM_WINDOWS\n     return DebugGrpcIO::CloseGrpcStream(debug_url);\n@@ -603,10 +608,10 @@ absl::Status DebugIO::CloseDebugURL(const string& debug_url) {\n \n absl::Status DebugFileIO::DumpTensorToDir(const DebugNodeKey& debug_node_key,\n                                           const Tensor& tensor,\n-                                          const uint64 wall_time_us,\n-                                          const string& dump_root_dir,\n-                                          string* dump_file_path) {\n-  const string file_path =\n+                                          const uint64_t wall_time_us,\n+                                          const std::string& dump_root_dir,\n+                                          std::string* dump_file_path) {\n+  const std::string file_path =\n       GetDumpFilePath(dump_root_dir, debug_node_key, wall_time_us);\n \n   if (dump_file_path != nullptr) {\n@@ -618,9 +623,9 @@ absl::Status DebugFileIO::DumpTensorToDir(const DebugNodeKey& debug_node_key,\n \n absl::Status DebugFileIO::DumpTensorToDirForNodeDumping(\n     const DebugNodeKey& debug_node_key, const Tensor& tensor,\n-    const uint64 wall_time_us, const string& dump_root_dir,\n-    string* dump_file_path, const int64_t step_id) {\n-  const string file_path = GetDumpFilePathForNodeDumping(\n+    const uint64_t wall_time_us, const std::string& dump_root_dir,\n+    std::string* dump_file_path, const int64_t step_id) {\n+  const std::string file_path = GetDumpFilePathForNodeDumping(\n       dump_root_dir, debug_node_key, wall_time_us, step_id);\n   if (dump_file_path != nullptr) {\n     *dump_file_path = file_path;\n@@ -629,9 +634,9 @@ absl::Status DebugFileIO::DumpTensorToDirForNodeDumping(\n   return DumpTensorToEventFile(debug_node_key, tensor, wall_time_us, file_path);\n }\n \n-string DebugFileIO::GetDumpFilePath(const string& dump_root_dir,\n-                                    const DebugNodeKey& debug_node_key,\n-                                    const uint64 wall_time_us) {\n+std::string DebugFileIO::GetDumpFilePath(const std::string& dump_root_dir,\n+                                         const DebugNodeKey& debug_node_key,\n+                                         const uint64_t wall_time_us) {\n   return AppendTimestampToFilePath(\n       io::JoinPath(dump_root_dir, debug_node_key.device_path,\n                    strings::StrCat(debug_node_key.node_name, \"_\",\n@@ -640,9 +645,9 @@ string DebugFileIO::GetDumpFilePath(const string& dump_root_dir,\n       wall_time_us);\n }\n \n-string DebugFileIO::GetDumpFilePathForNodeDumping(\n-    const string& dump_root_dir, const DebugNodeKey& debug_node_key,\n-    const uint64 wall_time_us, const int64_t step_id) {\n+std::string DebugFileIO::GetDumpFilePathForNodeDumping(\n+    const std::string& dump_root_dir, const DebugNodeKey& debug_node_key,\n+    const uint64_t wall_time_us, const int64_t step_id) {\n   return AppendTimestampToFilePath(\n       io::JoinPath(\n           dump_root_dir, kDumpSubDirName, absl::StrCat(\"step-\", step_id),\n@@ -654,8 +659,8 @@ string DebugFileIO::GetDumpFilePathForNodeDumping(\n }\n \n absl::Status DebugFileIO::DumpEventProtoToFile(const Event& event_proto,\n-                                               const string& dir_name,\n-                                               const string& file_name) {\n+                                               const std::string& dir_name,\n+                                               const std::string& file_name) {\n   Env* env(Env::Default());\n \n   absl::Status s = RecursiveCreateDir(env, dir_name);\n@@ -665,9 +670,9 @@ absl::Status DebugFileIO::DumpEventProtoToFile(const Event& event_proto,\n                                      \", due to: \", s.message()));\n   }\n \n-  const string file_path = io::JoinPath(dir_name, file_name);\n+  const std::string file_path = io::JoinPath(dir_name, file_name);\n \n-  string event_str;\n+  std::string event_str;\n   event_proto.SerializeToString(&event_str);\n \n   std::unique_ptr<WritableFile> f = nullptr;\n@@ -680,21 +685,21 @@ absl::Status DebugFileIO::DumpEventProtoToFile(const Event& event_proto,\n \n absl::Status DebugFileIO::DumpTensorToEventFile(\n     const DebugNodeKey& debug_node_key, const Tensor& tensor,\n-    const uint64 wall_time_us, const string& file_path) {\n+    const uint64_t wall_time_us, const std::string& file_path) {\n   std::vector<Event> events;\n   TF_RETURN_IF_ERROR(\n       WrapTensorAsEvents(debug_node_key, tensor, wall_time_us, 0, &events));\n-  return DumpEventProtoToFile(events[0], string(io::Dirname(file_path)),\n-                              string(io::Basename(file_path)));\n+  return DumpEventProtoToFile(events[0], std::string(io::Dirname(file_path)),\n+                              std::string(io::Basename(file_path)));\n }\n \n-absl::Status DebugFileIO::RecursiveCreateDir(Env* env, const string& dir) {\n+absl::Status DebugFileIO::RecursiveCreateDir(Env* env, const std::string& dir) {\n   if (env->FileExists(dir).ok() && env->IsDirectory(dir).ok()) {\n     // The path already exists as a directory. Return OK right away.\n     return absl::OkStatus();\n   }\n \n-  string parent_dir(io::Dirname(dir));\n+  std::string parent_dir(io::Dirname(dir));\n   if (!env->FileExists(parent_dir).ok()) {\n     // The parent path does not exist yet, create it first.\n     absl::Status s = RecursiveCreateDir(env, parent_dir);  // Recursive call\n@@ -724,13 +729,13 @@ absl::Status DebugFileIO::RecursiveCreateDir(Env* env, const string& dir) {\n }\n \n // Default total disk usage limit: 100 GBytes\n-const uint64 DebugFileIO::kDefaultGlobalDiskBytesLimit = 107374182400L;\n-uint64 DebugFileIO::global_disk_bytes_limit_ = 0;\n-uint64 DebugFileIO::disk_bytes_used_ = 0;\n+const uint64_t DebugFileIO::kDefaultGlobalDiskBytesLimit = 107374182400L;\n+uint64_t DebugFileIO::global_disk_bytes_limit_ = 0;\n+uint64_t DebugFileIO::disk_bytes_used_ = 0;\n \n mutex DebugFileIO::bytes_mu_(LINKER_INITIALIZED);\n \n-bool DebugFileIO::requestDiskByteUsage(uint64 bytes) {\n+bool DebugFileIO::requestDiskByteUsage(uint64_t bytes) {\n   mutex_lock l(bytes_mu_);\n   if (global_disk_bytes_limit_ == 0) {\n     const char* env_tfdbg_disk_bytes_limit = getenv(\"TFDBG_DISK_BYTES_LIMIT\");\n@@ -760,13 +765,13 @@ void DebugFileIO::resetDiskByteUsage() {\n }\n \n #ifndef PLATFORM_WINDOWS\n-DebugGrpcChannel::DebugGrpcChannel(const string& server_stream_addr)\n+DebugGrpcChannel::DebugGrpcChannel(const std::string& server_stream_addr)\n     : server_stream_addr_(server_stream_addr),\n       url_(absl::StrCat(DebugIO::kGrpcURLScheme, server_stream_addr)) {}\n \n absl::Status DebugGrpcChannel::Connect(const int64_t timeout_micros) {\n   ::grpc::ChannelArguments args;\n-  args.SetInt(GRPC_ARG_MAX_MESSAGE_LENGTH, std::numeric_limits<int32>::max());\n+  args.SetInt(GRPC_ARG_MAX_MESSAGE_LENGTH, std::numeric_limits<int32_t>::max());\n   // Avoid problems where default reconnect backoff is too long (e.g., 20 s).\n   args.SetInt(GRPC_ARG_MAX_RECONNECT_BACKOFF_MS, 1000);\n   channel_ = ::grpc::CreateCustomChannel(\n@@ -801,9 +806,10 @@ void DebugGrpcChannel::ReceiveAndProcessEventReplies(const size_t max_replies) {\n          ReadEventReply(&event_reply)) {\n     for (const EventReply::DebugOpStateChange& debug_op_state_change :\n          event_reply.debug_op_state_changes()) {\n-      string watch_key = strings::StrCat(debug_op_state_change.node_name(), \":\",\n-                                         debug_op_state_change.output_slot(),\n-                                         \":\", debug_op_state_change.debug_op());\n+      std::string watch_key =\n+          strings::StrCat(debug_op_state_change.node_name(), \":\",\n+                          debug_op_state_change.output_slot(), \":\",\n+                          debug_op_state_change.debug_op());\n       DebugGrpcIO::SetDebugNodeKeyGrpcState(url_, watch_key,\n                                             debug_op_state_change.state());\n     }\n@@ -832,17 +838,17 @@ const size_t DebugGrpcIO::kGrpcMessageSizeLimitBytes = 4000 * 1024;\n \n const size_t DebugGrpcIO::kGrpcMaxVarintLengthSize = 6;\n \n-std::unordered_map<string, std::unique_ptr<DebugGrpcChannel>>*\n+std::unordered_map<std::string, std::unique_ptr<DebugGrpcChannel>>*\n DebugGrpcIO::GetStreamChannels() {\n-  static std::unordered_map<string, std::unique_ptr<DebugGrpcChannel>>*\n-      stream_channels =\n-          new std::unordered_map<string, std::unique_ptr<DebugGrpcChannel>>();\n+  static std::unordered_map<\n+      std::string, std::unique_ptr<DebugGrpcChannel>>* stream_channels =\n+      new std::unordered_map<std::string, std::unique_ptr<DebugGrpcChannel>>();\n   return stream_channels;\n }\n \n absl::Status DebugGrpcIO::SendTensorThroughGrpcStream(\n     const DebugNodeKey& debug_node_key, const Tensor& tensor,\n-    const uint64 wall_time_us, const string& grpc_stream_url,\n+    const uint64_t wall_time_us, const std::string& grpc_stream_url,\n     const bool gated) {\n   if (gated &&\n       !IsReadGateOpen(grpc_stream_url, debug_node_key.debug_node_name)) {\n@@ -868,7 +874,7 @@ absl::Status DebugGrpcIO::SendTensorThroughGrpcStream(\n }\n \n absl::Status DebugGrpcIO::ReceiveEventReplyProtoThroughGrpcStream(\n-    EventReply* event_reply, const string& grpc_stream_url) {\n+    EventReply* event_reply, const std::string& grpc_stream_url) {\n   DebugGrpcChannel* debug_grpc_channel = nullptr;\n   TF_RETURN_IF_ERROR(\n       GetOrCreateDebugGrpcChannel(grpc_stream_url, &debug_grpc_channel));\n@@ -881,16 +887,16 @@ absl::Status DebugGrpcIO::ReceiveEventReplyProtoThroughGrpcStream(\n }\n \n absl::Status DebugGrpcIO::GetOrCreateDebugGrpcChannel(\n-    const string& grpc_stream_url, DebugGrpcChannel** debug_grpc_channel) {\n-  const string addr_with_path =\n+    const std::string& grpc_stream_url, DebugGrpcChannel** debug_grpc_channel) {\n+  const std::string addr_with_path =\n       absl::StartsWith(grpc_stream_url, DebugIO::kGrpcURLScheme)\n           ? grpc_stream_url.substr(strlen(DebugIO::kGrpcURLScheme))\n           : grpc_stream_url;\n-  const string server_stream_addr =\n+  const std::string server_stream_addr =\n       addr_with_path.substr(0, addr_with_path.find('/'));\n   {\n     mutex_lock l(streams_mu_);\n-    std::unordered_map<string, std::unique_ptr<DebugGrpcChannel>>*\n+    std::unordered_map<std::string, std::unique_ptr<DebugGrpcChannel>>*\n         stream_channels = GetStreamChannels();\n     if (stream_channels->find(grpc_stream_url) == stream_channels->end()) {\n       std::unique_ptr<DebugGrpcChannel> channel(\n@@ -905,7 +911,7 @@ absl::Status DebugGrpcIO::GetOrCreateDebugGrpcChannel(\n }\n \n absl::Status DebugGrpcIO::SendEventProtoThroughGrpcStream(\n-    const Event& event_proto, const string& grpc_stream_url,\n+    const Event& event_proto, const std::string& grpc_stream_url,\n     const bool receive_reply) {\n   DebugGrpcChannel* debug_grpc_channel;\n   TF_RETURN_IF_ERROR(\n@@ -924,15 +930,15 @@ absl::Status DebugGrpcIO::SendEventProtoThroughGrpcStream(\n   return absl::OkStatus();\n }\n \n-bool DebugGrpcIO::IsReadGateOpen(const string& grpc_debug_url,\n-                                 const string& watch_key) {\n+bool DebugGrpcIO::IsReadGateOpen(const std::string& grpc_debug_url,\n+                                 const std::string& watch_key) {\n   const DebugNodeName2State* enabled_node_to_state =\n       GetEnabledDebugOpStatesAtUrl(grpc_debug_url);\n   return enabled_node_to_state->find(watch_key) != enabled_node_to_state->end();\n }\n \n-bool DebugGrpcIO::IsWriteGateOpen(const string& grpc_debug_url,\n-                                  const string& watch_key) {\n+bool DebugGrpcIO::IsWriteGateOpen(const std::string& grpc_debug_url,\n+                                  const std::string& watch_key) {\n   const DebugNodeName2State* enabled_node_to_state =\n       GetEnabledDebugOpStatesAtUrl(grpc_debug_url);\n   auto it = enabled_node_to_state->find(watch_key);\n@@ -943,10 +949,10 @@ bool DebugGrpcIO::IsWriteGateOpen(const string& grpc_debug_url,\n   }\n }\n \n-absl::Status DebugGrpcIO::CloseGrpcStream(const string& grpc_stream_url) {\n+absl::Status DebugGrpcIO::CloseGrpcStream(const std::string& grpc_stream_url) {\n   mutex_lock l(streams_mu_);\n \n-  std::unordered_map<string, std::unique_ptr<DebugGrpcChannel>>*\n+  std::unordered_map<std::string, std::unique_ptr<DebugGrpcChannel>>*\n       stream_channels = GetStreamChannels();\n   if (stream_channels->find(grpc_stream_url) != stream_channels->end()) {\n     // Stream of the specified address exists. Close it and remove it from\n@@ -961,18 +967,18 @@ absl::Status DebugGrpcIO::CloseGrpcStream(const string& grpc_stream_url) {\n   }\n }\n \n-std::unordered_map<string, DebugGrpcIO::DebugNodeName2State>*\n+std::unordered_map<std::string, DebugGrpcIO::DebugNodeName2State>*\n DebugGrpcIO::GetEnabledDebugOpStates() {\n-  static std::unordered_map<string, DebugNodeName2State>*\n+  static std::unordered_map<std::string, DebugNodeName2State>*\n       enabled_debug_op_states =\n-          new std::unordered_map<string, DebugNodeName2State>();\n+          new std::unordered_map<std::string, DebugNodeName2State>();\n   return enabled_debug_op_states;\n }\n \n DebugGrpcIO::DebugNodeName2State* DebugGrpcIO::GetEnabledDebugOpStatesAtUrl(\n-    const string& grpc_debug_url) {\n+    const std::string& grpc_debug_url) {\n   static mutex* debug_ops_state_mu = new mutex();\n-  std::unordered_map<string, DebugNodeName2State>* states =\n+  std::unordered_map<std::string, DebugNodeName2State>* states =\n       GetEnabledDebugOpStates();\n \n   mutex_lock l(*debug_ops_state_mu);\n@@ -984,7 +990,7 @@ DebugGrpcIO::DebugNodeName2State* DebugGrpcIO::GetEnabledDebugOpStatesAtUrl(\n }\n \n void DebugGrpcIO::SetDebugNodeKeyGrpcState(\n-    const string& grpc_debug_url, const string& watch_key,\n+    const std::string& grpc_debug_url, const std::string& watch_key,\n     const EventReply::DebugOpStateChange::State new_state) {\n   DebugNodeName2State* states = GetEnabledDebugOpStatesAtUrl(grpc_debug_url);\n   if (new_state == EventReply::DebugOpStateChange::DISABLED) {"
        },
        {
            "sha": "99107971f0f2b432f35088ca0743c37630cac68f",
            "filename": "tensorflow/core/debug/debug_io_utils.h",
            "status": "modified",
            "additions": 59,
            "deletions": 55,
            "changes": 114,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_io_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_io_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_io_utils.h?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -36,15 +36,15 @@ limitations under the License.\n \n namespace tensorflow {\n \n-absl::Status ReadEventFromFile(const string& dump_file_path, Event* event);\n+absl::Status ReadEventFromFile(const std::string& dump_file_path, Event* event);\n \n struct DebugWatchAndURLSpec {\n-  DebugWatchAndURLSpec(const string& watch_key, const string& url,\n+  DebugWatchAndURLSpec(const std::string& watch_key, const std::string& url,\n                        const bool gated_grpc)\n       : watch_key(watch_key), url(url), gated_grpc(gated_grpc) {}\n \n-  const string watch_key;\n-  const string url;\n+  const std::string watch_key;\n+  const std::string url;\n   const bool gated_grpc;\n };\n \n@@ -63,10 +63,11 @@ class DebugIO {\n \n   static absl::Status PublishDebugMetadata(\n       const int64_t global_step, const int64_t session_run_index,\n-      const int64_t executor_step_index, const std::vector<string>& input_names,\n-      const std::vector<string>& output_names,\n-      const std::vector<string>& target_nodes,\n-      const std::unordered_set<string>& debug_urls);\n+      const int64_t executor_step_index,\n+      const std::vector<std::string>& input_names,\n+      const std::vector<std::string>& output_names,\n+      const std::vector<std::string>& target_nodes,\n+      const std::unordered_set<std::string>& debug_urls);\n \n   // Publishes a tensor to a debug target URL.\n   //\n@@ -82,22 +83,24 @@ class DebugIO {\n   //   step_id: Step ID associated with the tensor.\n   static absl::Status PublishDebugTensor(\n       const DebugNodeKey& debug_node_key, const Tensor& tensor,\n-      const uint64 wall_time_us, const absl::Span<const string> debug_urls,\n-      bool gated_grpc, int64_t step_id = -1);\n+      const uint64_t wall_time_us,\n+      const absl::Span<const std::string> debug_urls, bool gated_grpc,\n+      int64_t step_id = -1);\n \n   // Convenience overload of the method above for no gated_grpc by default.\n   static absl::Status PublishDebugTensor(\n       const DebugNodeKey& debug_node_key, const Tensor& tensor,\n-      const uint64 wall_time_us, const absl::Span<const string> debug_urls);\n+      const uint64_t wall_time_us,\n+      const absl::Span<const std::string> debug_urls);\n \n   // Publishes a graph to a set of debug URLs.\n   //\n   // Args:\n   //   graph: The graph to be published.\n   //   debug_urls: The set of debug URLs to publish the graph to.\n   static absl::Status PublishGraph(\n-      const Graph& graph, const string& device_name,\n-      const std::unordered_set<string>& debug_urls);\n+      const Graph& graph, const std::string& device_name,\n+      const std::unordered_set<std::string>& debug_urls);\n \n   // Determines whether a copy node needs to perform deep-copy of input tensor.\n   //\n@@ -126,8 +129,8 @@ class DebugIO {\n   //\n   // Returns:\n   //   Whether this debug op should proceed.\n-  static bool IsDebugNodeGateOpen(const string& watch_key,\n-                                  const std::vector<string>& debug_urls);\n+  static bool IsDebugNodeGateOpen(const std::string& watch_key,\n+                                  const std::vector<std::string>& debug_urls);\n \n   // Determines whether debug information should be sent through a grpc://\n   // debug URL given the current gRPC gating status.\n@@ -141,10 +144,10 @@ class DebugIO {\n   // Returns:\n   //   Whether the sending of debug data to the debug_url should\n   //     proceed.\n-  static bool IsDebugURLGateOpen(const string& watch_key,\n-                                 const string& debug_url);\n+  static bool IsDebugURLGateOpen(const std::string& watch_key,\n+                                 const std::string& debug_url);\n \n-  static absl::Status CloseDebugURL(const string& debug_url);\n+  static absl::Status CloseDebugURL(const std::string& debug_url);\n };\n \n // Helper class for debug ops.\n@@ -171,15 +174,15 @@ class DebugFileIO {\n   //   dump_file_path: The actual dump file path (passed as reference).\n   static absl::Status DumpTensorToDir(const DebugNodeKey& debug_node_key,\n                                       const Tensor& tensor,\n-                                      const uint64 wall_time_us,\n-                                      const string& dump_root_dir,\n-                                      string* dump_file_path);\n+                                      const uint64_t wall_time_us,\n+                                      const std::string& dump_root_dir,\n+                                      std::string* dump_file_path);\n \n   // Similar to the above, but for node inputs/outputs dumping feature.\n   static absl::Status DumpTensorToDirForNodeDumping(\n       const DebugNodeKey& debug_node_key, const Tensor& tensor,\n-      uint64 wall_time_us, const string& dump_root_dir, string* dump_file_path,\n-      int64_t step_id);\n+      uint64_t wall_time_us, const std::string& dump_root_dir,\n+      std::string* dump_file_path, int64_t step_id);\n \n   // Get the full path to the dump file.\n   //\n@@ -190,14 +193,14 @@ class DebugFileIO {\n   //   output_slot: Output slot index of the said node, e.g., 0.\n   //   debug_op: Name of the debug op, e.g., DebugIdentity.\n   //   wall_time_us: Time stamp of the dumped tensor, in microseconds (us).\n-  static string GetDumpFilePath(const string& dump_root_dir,\n-                                const DebugNodeKey& debug_node_key,\n-                                const uint64 wall_time_us);\n+  static std::string GetDumpFilePath(const std::string& dump_root_dir,\n+                                     const DebugNodeKey& debug_node_key,\n+                                     const uint64_t wall_time_us);\n \n   // Similar to the above, but for node inputs/outputs dumping feature.\n-  static string GetDumpFilePathForNodeDumping(\n-      const string& dump_root_dir, const DebugNodeKey& debug_node_key,\n-      uint64 wall_time_us, int64_t step_id);\n+  static std::string GetDumpFilePathForNodeDumping(\n+      const std::string& dump_root_dir, const DebugNodeKey& debug_node_key,\n+      uint64_t wall_time_us, int64_t step_id);\n \n   // Dumps an Event proto to a file.\n   //\n@@ -206,8 +209,8 @@ class DebugFileIO {\n   //   dir_name: Directory path.\n   //   file_name: Base file name.\n   static absl::Status DumpEventProtoToFile(const Event& event_proto,\n-                                           const string& dir_name,\n-                                           const string& file_name);\n+                                           const std::string& dir_name,\n+                                           const std::string& file_name);\n \n   // Request additional bytes to be dumped to the file system.\n   //\n@@ -222,31 +225,31 @@ class DebugFileIO {\n   // Returns:\n   //   Whether the request is approved given the total dumping\n   //   limit.\n-  static bool requestDiskByteUsage(uint64 bytes);\n+  static bool requestDiskByteUsage(uint64_t bytes);\n \n   // Reset the disk byte usage to zero.\n   static void resetDiskByteUsage();\n \n-  static uint64 global_disk_bytes_limit_;\n+  static uint64_t global_disk_bytes_limit_;\n \n  private:\n   // Encapsulates the Tensor in an Event protobuf and write it to file.\n   static absl::Status DumpTensorToEventFile(const DebugNodeKey& debug_node_key,\n                                             const Tensor& tensor,\n-                                            const uint64 wall_time_us,\n-                                            const string& file_path);\n+                                            const uint64_t wall_time_us,\n+                                            const std::string& file_path);\n \n   // Implemented ad hoc here for now.\n   // TODO(cais): Replace with shared implementation once http://b/30497715 is\n   // fixed.\n-  static absl::Status RecursiveCreateDir(Env* env, const string& dir);\n+  static absl::Status RecursiveCreateDir(Env* env, const std::string& dir);\n \n   // Tracks how much disk has been used so far.\n-  static uint64 disk_bytes_used_;\n+  static uint64_t disk_bytes_used_;\n   // Mutex for thread-safe access to disk_bytes_used_.\n   static mutex bytes_mu_;\n   // Default limit for the disk space.\n-  static const uint64 kDefaultGlobalDiskBytesLimit;\n+  static const uint64_t kDefaultGlobalDiskBytesLimit;\n \n   friend class DiskUsageLimitTest;\n };\n@@ -282,7 +285,7 @@ class DebugGrpcChannel {\n   //   server_stream_addr: Address (host name and port) of the debug stream\n   //     server implementing the EventListener service (see\n   //     debug_service.proto). E.g., \"127.0.0.1:12345\".\n-  explicit DebugGrpcChannel(const string& server_stream_addr);\n+  explicit DebugGrpcChannel(const std::string& server_stream_addr);\n \n   virtual ~DebugGrpcChannel() {}\n \n@@ -337,8 +340,8 @@ class DebugGrpcChannel {\n   absl::Status ReceiveServerRepliesAndClose();\n \n  private:\n-  string server_stream_addr_;\n-  string url_;\n+  std::string server_stream_addr_;\n+  std::string url_;\n   ::grpc::ClientContext ctx_;\n   std::shared_ptr<::grpc::Channel> channel_;\n   std::unique_ptr<grpc::EventListener::Stub> stub_;\n@@ -356,7 +359,7 @@ class DebugGrpcIO {\n   // Sends a tensor through a debug gRPC stream.\n   static absl::Status SendTensorThroughGrpcStream(\n       const DebugNodeKey& debug_node_key, const Tensor& tensor,\n-      const uint64 wall_time_us, const string& grpc_stream_url,\n+      const uint64_t wall_time_us, const std::string& grpc_stream_url,\n       const bool gated);\n \n   // Sends an Event proto through a debug gRPC stream.\n@@ -373,40 +376,40 @@ class DebugGrpcIO {\n   // Returns:\n   //   The Status of the operation.\n   static absl::Status SendEventProtoThroughGrpcStream(\n-      const Event& event_proto, const string& grpc_stream_url,\n+      const Event& event_proto, const std::string& grpc_stream_url,\n       const bool receive_reply = false);\n \n   // Receive an EventReply proto through a debug gRPC stream.\n   static absl::Status ReceiveEventReplyProtoThroughGrpcStream(\n-      EventReply* event_reply, const string& grpc_stream_url);\n+      EventReply* event_reply, const std::string& grpc_stream_url);\n \n   // Check whether a debug watch key is read-activated at a given gRPC URL.\n-  static bool IsReadGateOpen(const string& grpc_debug_url,\n-                             const string& watch_key);\n+  static bool IsReadGateOpen(const std::string& grpc_debug_url,\n+                             const std::string& watch_key);\n \n   // Check whether a debug watch key is write-activated (i.e., read- and\n   // write-activated) at a given gRPC URL.\n-  static bool IsWriteGateOpen(const string& grpc_debug_url,\n-                              const string& watch_key);\n+  static bool IsWriteGateOpen(const std::string& grpc_debug_url,\n+                              const std::string& watch_key);\n \n   // Closes a gRPC stream to the given address, if it exists.\n   // Thread-safety: Safe with respect to other calls to the same method and\n   // calls to SendTensorThroughGrpcStream().\n-  static absl::Status CloseGrpcStream(const string& grpc_stream_url);\n+  static absl::Status CloseGrpcStream(const std::string& grpc_stream_url);\n \n   // Set the gRPC state of a debug node key.\n   // TODO(cais): Include device information in watch_key.\n   static void SetDebugNodeKeyGrpcState(\n-      const string& grpc_debug_url, const string& watch_key,\n+      const std::string& grpc_debug_url, const std::string& watch_key,\n       const EventReply::DebugOpStateChange::State new_state);\n \n  private:\n   using DebugNodeName2State =\n-      std::unordered_map<string, EventReply::DebugOpStateChange::State>;\n+      std::unordered_map<std::string, EventReply::DebugOpStateChange::State>;\n \n   // Returns a global map from grpc debug URLs to the corresponding\n   // DebugGrpcChannels.\n-  static std::unordered_map<string, std::unique_ptr<DebugGrpcChannel>>*\n+  static std::unordered_map<std::string, std::unique_ptr<DebugGrpcChannel>>*\n   GetStreamChannels();\n \n   // Get a DebugGrpcChannel object at a given URL, creating one if necessary.\n@@ -420,15 +423,16 @@ class DebugGrpcIO {\n   // Returns:\n   //   Status of this operation.\n   static absl::Status GetOrCreateDebugGrpcChannel(\n-      const string& grpc_stream_url, DebugGrpcChannel** debug_grpc_channel);\n+      const std::string& grpc_stream_url,\n+      DebugGrpcChannel** debug_grpc_channel);\n \n   // Returns a map from debug URL to a map from debug op name to enabled state.\n-  static std::unordered_map<string, DebugNodeName2State>*\n+  static std::unordered_map<std::string, DebugNodeName2State>*\n   GetEnabledDebugOpStates();\n \n   // Returns a map from debug op names to enabled state, for a given debug URL.\n   static DebugNodeName2State* GetEnabledDebugOpStatesAtUrl(\n-      const string& grpc_debug_url);\n+      const std::string& grpc_debug_url);\n \n   // Clear enabled debug op state from all debug URLs (if any).\n   static void ClearEnabledWatchKeys();"
        },
        {
            "sha": "fde63f53331cf10fccddb7124842b749d8d4f4f4",
            "filename": "tensorflow/core/debug/debug_io_utils_test.cc",
            "status": "modified",
            "additions": 26,
            "deletions": 26,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_io_utils_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_io_utils_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_io_utils_test.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -107,19 +107,19 @@ TEST_F(DebugIOUtilsTest, DebugNodeKeysIsHashable) {\n TEST_F(DebugIOUtilsTest, DumpFloatTensorToFileSunnyDay) {\n   Initialize();\n \n-  const string test_dir =\n+  const std::string test_dir =\n       absl::StrCat(testing::TmpDir(), \"/DumpFloatTensorToFileSunnyDay\");\n   if (!env_->FileExists(test_dir).ok()) {\n     ASSERT_TRUE(env_->RecursivelyCreateDir(test_dir).ok());\n   }\n \n   // Append levels of nonexisting directories, to test that the function can\n   // create directories.\n-  const uint64 wall_time = env_->NowMicros();\n+  const uint64_t wall_time = env_->NowMicros();\n   const DebugNodeKey kDebugNodeKey(\"/job:localhost/replica:0/task:0/cpu:0\",\n                                    \"foo/bar/qux/tensor_a\", 0, \"DebugIdentity\");\n \n-  string dump_file_path;\n+  std::string dump_file_path;\n   TF_ASSERT_OK(DebugFileIO::DumpTensorToDir(\n       kDebugNodeKey, *tensor_a_, wall_time, test_dir, &dump_file_path));\n \n@@ -154,16 +154,16 @@ TEST_F(DebugIOUtilsTest, DumpFloatTensorToFileSunnyDay) {\n TEST_F(DebugIOUtilsTest, DumpStringTensorToFileSunnyDay) {\n   Initialize();\n \n-  const string test_dir =\n+  const std::string test_dir =\n       absl::StrCat(testing::TmpDir(), \"/DumpStringTensorToFileSunnyDay\");\n   if (!env_->FileExists(test_dir).ok()) {\n     ASSERT_TRUE(env_->RecursivelyCreateDir(test_dir).ok());\n   }\n   const DebugNodeKey kDebugNodeKey(\"/job:localhost/replica:0/task:0/cpu:0\",\n                                    \"quux/grault/tensor_b\", 1, \"DebugIdentity\");\n-  const uint64 wall_time = env_->NowMicros();\n+  const uint64_t wall_time = env_->NowMicros();\n \n-  string dump_file_name;\n+  std::string dump_file_name;\n   absl::Status s = DebugFileIO::DumpTensorToDir(\n       kDebugNodeKey, *tensor_b_, wall_time, test_dir, &dump_file_name);\n   ASSERT_TRUE(s.ok());\n@@ -209,17 +209,17 @@ TEST_F(DebugIOUtilsTest, DumpTensorToFileCannotCreateDirectory) {\n   Initialize();\n \n   // First, create the file at the path.\n-  const string test_dir =\n+  const std::string test_dir =\n       absl::StrCat(testing::TmpDir(), \"/DumpTensorToFileCannotCreateDirectory\");\n   if (!env_->FileExists(test_dir).ok()) {\n     ASSERT_TRUE(env_->RecursivelyCreateDir(test_dir).ok());\n   }\n-  const string kDeviceName = \"/job:localhost/replica:0/task:0/cpu:0\";\n+  const std::string kDeviceName = \"/job:localhost/replica:0/task:0/cpu:0\";\n   const DebugNodeKey kDebugNodeKey(kDeviceName, \"baz/tensor_a\", 0,\n                                    \"DebugIdentity\");\n-  const string txt_file_dir =\n+  const std::string txt_file_dir =\n       io::JoinPath(test_dir, DebugNodeKey::DeviceNameToDevicePath(kDeviceName));\n-  const string txt_file_name = io::JoinPath(txt_file_dir, \"baz\");\n+  const std::string txt_file_name = io::JoinPath(txt_file_dir, \"baz\");\n   if (!env_->FileExists(txt_file_dir).ok()) {\n     ASSERT_TRUE(env_->RecursivelyCreateDir(txt_file_dir).ok());\n   }\n@@ -238,9 +238,9 @@ TEST_F(DebugIOUtilsTest, DumpTensorToFileCannotCreateDirectory) {\n   // Second, try to dump the tensor to a path that requires \"baz\" to be a\n   // directory, which should lead to an error.\n \n-  const uint64 wall_time = env_->NowMicros();\n+  const uint64_t wall_time = env_->NowMicros();\n \n-  string dump_file_name;\n+  std::string dump_file_name;\n   absl::Status s = DebugFileIO::DumpTensorToDir(\n       kDebugNodeKey, *tensor_a_, wall_time, test_dir, &dump_file_name);\n   ASSERT_FALSE(s.ok());\n@@ -261,13 +261,13 @@ TEST_F(DebugIOUtilsTest, PublishTensorToMultipleFileURLs) {\n   const int kNumDumpRoots = 3;\n   const DebugNodeKey kDebugNodeKey(\"/job:localhost/replica:0/task:0/cpu:0\",\n                                    \"foo/bar/qux/tensor_a\", 0, \"DebugIdentity\");\n-  const uint64 wall_time = env_->NowMicros();\n+  const uint64_t wall_time = env_->NowMicros();\n \n-  std::vector<string> dump_roots;\n-  std::vector<string> dump_file_paths;\n-  std::vector<string> urls;\n+  std::vector<std::string> dump_roots;\n+  std::vector<std::string> dump_file_paths;\n+  std::vector<std::string> urls;\n   for (int i = 0; i < kNumDumpRoots; ++i) {\n-    string dump_root =\n+    std::string dump_root =\n         absl::StrCat(testing::TmpDir(), \"/PublicTensorToMultipleFileUrls_\", i);\n \n     dump_roots.push_back(dump_root);\n@@ -331,10 +331,10 @@ TEST_F(DebugIOUtilsTest, PublishTensorToMemoryCallback) {\n \n   const DebugNodeKey kDebugNodeKey(\"/job:localhost/replica:0/task:0/cpu:0\",\n                                    \"foo/bar/qux/tensor_a\", 0, \"DebugIdentity\");\n-  const uint64 wall_time = env_->NowMicros();\n+  const uint64_t wall_time = env_->NowMicros();\n \n   bool called = false;\n-  std::vector<string> urls = {\"memcbk://test_callback\"};\n+  std::vector<std::string> urls = {\"memcbk://test_callback\"};\n   ;\n \n   auto* callback_registry = DebugCallbackRegistry::singleton();\n@@ -367,17 +367,17 @@ TEST_F(DebugIOUtilsTest, PublishTensorConcurrentlyToPartiallyOverlappingPaths) {\n \n   thread::ThreadPool* tp =\n       new thread::ThreadPool(Env::Default(), \"test\", kConcurrentPubs);\n-  const uint64 wall_time = env_->NowMicros();\n-  const string dump_root_base =\n+  const uint64_t wall_time = env_->NowMicros();\n+  const std::string dump_root_base =\n       absl::StrCat(testing::TmpDir(),\n                    \"/PublishTensorConcurrentlyToPartiallyOverlappingPaths\");\n   if (!env_->FileExists(dump_root_base).ok()) {\n     ASSERT_TRUE(env_->RecursivelyCreateDir(dump_root_base).ok());\n   }\n \n   mutex mu;\n-  std::vector<string> dump_roots TF_GUARDED_BY(mu);\n-  std::vector<string> dump_file_paths TF_GUARDED_BY(mu);\n+  std::vector<std::string> dump_roots TF_GUARDED_BY(mu);\n+  std::vector<std::string> dump_file_paths TF_GUARDED_BY(mu);\n \n   int dump_count TF_GUARDED_BY(mu) = 0;\n   int done_count TF_GUARDED_BY(mu) = 0;\n@@ -387,8 +387,8 @@ TEST_F(DebugIOUtilsTest, PublishTensorConcurrentlyToPartiallyOverlappingPaths) {\n              &dump_file_paths, &wall_time, &kDebugNodeKey, &kConcurrentPubs,\n              &all_done]() {\n     // \"gumpy\" is the shared directory part of the path.\n-    string dump_root;\n-    string debug_url;\n+    std::string dump_root;\n+    std::string debug_url;\n     {\n       mutex_lock l(mu);\n       dump_root =\n@@ -401,7 +401,7 @@ TEST_F(DebugIOUtilsTest, PublishTensorConcurrentlyToPartiallyOverlappingPaths) {\n       debug_url = absl::StrCat(\"file://\", dump_root);\n     }\n \n-    std::vector<string> urls;\n+    std::vector<std::string> urls;\n     urls.push_back(debug_url);\n \n     absl::Status s ="
        },
        {
            "sha": "09510b8df1bfb8b05c464dd2153e137d3ab5d70b",
            "filename": "tensorflow/core/debug/debug_node_key.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_node_key.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_node_key.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_node_key.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -26,9 +26,11 @@ const char* const DebugNodeKey::kMetadataFilePrefix = \"_tfdbg_\";\n \n const char* const DebugNodeKey::kDeviceTag = \"device_\";\n \n-DebugNodeKey::DebugNodeKey(const string& device_name, const string& node_name,\n-                           const int32_t output_slot, const string& debug_op,\n-                           const string& io_of_node, const bool is_input,\n+DebugNodeKey::DebugNodeKey(const std::string& device_name,\n+                           const std::string& node_name,\n+                           const int32_t output_slot,\n+                           const std::string& debug_op,\n+                           const std::string& io_of_node, const bool is_input,\n                            const int32_t io_index)\n     : device_name(device_name),\n       node_name(node_name),\n@@ -52,7 +54,8 @@ bool DebugNodeKey::operator!=(const DebugNodeKey& other) const {\n   return !((*this) == other);\n }\n \n-const string DebugNodeKey::DeviceNameToDevicePath(const string& device_name) {\n+const std::string DebugNodeKey::DeviceNameToDevicePath(\n+    const std::string& device_name) {\n   return absl::StrCat(kMetadataFilePrefix, kDeviceTag,\n                       str_util::StringReplace(\n                           str_util::StringReplace(device_name, \":\", \"_\", true),"
        },
        {
            "sha": "867e080931432470b6ff928c44a59c5b60acd101",
            "filename": "tensorflow/core/debug/debug_node_key.h",
            "status": "modified",
            "additions": 13,
            "deletions": 12,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_node_key.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebug_node_key.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebug_node_key.h?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -27,28 +27,29 @@ struct DebugNodeKey {\n   static const char* const kMetadataFilePrefix;\n   static const char* const kDeviceTag;\n \n-  DebugNodeKey(const string& device_name, const string& node_name,\n-               int32_t output_slot, const string& debug_op,\n-               const string& io_of_node = \"\", bool is_input = false,\n+  DebugNodeKey(const std::string& device_name, const std::string& node_name,\n+               int32_t output_slot, const std::string& debug_op,\n+               const std::string& io_of_node = \"\", bool is_input = false,\n                int32_t io_index = -1);\n \n   // Converts a device name string to a device path string.\n   // E.g., /job:localhost/replica:0/task:0/cpu:0 will be converted to\n   //   ,job_localhost,replica_0,task_0,cpu_0.\n-  static const string DeviceNameToDevicePath(const string& device_name);\n+  static const std::string DeviceNameToDevicePath(\n+      const std::string& device_name);\n \n   bool operator==(const DebugNodeKey& other) const;\n   bool operator!=(const DebugNodeKey& other) const;\n \n-  const string device_name;\n-  const string node_name;\n-  const int32 output_slot;\n-  const string debug_op;\n-  const string debug_node_name;\n-  const string device_path;\n-  const string io_of_node;\n+  const std::string device_name;\n+  const std::string node_name;\n+  const int32_t output_slot;\n+  const std::string debug_op;\n+  const std::string debug_node_name;\n+  const std::string device_path;\n+  const std::string io_of_node;\n   const bool is_input;\n-  const int32 io_index;\n+  const int32_t io_index;\n };\n \n }  // namespace tensorflow"
        },
        {
            "sha": "23b70b431d8dd0da90a150722a66da06a15e259d",
            "filename": "tensorflow/core/debug/debugger_state_impl.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebugger_state_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebugger_state_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebugger_state_impl.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -23,7 +23,7 @@ namespace tensorflow {\n DebuggerState::DebuggerState(const DebugOptions& debug_options) {\n   for (const DebugTensorWatch& watch :\n        debug_options.debug_tensor_watch_opts()) {\n-    for (const string& url : watch.debug_urls()) {\n+    for (const std::string& url : watch.debug_urls()) {\n       debug_urls_.insert(url);\n     }\n   }\n@@ -33,16 +33,17 @@ DebuggerState::DebuggerState(const DebugOptions& debug_options) {\n }\n \n DebuggerState::~DebuggerState() {\n-  for (const string& debug_url : debug_urls_) {\n+  for (const std::string& debug_url : debug_urls_) {\n     DebugIO::CloseDebugURL(debug_url).IgnoreError();\n   }\n }\n \n absl::Status DebuggerState::PublishDebugMetadata(\n     const int64_t global_step, const int64_t session_run_index,\n-    const int64_t executor_step_index, const std::vector<string>& input_names,\n-    const std::vector<string>& output_names,\n-    const std::vector<string>& target_names) {\n+    const int64_t executor_step_index,\n+    const std::vector<std::string>& input_names,\n+    const std::vector<std::string>& output_names,\n+    const std::vector<std::string>& target_names) {\n   return DebugIO::PublishDebugMetadata(global_step, session_run_index,\n                                        executor_step_index, input_names,\n                                        output_names, target_names, debug_urls_);\n@@ -55,11 +56,11 @@ absl::Status DebugGraphDecorator::DecorateGraph(Graph* graph, Device* device) {\n }\n \n absl::Status DebugGraphDecorator::PublishGraph(const Graph& graph,\n-                                               const string& device_name) {\n-  std::unordered_set<string> debug_urls;\n+                                               const std::string& device_name) {\n+  std::unordered_set<std::string> debug_urls;\n   for (const DebugTensorWatch& watch :\n        debug_options_.debug_tensor_watch_opts()) {\n-    for (const string& url : watch.debug_urls()) {\n+    for (const std::string& url : watch.debug_urls()) {\n       debug_urls.insert(url);\n     }\n   }"
        },
        {
            "sha": "73e74738d59d3c582dd0bef1b360261a166149a1",
            "filename": "tensorflow/core/debug/debugger_state_impl.h",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebugger_state_impl.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fdebugger_state_impl.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fdebugger_state_impl.h?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -34,12 +34,13 @@ class DebuggerState : public DebuggerStateInterface {\n   // details.\n   absl::Status PublishDebugMetadata(\n       const int64_t global_step, const int64_t session_run_count,\n-      const int64_t executor_step_count, const std::vector<string>& input_names,\n-      const std::vector<string>& output_names,\n-      const std::vector<string>& target_names) override;\n+      const int64_t executor_step_count,\n+      const std::vector<std::string>& input_names,\n+      const std::vector<std::string>& output_names,\n+      const std::vector<std::string>& target_names) override;\n \n  private:\n-  std::unordered_set<string> debug_urls_;\n+  std::unordered_set<std::string> debug_urls_;\n };\n \n class DebugGraphDecorator : public DebugGraphDecoratorInterface {\n@@ -50,7 +51,7 @@ class DebugGraphDecorator : public DebugGraphDecoratorInterface {\n \n   absl::Status DecorateGraph(Graph* graph, Device* device) override;\n   absl::Status PublishGraph(const Graph& graph,\n-                            const string& device_name) override;\n+                            const std::string& device_name) override;\n \n  private:\n   DebugOptions debug_options_;"
        },
        {
            "sha": "4e58928e5693ddef9476b171bf97ada489039459",
            "filename": "tensorflow/core/debug/grpc_session_debug_test.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 11,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fgrpc_session_debug_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a137ca105e47c64930f3e792ea4dc2f9fdea2f46/tensorflow%2Fcore%2Fdebug%2Fgrpc_session_debug_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fdebug%2Fgrpc_session_debug_test.cc?ref=a137ca105e47c64930f3e792ea4dc2f9fdea2f46",
            "patch": "@@ -49,7 +49,7 @@ SessionOptions Devices(int num_cpus, int num_gpus) {\n   return result;\n }\n \n-void CreateGraphDef(GraphDef* graph_def, string node_names[3]) {\n+void CreateGraphDef(GraphDef* graph_def, std::string node_names[3]) {\n   Graph graph(OpRegistry::Global());\n \n   Tensor a_tensor(DT_FLOAT, TensorShape({1, 2}));\n@@ -77,7 +77,7 @@ void IsSingleFloatValue(const Tensor& val, float expected_val) {\n   ASSERT_EQ(val.flat<float>()(0), expected_val);\n }\n \n-SessionOptions Options(const string& target, int placement_period) {\n+SessionOptions Options(const std::string& target, int placement_period) {\n   SessionOptions options;\n   // NOTE(mrry): GrpcSession requires a grpc:// scheme prefix in the target\n   // string.\n@@ -115,18 +115,19 @@ class GrpcSessionDebugTest : public ::testing::Test {\n     }\n   }\n \n-  const string GetDebugURL() { return debug_url_; }\n+  const std::string GetDebugURL() { return debug_url_; }\n \n-  void LoadTensorDumps(const string& subdir, std::vector<Tensor>* tensors) {\n-    const string dirpath = io::JoinPath(dump_dir_, subdir);\n+  void LoadTensorDumps(const std::string& subdir,\n+                       std::vector<Tensor>* tensors) {\n+    const std::string dirpath = io::JoinPath(dump_dir_, subdir);\n     if (!(Env::Default()->IsDirectory(dirpath).ok())) {\n       return;\n     }\n \n-    std::vector<string> filenames;\n+    std::vector<std::string> filenames;\n     TF_ASSERT_OK(Env::Default()->GetChildren(dirpath, &filenames));\n \n-    for (const string& filename : filenames) {\n+    for (const std::string& filename : filenames) {\n       Event event;\n       TF_ASSERT_OK(ReadEventFromFile(io::JoinPath(dirpath, filename), &event));\n       if (event.summary().value().size() == 1) {\n@@ -144,13 +145,13 @@ class GrpcSessionDebugTest : public ::testing::Test {\n     debug_url_ = absl::StrCat(\"file://\", dump_dir_);\n   }\n \n-  string dump_dir_;\n-  string debug_url_;\n+  std::string dump_dir_;\n+  std::string debug_url_;\n };\n \n TEST_F(GrpcSessionDebugTest, FileDebugURL) {\n   GraphDef graph;\n-  string node_names[3];\n+  std::string node_names[3];\n   CreateGraphDef(&graph, node_names);\n \n   std::unique_ptr<test::TestCluster> cluster;\n@@ -216,7 +217,8 @@ TEST_F(GrpcSessionDebugTest, FileDebugURL) {\n   TF_CHECK_OK(session->Close());\n }\n \n-void SetDevice(GraphDef* graph, const string& name, const string& dev) {\n+void SetDevice(GraphDef* graph, const std::string& name,\n+               const std::string& dev) {\n   for (size_t i = 0; i < graph->node_size(); ++i) {\n     if (graph->node(i).name() == name) {\n       graph->mutable_node(i)->set_device(dev);"
        }
    ],
    "stats": {
        "total": 756,
        "additions": 390,
        "deletions": 366
    }
}