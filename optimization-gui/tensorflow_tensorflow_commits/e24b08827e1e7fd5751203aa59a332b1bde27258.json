{
    "author": "unknown",
    "message": "[XLA:GPU] ThunkBufferDebugPass: recursively apply instrumentation to entire thunk graph\n\nBefore this change, the debug instrumentation was only applied to thunks in the\nroot ThunkSequence, but not to sub-thunks of, for example,\nConditionalThunk/WhileThunk. This patch fixes that oversight.\n\nPiperOrigin-RevId: 827530474",
    "sha": "e24b08827e1e7fd5751203aa59a332b1bde27258",
    "files": [
        {
            "sha": "4a8524e6f9d61b13c1e825b3a3d3ca0cf693e6ab",
            "filename": "third_party/xla/xla/backends/gpu/runtime/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e24b08827e1e7fd5751203aa59a332b1bde27258/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e24b08827e1e7fd5751203aa59a332b1bde27258/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2FBUILD?ref=e24b08827e1e7fd5751203aa59a332b1bde27258",
            "patch": "@@ -2935,12 +2935,14 @@ xla_cc_test(\n     deps = [\n         \":buffers_checksum_thunk\",\n         \":buffers_nan_count_thunk\",\n+        \":conditional_thunk\",\n         \":custom_call_thunk\",\n         \":sequential_thunk\",\n         \":thunk\",\n         \":thunk_buffer_debug_pass\",\n         \":thunk_id\",\n         \":thunk_pass_pipeline\",\n+        \":while_thunk\",\n         \"//xla:literal_util\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/runtime:buffer_use\","
        },
        {
            "sha": "3a3f3ab7e429c95cf8c808824d4d3840c8bc4209",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_pass.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 15,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e24b08827e1e7fd5751203aa59a332b1bde27258/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e24b08827e1e7fd5751203aa59a332b1bde27258/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass.cc?ref=e24b08827e1e7fd5751203aa59a332b1bde27258",
            "patch": "@@ -285,23 +285,25 @@ absl::StatusOr<bool> ThunkBufferDebugPass::Run(\n                                               /*results=*/{}, /*attributes=*/{},\n                                               hlo_module->entry_computation()));\n \n-  ThunkSequence& thunks = root_thunk->thunks();\n-  for (auto& thunk : thunks) {\n-    if (mode_ == Mode::kChecksum) {\n-      VLOG(1) << \"Wrapping with checksum thunk\";\n-      thunk = WrapWithChecksumThunk(\n-          std::move(thunk), log_slice,\n-          /*predecessor_thunk=*/*buffer_debug_init_thunk,\n-          /*successor_thunk=*/*buffer_debug_dump_thunk, metadata_store);\n-    } else if (mode_ == Mode::kNanCounter) {\n-      VLOG(1) << \"Wrapping with nan counter thunk\";\n-      thunk = WrapWithNanCounterThunk(\n-          std::move(thunk), log_slice,\n-          /*predecessor_thunk=*/*buffer_debug_init_thunk,\n-          /*successor_thunk=*/*buffer_debug_dump_thunk, metadata_store);\n+  root_thunk->TransformAllNestedThunks([&](std::unique_ptr<Thunk> thunk) {\n+    switch (mode_) {\n+      case Mode::kChecksum:\n+        VLOG(1) << \"Wrapping with checksum thunk\";\n+        return WrapWithChecksumThunk(\n+            std::move(thunk), log_slice,\n+            /*predecessor_thunk=*/*buffer_debug_init_thunk,\n+            /*successor_thunk=*/*buffer_debug_dump_thunk, metadata_store);\n+      case Mode::kNanCounter:\n+        VLOG(1) << \"Wrapping with nan counter thunk\";\n+        return WrapWithNanCounterThunk(\n+            std::move(thunk), log_slice,\n+            /*predecessor_thunk=*/*buffer_debug_init_thunk,\n+            /*successor_thunk=*/*buffer_debug_dump_thunk, metadata_store);\n     }\n-  }\n+    return thunk;\n+  });\n \n+  ThunkSequence& thunks = root_thunk->thunks();\n   thunks.reserve(thunks.size() + 2);\n   thunks.insert(thunks.begin(), std::move(buffer_debug_init_thunk));\n   thunks.push_back(std::move(buffer_debug_dump_thunk));"
        },
        {
            "sha": "e67e6dc4ca796fb6ac87c1516f5ce8ac5fc029f0",
            "filename": "third_party/xla/xla/backends/gpu/runtime/thunk_buffer_debug_pass_test.cc",
            "status": "modified",
            "additions": 278,
            "deletions": 32,
            "changes": 310,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/e24b08827e1e7fd5751203aa59a332b1bde27258/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/e24b08827e1e7fd5751203aa59a332b1bde27258/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fruntime%2Fthunk_buffer_debug_pass_test.cc?ref=e24b08827e1e7fd5751203aa59a332b1bde27258",
            "patch": "@@ -15,7 +15,9 @@ limitations under the License.\n \n #include \"xla/backends/gpu/runtime/thunk_buffer_debug_pass.h\"\n \n+#include <cstddef>\n #include <cstdint>\n+#include <initializer_list>\n #include <memory>\n #include <utility>\n #include <vector>\n@@ -26,11 +28,13 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"xla/backends/gpu/runtime/buffers_checksum_thunk.h\"\n #include \"xla/backends/gpu/runtime/buffers_nan_count_thunk.h\"\n+#include \"xla/backends/gpu/runtime/conditional_thunk.h\"\n #include \"xla/backends/gpu/runtime/custom_call_thunk.h\"\n #include \"xla/backends/gpu/runtime/sequential_thunk.h\"\n #include \"xla/backends/gpu/runtime/thunk.h\"\n #include \"xla/backends/gpu/runtime/thunk_id.h\"\n #include \"xla/backends/gpu/runtime/thunk_pass_pipeline.h\"\n+#include \"xla/backends/gpu/runtime/while_thunk.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n@@ -46,13 +50,48 @@ namespace gpu {\n namespace {\n \n using testing::ElementsAre;\n+using testing::Eq;\n using testing::Pair;\n using testing::Pointer;\n using testing::SizeIs;\n using testing::UnorderedElementsAre;\n+using testing::UnorderedElementsAreArray;\n \n MATCHER_P(IsUniquePointerTo, ptr, \"\") { return arg.get() == ptr; }\n \n+MATCHER_P(ThunkKindIs, kind, \"\") {\n+  return ExplainMatchResult(Eq(kind), arg->kind(), result_listener);\n+}\n+\n+MATCHER_P(IsCustomCallThunkWithTargetName, target_name, \"\") {\n+  return ExplainMatchResult(Eq(Thunk::Kind::kCustomCall), arg->kind(),\n+                            result_listener) &&\n+         ExplainMatchResult(\n+             Eq(target_name),\n+             static_cast<const CustomCallThunk&>(*arg).target_name(),\n+             result_listener);\n+}\n+\n+MATCHER_P(IsChecksumThunkChecking, slice, \"\") {\n+  return ExplainMatchResult(Eq(Thunk::Kind::kBuffersDebugChecksum), arg->kind(),\n+                            result_listener) &&\n+         ExplainMatchResult(UnorderedElementsAreArray(slice),\n+                            static_cast<const BuffersDebugChecksumThunk&>(*arg)\n+                                .buffer_slices(),\n+                            result_listener);\n+}\n+\n+MATCHER_P(IsSequentialThunkWith, thunk_matcher, \"\") {\n+  return ExplainMatchResult(Eq(Thunk::Kind::kSequential), arg->kind(),\n+                            result_listener) &&\n+         ExplainMatchResult(thunk_matcher,\n+                            static_cast<const SequentialThunk&>(*arg).thunks(),\n+                            result_listener);\n+}\n+\n+using SliceList =\n+    std::initializer_list<std::pair<size_t, BufferAllocation::Slice>>;\n+\n class FakeThunkPassBufferAllocator : public ThunkPassBufferAllocator {\n  public:\n   absl::StatusOr<BufferAllocation*> NewEmptyAllocation(int64_t size) override {\n@@ -85,7 +124,39 @@ class FakeThunk : public Thunk {\n   BufferUses buffer_uses_;\n };\n \n-TEST(ThunkBufferDebugPassTest, IsNoOpWhenHloModuleIsNull) {\n+class ThunkBufferDebugPassTest : public ::testing::Test {\n+ protected:\n+  void SetUp() override {\n+    // The callbacks created by ThunkBufferDebugPass require a HloModule\n+    // with a non-null entry computation.\n+    auto builder = HloComputation::Builder(\"entry\");\n+    HloInstruction* root = builder.AddInstruction(\n+        HloInstruction::CreateConstant(LiteralUtil::CreateR0(1)));\n+    std::unique_ptr<HloComputation> entry_computation = builder.Build(root);\n+    fake_hlo_module_ =\n+        std::make_unique<HloModule>(\"test_module\", HloModuleConfig());\n+    fake_hlo_module_->AddEntryComputation(std::move(entry_computation));\n+  }\n+\n+  Thunk::ThunkInfo ThunkInfoWithId(ThunkId thunk_id) {\n+    Thunk::ThunkInfo info;\n+    info.thunk_id = thunk_id;\n+    return info;\n+  }\n+\n+  // Create a new, unique, non-null slice backed by `alloc_`.\n+  BufferAllocation::Slice CreateSlice() {\n+    BufferAllocation::Slice slice(&alloc_, used_alloc_size_, 1);\n+    used_alloc_size_ += slice.size();\n+    return slice;\n+  }\n+\n+  BufferAllocation alloc_ = BufferAllocation(0, 1024, 0);\n+  size_t used_alloc_size_ = 0;\n+  std::unique_ptr<HloModule> fake_hlo_module_;\n+};\n+\n+TEST_F(ThunkBufferDebugPassTest, IsNoOpWhenHloModuleIsNull) {\n   DebugOptions debug_options;\n   debug_options.set_xla_gpu_experimental_enable_checksum_tracing_on_thunks(\n       true);\n@@ -109,7 +180,7 @@ TEST(ThunkBufferDebugPassTest, IsNoOpWhenHloModuleIsNull) {\n   EXPECT_THAT(root_thunk->thunks(), ElementsAre(Pointer(fake_thunk_ptr)));\n }\n \n-TEST(ThunkBufferDebugPassTest, InsertsBuffersDebugChecksumThunks) {\n+TEST_F(ThunkBufferDebugPassTest, InsertsBuffersDebugChecksumThunks) {\n   static constexpr ThunkId kTestThunkId = ThunkId(123);\n   DebugOptions debug_options;\n   debug_options.set_xla_gpu_experimental_enable_checksum_tracing_on_thunks(\n@@ -160,46 +231,221 @@ TEST(ThunkBufferDebugPassTest, InsertsBuffersDebugChecksumThunks) {\n \n   // Expected thunk structure after the pass:\n   // 1. CustomCallThunk (buffer debug log init)\n-  // 2. SequentialThunk\n+  // 2. SequentialThunk [\n   //    1. BuffersDebugChecksumThunk (checksum input buffers)\n   //    2. FakeThunk\n   //    3. BuffersDebugChecksumThunk (checksum output buffers)\n+  // ]\n   // 3. CustomCallThunk (buffer debug log dump)\n   const std::vector<std::unique_ptr<Thunk>>& new_thunks = root_thunk->thunks();\n-  EXPECT_THAT(new_thunks, SizeIs(3));\n-  EXPECT_EQ(new_thunks[0]->kind(), Thunk::Kind::kCustomCall);\n-  EXPECT_EQ(new_thunks[1]->kind(), Thunk::Kind::kSequential);\n-  EXPECT_EQ(new_thunks[2]->kind(), Thunk::Kind::kCustomCall);\n+  EXPECT_THAT(\n+      new_thunks,\n+      ElementsAre(\n+          IsCustomCallThunkWithTargetName(\"xla_gpu_buffer_debug_log_init\"),\n+          IsSequentialThunkWith(ElementsAre(IsChecksumThunkChecking(SliceList{\n+                                                {0, slice_i},\n+                                                {2, slice_io},\n+                                            }),\n+                                            Pointer(fake_thunk_ptr),\n+                                            IsChecksumThunkChecking(SliceList{\n+                                                {1, slice_o},\n+                                                {2, slice_io},\n+                                            }))),\n+          IsCustomCallThunkWithTargetName(\"xla_gpu_buffer_debug_log_dump\")));\n+}\n \n-  const CustomCallThunk& buffer_debug_init_thunk =\n-      static_cast<const CustomCallThunk&>(*new_thunks[0]);\n-  EXPECT_EQ(buffer_debug_init_thunk.target_name(),\n-            \"xla_gpu_buffer_debug_log_init\");\n+TEST_F(ThunkBufferDebugPassTest, RecursivelyInsertsBuffersDebugChecksumThunks) {\n+  static constexpr ThunkId kWhileConditionFakeThunkId = ThunkId(100);\n+  static constexpr ThunkId kWhileBodyId = ThunkId(101);\n+  static constexpr ThunkId kBranch0ThunkId = ThunkId(102);\n+  static constexpr ThunkId kBranch1ThunkId = ThunkId(103);\n+  DebugOptions debug_options;\n+  debug_options.set_xla_gpu_experimental_enable_checksum_tracing_on_thunks(\n+      true);\n+  se::DeviceDescription device_info;\n+  FakeThunkPassBufferAllocator allocator;\n+  // Create a fake thunk with a few different buffer uses.\n+  BufferAllocation::Slice slice_while_condition = CreateSlice();\n+  BufferAllocation::Slice slice_while_body = CreateSlice();\n+  BufferAllocation::Slice slice_branch0 = CreateSlice();\n+  BufferAllocation::Slice slice_branch1 = CreateSlice();\n+  // Setup a thunk tree.\n+  auto while_condition_fake_thunk = std::make_unique<FakeThunk>(\n+      ThunkInfoWithId(kWhileConditionFakeThunkId),\n+      Thunk::BufferUses{BufferUse::Read(slice_while_condition)});\n+  const Thunk* const while_condition_fake_thunk_ptr =\n+      while_condition_fake_thunk.get();\n+  auto while_body_fake_thunk = std::make_unique<FakeThunk>(\n+      ThunkInfoWithId(kWhileBodyId),\n+      Thunk::BufferUses{BufferUse::Read(slice_while_body)});\n+  const Thunk* const while_body_fake_thunk_ptr = while_body_fake_thunk.get();\n+  auto conditional_branch0_thunk = std::make_unique<FakeThunk>(\n+      ThunkInfoWithId(kBranch0ThunkId),\n+      Thunk::BufferUses{BufferUse::Read(slice_branch0)});\n+  const Thunk* const branch0_thunk_ptr = conditional_branch0_thunk.get();\n+  auto conditional_branch1_thunk = std::make_unique<FakeThunk>(\n+      ThunkInfoWithId(kBranch1ThunkId),\n+      Thunk::BufferUses{BufferUse::Read(slice_branch1)});\n+  const Thunk* const branch1_thunk_ptr = conditional_branch1_thunk.get();\n+  std::vector<std::unique_ptr<SequentialThunk>> branch_thunks;\n+  branch_thunks.push_back(\n+      SequentialThunk::FromThunk(std::move(conditional_branch0_thunk)));\n+  branch_thunks.push_back(\n+      SequentialThunk::FromThunk(std::move(conditional_branch1_thunk)));\n+  auto conditional_thunk = std::make_unique<ConditionalThunk>(\n+      Thunk::ThunkInfo(),\n+      /*branch_index_buffer_index=*/BufferAllocation::Slice(),\n+      std::move(branch_thunks),\n+      /*branch_index_is_bool=*/true);\n+  const Thunk* const conditional_thunk_ptr = conditional_thunk.get();\n+  std::vector<std::unique_ptr<Thunk>> while_body_thunks;\n+  while_body_thunks.push_back(std::move(while_body_fake_thunk));\n+  while_body_thunks.push_back(std::move(conditional_thunk));\n+  auto while_thunk = std::make_unique<WhileThunk>(\n+      Thunk::ThunkInfo(), /*loop=*/nullptr,\n+      /*condition_result_buffer_index=*/BufferAllocation::Slice(),\n+      /*condition_thunk_sequence=*/\n+      SequentialThunk::FromThunk(std::move(while_condition_fake_thunk)),\n+      /*body_thunk_sequence=*/\n+      std::make_unique<SequentialThunk>(Thunk::ThunkInfo(),\n+                                        std::move(while_body_thunks)));\n+  std::unique_ptr<SequentialThunk> root_thunk =\n+      SequentialThunk::FromThunk(std::move(while_thunk));\n+\n+  // Thunk structure before the pass:\n+  // 1. WhileThunk\n+  //    Condition: SequentialThunk [\n+  //       FakeThunk (kWhileConditionFakeThunkId)\n+  //    ]\n+  //    Body: SequentialThunk [\n+  //       FakeThunk (kWhileBodyId)\n+  //       ConditionalThunk [\n+  //          Branch 0: SequentialThunk [\n+  //             FakeThunk (kBranch0ThunkId)\n+  //          ]\n+  //          Branch 1: SequentialThunk [\n+  //             FakeThunk (kBranch1ThunkId)\n+  //          ]\n+  //       ]\n+  //    ]\n \n-  const CustomCallThunk& buffer_debug_dump_thunk =\n-      static_cast<const CustomCallThunk&>(*new_thunks[2]);\n-  EXPECT_EQ(buffer_debug_dump_thunk.target_name(),\n-            \"xla_gpu_buffer_debug_log_dump\");\n+  ThunkBufferDebugPass pass(ThunkBufferDebugPass::Mode::kChecksum);\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      bool changed, pass.Run(root_thunk.get(), debug_options,\n+                             fake_hlo_module_.get(), device_info, allocator));\n+  EXPECT_TRUE(changed);\n \n-  const std::vector<std::unique_ptr<Thunk>>& sub_thunks =\n-      static_cast<const SequentialThunk&>(*new_thunks[1]).thunks();\n-  EXPECT_THAT(sub_thunks, SizeIs(3));\n-  EXPECT_EQ(sub_thunks[0]->kind(), Thunk::Kind::kBuffersDebugChecksum);\n-  EXPECT_THAT(sub_thunks[1], Pointer(fake_thunk_ptr));\n-  EXPECT_EQ(sub_thunks[2]->kind(), Thunk::Kind::kBuffersDebugChecksum);\n-\n-  const BuffersDebugChecksumThunk& buffer_debug_before_fake_thunk =\n-      static_cast<const BuffersDebugChecksumThunk&>(*sub_thunks[0]);\n-  EXPECT_THAT(buffer_debug_before_fake_thunk.buffer_slices(),\n-              UnorderedElementsAre(Pair(0, slice_i), Pair(2, slice_io)));\n-\n-  const BuffersDebugChecksumThunk& buffer_debug_after_fake_thunk =\n-      static_cast<const BuffersDebugChecksumThunk&>(*sub_thunks[2]);\n-  EXPECT_THAT(buffer_debug_after_fake_thunk.buffer_slices(),\n-              UnorderedElementsAre(Pair(1, slice_o), Pair(2, slice_io)));\n+  // Each FakeThunk is supposed to be transformed into a SequentialThunk\n+  // containing the original FakeThunk sandwiched between two\n+  // BuffersDebugChecksumThunk thunks.\n+  //\n+  // Thunk structure after the pass:\n+  // 1. CustomCallThunk (buffer debug log init)\n+  // 2. WhileThunk\n+  //    1. Condition: SequentialThunk [\n+  //       1. SequentialThunk [\n+  //          1. BuffersDebugChecksumThunk (checksum input buffers)\n+  //          2. FakeThunk (kWhileConditionFakeThunkId)\n+  //          3. BuffersDebugChecksumThunk (checksum output buffers)\n+  //       ]\n+  //    ]\n+  //    2. Body: SequentialThunk [\n+  //       1. SequentialThunk [\n+  //          1. BuffersDebugChecksumThunk (checksum input buffers)\n+  //          2. FakeThunk (kWhileBodyId)\n+  //          3. BuffersDebugChecksumThunk (checksum output buffers)\n+  //       ]\n+  //       2. ConditionalThunk [\n+  //          Branch 0: SequentialThunk [\n+  //             1. SequentialThunk [\n+  //                1. BuffersDebugChecksumThunk (checksum input buffers)\n+  //                2. FakeThunk (kBranch0ThunkId)\n+  //                3. BuffersDebugChecksumThunk (checksum output buffers)\n+  //             ]\n+  //          ]\n+  //          Branch 1: SequentialThunk [\n+  //             1. SequentialThunk [\n+  //                1. BuffersDebugChecksumThunk (checksum input buffers)\n+  //                2. FakeThunk (kBranch1ThunkId)\n+  //                3. BuffersDebugChecksumThunk (checksum output buffers)\n+  //             ]\n+  //          ]\n+  //       ]\n+  //    ]\n+  // 3. CustomCallThunk (buffer debug log dump)\n+\n+  const std::vector<std::unique_ptr<Thunk>>& new_thunks = root_thunk->thunks();\n+  EXPECT_THAT(\n+      new_thunks,\n+      ElementsAre(\n+          IsCustomCallThunkWithTargetName(\"xla_gpu_buffer_debug_log_init\"),\n+          ThunkKindIs(Thunk::Kind::kWhile),\n+          IsCustomCallThunkWithTargetName(\"xla_gpu_buffer_debug_log_dump\")));\n+\n+  {\n+    ASSERT_EQ(new_thunks[1]->kind(), Thunk::Kind::kWhile);\n+    const WhileThunk& while_thunk =\n+        static_cast<const WhileThunk&>(*new_thunks[1]);\n+    EXPECT_THAT(while_thunk.body_thunk_sequence()->thunks(),\n+                ElementsAre(ThunkKindIs(Thunk::Kind::kSequential),\n+                            Pointer(conditional_thunk_ptr)));\n+    const SequentialThunk& condition_fake_thunk_sequence =\n+        static_cast<const SequentialThunk&>(\n+            *while_thunk.condition_thunk_sequence()->thunks()[0]);\n+    EXPECT_THAT(\n+        condition_fake_thunk_sequence.thunks(),\n+        ElementsAre(\n+            IsChecksumThunkChecking(SliceList{{0, slice_while_condition}}),\n+            Pointer(while_condition_fake_thunk_ptr),\n+            IsChecksumThunkChecking(SliceList{{0, slice_while_condition}})));\n+\n+    const SequentialThunk& body_fake_thunk_sequence =\n+        static_cast<const SequentialThunk&>(\n+            *while_thunk.body_thunk_sequence()->thunks()[0]);\n+    EXPECT_THAT(\n+        body_fake_thunk_sequence.thunks(),\n+        ElementsAre(IsChecksumThunkChecking(SliceList{{0, slice_while_body}}),\n+                    Pointer(while_body_fake_thunk_ptr),\n+                    IsChecksumThunkChecking(SliceList{{0, slice_while_body}})));\n+\n+    ASSERT_EQ(while_thunk.body_thunk_sequence()->thunks()[1]->kind(),\n+              Thunk::Kind::kConditional);\n+    const ConditionalThunk& conditional_thunk =\n+        static_cast<const ConditionalThunk&>(\n+            *while_thunk.body_thunk_sequence()->thunks()[1]);\n+    EXPECT_THAT(conditional_thunk.branch_thunks(),\n+                ElementsAre(ThunkKindIs(Thunk::Kind::kSequential),\n+                            ThunkKindIs(Thunk::Kind::kSequential)));\n+\n+    const SequentialThunk& branch0_thunk = static_cast<const SequentialThunk&>(\n+        *conditional_thunk.branch_thunks()[0]);\n+    EXPECT_THAT(branch0_thunk.thunks(),\n+                ElementsAre(ThunkKindIs(Thunk::Kind::kSequential)));\n+\n+    const SequentialThunk& branch0_fake_thunk_sequence =\n+        static_cast<const SequentialThunk&>(*branch0_thunk.thunks()[0]);\n+    EXPECT_THAT(\n+        branch0_fake_thunk_sequence.thunks(),\n+        ElementsAre(IsChecksumThunkChecking(SliceList{{0, slice_branch0}}),\n+                    Pointer(branch0_thunk_ptr),\n+                    IsChecksumThunkChecking(SliceList{{0, slice_branch0}})));\n+\n+    const SequentialThunk& branch1_thunk = static_cast<const SequentialThunk&>(\n+        *conditional_thunk.branch_thunks()[1]);\n+    EXPECT_THAT(branch1_thunk.thunks(),\n+                ElementsAre(ThunkKindIs(Thunk::Kind::kSequential)));\n+\n+    const SequentialThunk& branch1_fake_thunk_sequence =\n+        static_cast<const SequentialThunk&>(*branch1_thunk.thunks()[0]);\n+    EXPECT_THAT(\n+        branch1_fake_thunk_sequence.thunks(),\n+        ElementsAre(IsChecksumThunkChecking(SliceList{{0, slice_branch1}}),\n+                    Pointer(branch1_thunk_ptr),\n+                    IsChecksumThunkChecking(SliceList{{0, slice_branch1}})));\n+  }\n }\n \n-TEST(ThunkBufferDebugPassTest, InsertsBuffersDebugNanCounterThunks) {\n+TEST_F(ThunkBufferDebugPassTest, InsertsBuffersDebugNanCounterThunks) {\n   static constexpr ThunkId kTestThunkId = ThunkId(123);\n   DebugOptions debug_options;\n   debug_options.set_xla_gpu_experimental_enable_nan_counter_on_thunks(true);"
        }
    ],
    "stats": {
        "total": 344,
        "additions": 297,
        "deletions": 47
    }
}