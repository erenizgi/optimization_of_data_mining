{
    "author": "mwhittaker",
    "message": "Simplify `CoordinationServiceAgent` creation.\n\nPreviously, there was a `CreateCoordinationServiceAgent` function and three\npublic `Initialize` methods. Now, there is a single\n`CoordinationServiceAgent::Create` method that does the creation and\ninitialization.\n\nPiperOrigin-RevId: 846456258",
    "sha": "226de359e2cd86d561dfdd87169ebd4fc8a8a02f",
    "files": [
        {
            "sha": "e8f57c5d4e36ecc3596bb1e7c19785ca9a758e11",
            "filename": "third_party/xla/xla/pjrt/distributed/client.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fclient.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fclient.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fclient.cc?ref=226de359e2cd86d561dfdd87169ebd4fc8a8a02f",
            "patch": "@@ -98,13 +98,14 @@ DistributedRuntimeCoordinationServiceClient::\n \n   std::unique_ptr<CoordinationClient> leader_client;\n   leader_client.reset(NewGrpcCoordinationClient(channel));\n-  coord_agent_ = CreateCoordinationServiceAgent();\n-  const absl::Status status = coord_agent_->Initialize(\n+  auto agent = CoordinationServiceAgent::Create(\n       options.env, \"jax_worker\", options.node_id, config,\n       std::move(leader_client), options.missed_heartbeat_callback,\n       options.recoverable);\n-  if (!status.ok()) {\n-    LOG(ERROR) << \"Coordination agent failed to initialize: \" << status;\n+  if (!agent.ok()) {\n+    LOG(ERROR) << \"Coordination agent failed to initialize: \" << agent.status();\n+  } else {\n+    coord_agent_ = *std::move(agent);\n   }\n   task_id_ = options.node_id;\n   config_ = config;"
        },
        {
            "sha": "d50eae2b53bdd10f2a7e0e3bfe7b17d2c0f94a9c",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2FBUILD?ref=226de359e2cd86d561dfdd87169ebd4fc8a8a02f",
            "patch": "@@ -142,6 +142,7 @@ cc_library(\n         \"@com_google_absl//absl/functional:bind_front\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/memory\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n@@ -163,6 +164,7 @@ xla_cc_test(\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:status\",\n+        \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/protobuf:coordination_config_proto_cc_impl\",\n         \"//xla/tsl/protobuf:coordination_service_proto_cc_impl\","
        },
        {
            "sha": "b071e9508a7f1aa62b292b100f40d1e6570e2fac",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/client_server_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fclient_server_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fclient_server_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fclient_server_test.cc?ref=226de359e2cd86d561dfdd87169ebd4fc8a8a02f",
            "patch": "@@ -130,16 +130,17 @@ class ClientServerTest : public ::testing::Test {\n     std::unique_ptr<CoordinationClient> leader_client;\n     leader_client.reset(NewGrpcCoordinationClient(channel));\n \n-    auto coord_agent = CreateCoordinationServiceAgent();\n     CoordinationServiceAgent::Config config =\n         GetConfig(init_and_shutdown_timeout, shutdown_on_destruction);\n-    const absl::Status status = coord_agent->Initialize(\n+    auto coord_agent = CoordinationServiceAgent::Create(\n         tsl::Env::Default(), \"agent\", node_id, config, std::move(leader_client),\n         std::move(error_fn), recoverable);\n-    if (!status.ok()) {\n-      LOG(ERROR) << \"Coordination agent failed to initialize: \" << status;\n+    if (!coord_agent.ok()) {\n+      LOG(ERROR) << \"Coordination agent failed to initialize: \"\n+                 << coord_agent.status();\n+      return nullptr;\n     }\n-    return coord_agent;\n+    return *std::move(coord_agent);\n   }\n \n   void StartService(int num_nodes,"
        },
        {
            "sha": "8e3fa8497577ea0264a128543ce3a350f80b3143",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service_agent.cc",
            "status": "modified",
            "additions": 21,
            "deletions": 58,
            "changes": 79,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.cc?ref=226de359e2cd86d561dfdd87169ebd4fc8a8a02f",
            "patch": "@@ -33,6 +33,7 @@ limitations under the License.\n #include \"absl/functional/bind_front.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n+#include \"absl/memory/memory.h\"\n #include \"absl/status/status.h\"\n #include \"absl/strings/numbers.h\"\n #include \"absl/strings/str_cat.h\"\n@@ -55,7 +56,6 @@ limitations under the License.\n namespace xla {\n using tensorflow::CoordinatedTask;\n using tensorflow::CoordinatedTaskState;\n-using tensorflow::CoordinatedTaskStateInfo;\n using tensorflow::DeviceInfo;\n using tensorflow::KeyValueEntry;\n \n@@ -69,64 +69,40 @@ constexpr char kHeartbeatThread[] = \"CoordinationServiceHeartbeatLoop\";\n \n }  // namespace\n \n-absl::Status CoordinationServiceAgent::Initialize(\n-    tsl::Env* env, absl::string_view job_name, int task_id,\n-    const Config& config, std::unique_ptr<CoordinationClient> leader_client,\n-    tsl::StatusCallback error_fn) {\n-  return Initialize(env, job_name, task_id, config, std::move(leader_client),\n-                    error_fn,\n-                    /*recoverable=*/false);\n-}\n-\n-absl::Status CoordinationServiceAgent::Initialize(\n+/*static*/ absl::StatusOr<std::unique_ptr<CoordinationServiceAgent>>\n+CoordinationServiceAgent::Create(\n     tsl::Env* env, absl::string_view job_name, int task_id,\n     const Config& config, std::unique_ptr<CoordinationClient> leader_client,\n     tsl::StatusCallback error_fn, bool recoverable) {\n-  CoordinatedTask task;\n-  task.set_job_name(std::string(job_name));\n-  task.set_task_id(task_id);\n+  // Validate arguments.\n+  if (config.service_leader.empty()) {\n+    return MakeCoordinationError(absl::InvalidArgumentError(\n+        \"CoordinationServiceAgent must be initialized with a valid leader.\"));\n+  }\n+  if (leader_client == nullptr) {\n+    return MakeCoordinationError(absl::InvalidArgumentError(\n+        \"CoordinationServiceAgent must have a valid leader client.\"));\n+  }\n   if (recoverable) {\n     LOG(WARNING)\n         << \"Using experimental recoverable task feature. The default shutdown \"\n            \"barrier will only block non-recoverable tasks. If a synchronized \"\n            \"shutdown is desired, the user / library should invoke \"\n            \"`WaitAtBarrier` explicitly at the end of the program.\";\n-    task.set_recoverable(true);\n   }\n-  return Initialize(env, task, config, std::move(leader_client), error_fn);\n-}\n \n-absl::Status CoordinationServiceAgent::Initialize(\n-    tsl::Env* env, const CoordinatedTask& task, const Config& config,\n-    std::unique_ptr<CoordinationClient> leader_client,\n-    tsl::StatusCallback error_fn) {\n+  // Record coordination service agent metric.\n   enabled_usage_metric->GetCell()->Set(true);\n-  absl::MutexLock l(state_mu_);\n-  if (state_ != CoordinatedTaskState::TASKSTATE_UNINITIALIZED) {\n-    return MakeCoordinationError(absl::FailedPreconditionError(\n-        \"Coordination service agent has already been initialized.\"));\n-  }\n \n-  env_ = env;\n-  task_ = task;\n-  config_ = config;\n-  if (config_.service_leader.empty()) {\n-    return MakeCoordinationError(absl::InvalidArgumentError(\n-        \"CoordinationServiceAgent must be initialized with a valid leader.\"));\n-  }\n-  leader_client_ = std::move(leader_client);\n-  if (leader_client_ == nullptr) {\n-    return MakeCoordinationError(absl::InvalidArgumentError(\n-        \"CoordinationServiceAgent must have a valid leader client.\"));\n-  }\n-  error_fn_ = error_fn;\n-  state_ = CoordinatedTaskState::TASKSTATE_DISCONNECTED;\n-  return absl::OkStatus();\n-}\n+  CoordinatedTask task;\n+  task.set_job_name(std::string(job_name));\n+  task.set_task_id(task_id);\n+  task.set_recoverable(recoverable);\n \n-bool CoordinationServiceAgent::IsInitialized() {\n-  absl::MutexLock l(state_mu_);\n-  return state_ != CoordinatedTaskState::TASKSTATE_UNINITIALIZED;\n+  // The CoordinationServiceAgent constructor is private, so we can't call\n+  // std::make_unique.\n+  return absl::WrapUnique(new CoordinationServiceAgent(\n+      env, task, config, error_fn, std::move(leader_client)));\n }\n \n bool CoordinationServiceAgent::IsConnected() {\n@@ -354,11 +330,6 @@ const DeviceInfo& CoordinationServiceAgent::GetClusterDeviceInfo() {\n }\n \n absl::StatusOr<CoordinatedTask> CoordinationServiceAgent::GetOwnTask() {\n-  if (!IsInitialized()) {\n-    return MakeCoordinationError(absl::FailedPreconditionError(\n-        \"Agent has not been initialized; we do not \"\n-        \"know the associated task yet.\"));\n-  }\n   return task_;\n }\n \n@@ -964,10 +935,6 @@ absl::Status CoordinationServiceAgent::ValidateRunningAgent(\n }\n \n absl::StatusOr<tsl::Env*> CoordinationServiceAgent::GetEnv() {\n-  if (!IsInitialized()) {\n-    return MakeCoordinationError(absl::FailedPreconditionError(\n-        \"Coordination service agent has not been initialized.\"));\n-  }\n   if (env_ == nullptr) {\n     return MakeCoordinationError(absl::FailedPreconditionError(\n         \"Coordination service agent was not \"\n@@ -976,8 +943,4 @@ absl::StatusOr<tsl::Env*> CoordinationServiceAgent::GetEnv() {\n   return env_;\n }\n \n-std::unique_ptr<CoordinationServiceAgent> CreateCoordinationServiceAgent() {\n-  return std::make_unique<CoordinationServiceAgent>();\n-}\n-\n }  // namespace xla"
        },
        {
            "sha": "429bdec124f9e9f7ec4f386266b6ec7fe8bf16fa",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service_agent.h",
            "status": "modified",
            "additions": 23,
            "deletions": 29,
            "changes": 52,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent.h?ref=226de359e2cd86d561dfdd87169ebd4fc8a8a02f",
            "patch": "@@ -106,30 +106,16 @@ class CoordinationServiceAgent {\n   using ChangedKeyValuesCallback =\n       std::function<void(const std::map<std::string, std::string>&)>;\n \n-  CoordinationServiceAgent() = default;\n+  static absl::StatusOr<std::unique_ptr<CoordinationServiceAgent>> Create(\n+      tsl::Env* env, absl::string_view job_name, int task_id,\n+      const Config& config, std::unique_ptr<CoordinationClient> leader_client,\n+      tsl::StatusCallback error_fn, bool recoverable = false);\n \n   virtual ~CoordinationServiceAgent() {\n     absl::Status s = Shutdown();\n     VLOG(3) << \"Coordination agent dtor failed with status: \" << s;\n   }\n \n-  absl::Status Initialize(tsl::Env* env, absl::string_view job_name,\n-                          int task_id, const Config& config,\n-                          std::unique_ptr<CoordinationClient> leader_client,\n-                          tsl::StatusCallback error_fn, bool recoverable);\n-  absl::Status Initialize(tsl::Env* env, absl::string_view job_name,\n-                          int task_id, const Config& config,\n-                          std::unique_ptr<CoordinationClient> leader_client,\n-                          tsl::StatusCallback error_fn);\n-  absl::Status Initialize(tsl::Env* env,\n-                          const tensorflow::CoordinatedTask& task,\n-                          const Config& config,\n-                          std::unique_ptr<CoordinationClient> leader_client,\n-                          tsl::StatusCallback error_fn);\n-\n-  // Return true if the coordination service agent has been initialized.\n-  bool IsInitialized();\n-\n   // Return true if the coordination service agent has successfully connected\n   // with the Coordination Service\n   bool IsConnected();\n@@ -154,11 +140,11 @@ class CoordinationServiceAgent {\n \n   // State transition in coordination service agent:\n   //\n-  //                 Init              Connect           SetError\n-  //   UNINITIALIZED ---> DISCONNECTED ------> CONNECTED -------> ERROR\n-  //                           ^                                  |\n-  //                           |__________________________________|\n-  //                                         Reset\n+  //               Connect           SetError\n+  //  DISCONNECTED ------> CONNECTED -------> ERROR\n+  //       ^                                  |\n+  //       |__________________________________|\n+  //                     Reset\n \n   // Get task associated with this agent.\n   absl::StatusOr<tensorflow::CoordinatedTask> GetOwnTask();\n@@ -179,7 +165,7 @@ class CoordinationServiceAgent {\n   // distinguish user-specified errors from internal service or RPC failures.\n   // Possible service errors:\n   //   - Internal: Coordination service has shut down.\n-  //   - FailedPrecondition: Uninitialized/disconnected/already in error state.\n+  //   - FailedPrecondition: disconnected/already in error state.\n   //   - InvalidArgument: Unexpected task request\n   absl::Status ReportError(const absl::Status& error);\n \n@@ -290,8 +276,8 @@ class CoordinationServiceAgent {\n   //       for the same barrier, (2) one of the participating tasks is not in\n   //       the cluster, or (3) task making the request is not included in the\n   //       list of participating tasks.\n-  //   - FailedPrecondition: Agent is in UNINITIALIZED or ERROR state, or the\n-  //       same barrier id is still being invoked.\n+  //   - FailedPrecondition: Agent is in ERROR state, or the same barrier id is\n+  //       still being invoked.\n   virtual absl::Status WaitAtBarrier(\n       absl::string_view barrier_id, absl::Duration timeout,\n       const std::vector<tensorflow::CoordinatedTask>& tasks);\n@@ -378,6 +364,16 @@ class CoordinationServiceAgent {\n  private:\n   friend class CoordinationServiceRpcHandler;\n \n+  explicit CoordinationServiceAgent(\n+      tsl::Env* env, const tensorflow::CoordinatedTask& task,\n+      const Config& config, tsl::StatusCallback error_fn,\n+      std::unique_ptr<CoordinationClient> leader_client)\n+      : env_(env),\n+        task_(task),\n+        config_(config),\n+        error_fn_(error_fn),\n+        leader_client_(std::move(leader_client)) {}\n+\n   // Starts sending heartbeats to the coordination service.\n   void StartSendingHeartbeats();\n   // Use long polling to get error from the coordination service.\n@@ -398,7 +394,7 @@ class CoordinationServiceAgent {\n \n   mutable absl::Mutex state_mu_;\n   tensorflow::CoordinatedTaskState state_ ABSL_GUARDED_BY(state_mu_) =\n-      tensorflow::CoordinatedTaskState::TASKSTATE_UNINITIALIZED;\n+      tensorflow::CoordinatedTaskState::TASKSTATE_DISCONNECTED;\n   absl::Status status_ ABSL_GUARDED_BY(state_mu_) = absl::OkStatus();\n   // Tracks the number of times a barrier has been used, keyed by id.\n   absl::flat_hash_map<std::string, int64_t> barrier_counter_\n@@ -429,8 +425,6 @@ class CoordinationServiceAgent {\n   void operator=(const CoordinationServiceAgent&) = delete;\n };\n \n-std::unique_ptr<CoordinationServiceAgent> CreateCoordinationServiceAgent();\n-\n }  // namespace xla\n \n #endif  // XLA_PJRT_DISTRIBUTED_COORDINATION_COORDINATION_SERVICE_AGENT_H_"
        },
        {
            "sha": "e2e983cbb8a4ed9e4d9643bcdfaf6450a37835d2",
            "filename": "third_party/xla/xla/pjrt/distributed/coordination/coordination_service_agent_test.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 17,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fcoordination%2Fcoordination_service_agent_test.cc?ref=226de359e2cd86d561dfdd87169ebd4fc8a8a02f",
            "patch": "@@ -34,6 +34,7 @@ limitations under the License.\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/status.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/protobuf/coordination_config.pb.h\"\n #include \"xla/tsl/protobuf/coordination_service.pb.h\"\n@@ -154,12 +155,13 @@ class CoordinationServiceAgentTest : public ::testing::Test {\n   // Should be called after mocking service responses, before testing the agent.\n   void InitializeAgent(CoordinationServiceAgent::Config config = {}) {\n     config.service_leader = \"test_leader\";\n-    TF_ASSERT_OK(agent_->Initialize(\n-        tsl::Env::Default(), /*job_name=*/\"test_job\",\n-        /*task_id=*/0, config, std::move(client_),\n-        /*error_fn=*/[](absl::Status s) {\n-          LOG(ERROR) << \"Coordination agent is set to error: \" << s;\n-        }));\n+    TF_ASSERT_OK_AND_ASSIGN(\n+        agent_, CoordinationServiceAgent::Create(\n+                    tsl::Env::Default(), /*job_name=*/\"test_job\",\n+                    /*task_id=*/0, config, std::move(client_),\n+                    /*error_fn=*/[](absl::Status s) {\n+                      LOG(ERROR) << \"Coordination agent is set to error: \" << s;\n+                    }));\n   }\n \n   TestCoordinationClient* GetClient() {\n@@ -170,8 +172,7 @@ class CoordinationServiceAgentTest : public ::testing::Test {\n   }\n \n  protected:\n-  std::unique_ptr<CoordinationServiceAgent> agent_ =\n-      CreateCoordinationServiceAgent();\n+  std::unique_ptr<CoordinationServiceAgent> agent_;\n   std::unique_ptr<TestCoordinationClient> client_ =\n       std::make_unique<TestCoordinationClient>();\n };\n@@ -490,18 +491,9 @@ TEST_F(CoordinationServiceAgentTest, GetOwnTask) {\n   EXPECT_EQ(actual_task.task_id(), expected_task.task_id());\n }\n \n-TEST_F(CoordinationServiceAgentTest, GetOwnTask_Uninitialized) {\n-  auto result = agent_->GetOwnTask();\n-\n-  EXPECT_TRUE(absl::IsFailedPrecondition(result.status()));\n-}\n-\n TEST_F(CoordinationServiceAgentTest, GetEnv_SucceedsAfterInit) {\n-  EXPECT_TRUE(absl::IsFailedPrecondition(agent_->GetEnv().status()));\n   InitializeAgent();\n-\n   absl::StatusOr<tsl::Env*> result = agent_->GetEnv();\n-\n   TF_ASSERT_OK(result.status());\n   EXPECT_EQ(*result, tsl::Env::Default());\n }"
        },
        {
            "sha": "2564ccc737b75e9f505654057d65f43ae4c2e732",
            "filename": "third_party/xla/xla/pjrt/distributed/preemption/preemption_sync_manager_test.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 10,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/226de359e2cd86d561dfdd87169ebd4fc8a8a02f/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fdistributed%2Fpreemption%2Fpreemption_sync_manager_test.cc?ref=226de359e2cd86d561dfdd87169ebd4fc8a8a02f",
            "patch": "@@ -163,12 +163,16 @@ class PreemptionSyncManagerTest : public ::testing::Test {\n     };\n     CoordinationServiceAgent::Config coord_config;\n     coord_config.service_leader = \"test_leader\";\n-    CHECK_OK(coord_agent_->Initialize(tsl::Env::Default(), kJobName,\n-                                      /*task_id=*/0, coord_config,\n-                                      std::move(coord_client), error_fn));\n-    CHECK_OK(coord_agent2_->Initialize(tsl::Env::Default(), kJobName,\n-                                       /*task_id=*/1, coord_config,\n-                                       std::move(coord_client2), error_fn));\n+    coord_agent_ =\n+        CoordinationServiceAgent::Create(tsl::Env::Default(), kJobName,\n+                                         /*task_id=*/0, coord_config,\n+                                         std::move(coord_client), error_fn)\n+            .value();\n+    coord_agent2_ =\n+        CoordinationServiceAgent::Create(tsl::Env::Default(), kJobName,\n+                                         /*task_id=*/1, coord_config,\n+                                         std::move(coord_client2), error_fn)\n+            .value();\n     CHECK_OK(coord_agent_->Connect());\n     CHECK_OK(coord_agent2_->Connect());\n   }\n@@ -180,12 +184,10 @@ class PreemptionSyncManagerTest : public ::testing::Test {\n   std::unique_ptr<tsl::AsyncServiceInterface> coord_rpc_service_;\n   std::unique_ptr<tsl::Thread> coord_rpc_thread_;\n   // Owned by task 1.\n-  std::unique_ptr<CoordinationServiceAgent> coord_agent_ =\n-      CreateCoordinationServiceAgent();\n+  std::unique_ptr<CoordinationServiceAgent> coord_agent_;\n   FakePreemptionNotifier* preempt_notifier_;\n   // Owned by task 2.\n-  std::unique_ptr<CoordinationServiceAgent> coord_agent2_ =\n-      CreateCoordinationServiceAgent();\n+  std::unique_ptr<CoordinationServiceAgent> coord_agent2_;\n   FakePreemptionNotifier* preempt_notifier2_;\n };\n "
        }
    ],
    "stats": {
        "total": 201,
        "additions": 78,
        "deletions": 123
    }
}