{
    "author": "ezhulenev",
    "message": "[xla:ffi] Make TypeInfo mandatory in XLA_FFI_REGISTER_TYPE\n\nAdd placeholders for future Type serialization/deserialization. It's not an ABI breaking change as it's unused today, and it allows to avoid ABI breaking change in the future when FFI will add proper ser/des support for user defined types.\n\nPiperOrigin-RevId: 820676169",
    "sha": "4752801386d085aa39e7ade590333484db47ac4f",
    "files": [
        {
            "sha": "229f31866b9e2396d1b25c1974b27f713c0eddb1",
            "filename": "third_party/xla/xla/ffi/api/c_api.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4752801386d085aa39e7ade590333484db47ac4f/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fc_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4752801386d085aa39e7ade590333484db47ac4f/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fc_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fc_api.h?ref=4752801386d085aa39e7ade590333484db47ac4f",
            "patch": "@@ -272,6 +272,8 @@ typedef struct XLA_FFI_TypeId {\n // to destroy their state when executable is being destroyed.\n typedef struct XLA_FFI_TypeInfo {\n   void (*deleter)(void* object);\n+  void (*serialize)();    // placeholder for future use\n+  void (*deserialize)();  // placeholder for future use\n } XLA_FFI_TypeInfo;\n \n // We use byte spans to pass strings to handlers because strings might not be"
        },
        {
            "sha": "bc98f6b9db5c22e6f7330a486252058dc6e336c8",
            "filename": "third_party/xla/xla/ffi/api/ffi.h",
            "status": "modified",
            "additions": 6,
            "deletions": 19,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4752801386d085aa39e7ade590333484db47ac4f/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4752801386d085aa39e7ade590333484db47ac4f/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h?ref=4752801386d085aa39e7ade590333484db47ac4f",
            "patch": "@@ -1466,33 +1466,20 @@ struct CtxDecoding<FfiExecutionContext> {\n //===----------------------------------------------------------------------===//\n \n template <typename T>\n-XLA_FFI_TypeInfo TypeInfo() {\n+constexpr XLA_FFI_TypeInfo TypeInfo() {\n   return XLA_FFI_TypeInfo{[](void* ptr) { delete static_cast<T*>(ptr); }};\n }\n \n-#define XLA_FFI_REGISTER_TYPE_WITH_INFO(API, NAME, TYPE_ID, TYPE_INFO) \\\n-  XLA_FFI_REGISTER_TYPE_WITH_INFO_(API, NAME, TYPE_ID, TYPE_INFO, __COUNTER__)\n-#define XLA_FFI_REGISTER_TYPE_WITH_INFO_(API, NAME, TYPE_ID, TYPE_INFO, N) \\\n-  XLA_FFI_REGISTER_TYPE_WITH_INFO__(API, NAME, TYPE_ID, TYPE_INFO, N)\n-#define XLA_FFI_REGISTER_TYPE_WITH_INFO__(API, NAME, TYPE_ID, TYPE_INFO, N)    \\\n+#define XLA_FFI_REGISTER_TYPE(API, NAME, TYPE_ID, TYPE_INFO) \\\n+  XLA_FFI_REGISTER_TYPE_(API, NAME, TYPE_ID, TYPE_INFO, __COUNTER__)\n+#define XLA_FFI_REGISTER_TYPE_(API, NAME, TYPE_ID, TYPE_INFO, N) \\\n+  XLA_FFI_REGISTER_TYPE__(API, NAME, TYPE_ID, TYPE_INFO, N)\n+#define XLA_FFI_REGISTER_TYPE__(API, NAME, TYPE_ID, TYPE_INFO, N)              \\\n   XLA_FFI_ATTRIBUTE_UNUSED static const XLA_FFI_Error*                         \\\n       xla_ffi_type_##N##_registered_ = [] {                                    \\\n         return ::xla::ffi::Ffi::RegisterTypeId(API, NAME, TYPE_ID, TYPE_INFO); \\\n       }()\n \n-#define XLA_FFI_REGISTER_TYPE_X(x, API, NAME, TYPE_ID, TYPE_INFO, FUNC, ...) \\\n-  FUNC\n-\n-// Registers external type with XLA runtime and assigns it a unique type id.\n-//\n-// This is a trick to define macro with optional parameters.\n-// Source: https://stackoverflow.com/a/8814003\n-#define XLA_FFI_REGISTER_TYPE(API, NAME, TYPE_ID, ...)                  \\\n-  XLA_FFI_REGISTER_TYPE_X(                                              \\\n-      , API, NAME, TYPE_ID, ##__VA_ARGS__,                              \\\n-      XLA_FFI_REGISTER_TYPE_WITH_INFO(API, NAME, TYPE_ID, __VA_ARGS__), \\\n-      XLA_FFI_REGISTER_TYPE_WITH_INFO(API, NAME, TYPE_ID, {nullptr}))\n-\n //===----------------------------------------------------------------------===//\n // UserData\n //===----------------------------------------------------------------------===//"
        },
        {
            "sha": "dce80f46aa9bb056abeab0b47321cf23a8a0b4a5",
            "filename": "third_party/xla/xla/ffi/api/ffi_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4752801386d085aa39e7ade590333484db47ac4f/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4752801386d085aa39e7ade590333484db47ac4f/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc?ref=4752801386d085aa39e7ade590333484db47ac4f",
            "patch": "@@ -1202,13 +1202,14 @@ struct MyDataWithExplicitTypeId {\n \n // Rely on XLA to assign unique type id for the type.\n TypeId MyDataWithAutoTypeId::id = XLA_FFI_UNKNOWN_TYPE_ID;\n-XLA_FFI_REGISTER_TYPE(GetXlaFfiApi(), \"my_data_auto\",\n-                      &MyDataWithAutoTypeId::id);\n+XLA_FFI_REGISTER_TYPE(GetXlaFfiApi(), \"my_data_auto\", &MyDataWithAutoTypeId::id,\n+                      TypeInfo<MyDataWithAutoTypeId>());\n \n // Provide explicit type id and rely on XLA to check that it's unique.\n TypeId MyDataWithExplicitTypeId::id = {42};\n XLA_FFI_REGISTER_TYPE(GetXlaFfiApi(), \"my_data_explicit\",\n-                      &MyDataWithExplicitTypeId::id);\n+                      &MyDataWithExplicitTypeId::id,\n+                      TypeInfo<MyDataWithExplicitTypeId>());\n \n TEST(FfiTest, UserData) {\n   MyDataWithAutoTypeId data0{\"foo\"};\n@@ -1253,7 +1254,8 @@ struct MyState {\n };\n \n TypeId MyState::id = {};  // zero-initialize type id\n-XLA_FFI_REGISTER_TYPE(GetXlaFfiApi(), \"state\", &MyState::id);\n+XLA_FFI_REGISTER_TYPE(GetXlaFfiApi(), \"state\", &MyState::id,\n+                      TypeInfo<MyState>());\n \n TEST(FfiTest, StatefulHandler) {\n   ExecutionState execution_state;"
        },
        {
            "sha": "e8debf7046516b474c3d72faee56b5a9324bf805",
            "filename": "third_party/xla/xla/pjrt/host_callback.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4752801386d085aa39e7ade590333484db47ac4f/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4752801386d085aa39e7ade590333484db47ac4f/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fhost_callback.cc?ref=4752801386d085aa39e7ade590333484db47ac4f",
            "patch": "@@ -181,6 +181,7 @@ CreateHostCallbackStateAndAppendSendRecvCallbacks(\n // First 64 bits of SHA-512 of \"xla::FfiLoadedHostCallbacks\".\n ffi::TypeId FfiLoadedHostCallbacks::id = {7357244197867843242};\n XLA_FFI_REGISTER_TYPE(ffi::GetXlaFfiApi(), \"FfiLoadedHostCallbacks\",\n-                      &FfiLoadedHostCallbacks::id);\n+                      &FfiLoadedHostCallbacks::id,\n+                      ffi::TypeInfo<FfiLoadedHostCallbacks>());\n \n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 40,
        "additions": 16,
        "deletions": 24
    }
}