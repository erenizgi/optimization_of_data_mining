{
    "author": "WillFroom",
    "message": "[XLA][XTile] Update SafeIntegerArithmeticPass to also work with tensors.\n\nPiperOrigin-RevId: 838673735",
    "sha": "618e55810a9f86ccb2c762e4a087edb606264a1c",
    "files": [
        {
            "sha": "9605ff78e9f2f5fd32e9f96c7c8a13ea88443542",
            "filename": "third_party/xla/xla/codegen/emitters/transforms/safe_integer_arithmetic.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/618e55810a9f86ccb2c762e4a087edb606264a1c/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Fsafe_integer_arithmetic.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/618e55810a9f86ccb2c762e4a087edb606264a1c/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Fsafe_integer_arithmetic.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Fsafe_integer_arithmetic.cc?ref=618e55810a9f86ccb2c762e4a087edb606264a1c",
            "patch": "@@ -20,11 +20,11 @@ limitations under the License.\n #include \"mlir/Dialect/Arith/IR/Arith.h\"\n #include \"mlir/Dialect/Func/IR/FuncOps.h\"\n #include \"mlir/Dialect/LLVMIR/LLVMDialect.h\"  // IWYU pragma: keep\n-#include \"mlir/Dialect/Vector/IR/VectorOps.h\"\n #include \"mlir/IR/AffineExpr.h\"\n #include \"mlir/IR/Builders.h\"\n #include \"mlir/IR/BuiltinAttributeInterfaces.h\"\n #include \"mlir/IR/BuiltinAttributes.h\"\n+#include \"mlir/IR/BuiltinTypeInterfaces.h\"\n #include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/IR/PatternMatch.h\"\n #include \"mlir/IR/TypeUtilities.h\"\n@@ -44,8 +44,8 @@ namespace {\n \n inline mlir::Value GetConstantOrSplat(mlir::ImplicitLocOpBuilder& builder,\n                                       mlir::Type type, mlir::TypedAttr value) {\n-  if (auto vector_type = mlir::dyn_cast<mlir::VectorType>(type)) {\n-    value = mlir::SplatElementsAttr::get(vector_type, value);\n+  if (auto shaped_type = mlir::dyn_cast<mlir::ShapedType>(type)) {\n+    value = mlir::SplatElementsAttr::get(shaped_type, value);\n   }\n   return mlir::arith::ConstantOp::create(builder, type, value);\n }"
        },
        {
            "sha": "55db4913d46ac027b84481aad56c9e2f9c49bd20",
            "filename": "third_party/xla/xla/codegen/emitters/transforms/tests/safe_integer_arithmetic.mlir",
            "status": "modified",
            "additions": 73,
            "deletions": 1,
            "changes": 74,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/618e55810a9f86ccb2c762e4a087edb606264a1c/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Ftests%2Fsafe_integer_arithmetic.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/618e55810a9f86ccb2c762e4a087edb606264a1c/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Ftests%2Fsafe_integer_arithmetic.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Ftransforms%2Ftests%2Fsafe_integer_arithmetic.mlir?ref=618e55810a9f86ccb2c762e4a087edb606264a1c",
            "patch": "@@ -79,6 +79,28 @@ func.func @signed_div_vector(%arg0: vector<8xi32>, %arg1: vector<8xi32>) -> vect\n \n // -----\n \n+func.func @signed_div_tensor(%arg0: tensor<8xi32>, %arg1: tensor<8xi32>) -> tensor<8xi32> {\n+  // CHECK-DAG: %[[C_1:.*]] = arith.constant dense<-1> : tensor<8xi32>\n+  // CHECK-DAG: %[[CMIN:.*]] = arith.constant dense<-2147483648> : tensor<8xi32>\n+  // CHECK-DAG: %[[C0:.*]] = arith.constant dense<0> : tensor<8xi32>\n+  // CHECK-DAG: %[[C1:.*]] = arith.constant dense<1> : tensor<8xi32>\n+  // CHECK:     %[[RHS_ZERO:.*]] = arith.cmpi eq, %arg1, %[[C0]] : tensor<8xi32>\n+  // CHECK:     %[[LHS_MIN:.*]] = arith.cmpi eq, %arg0, %[[CMIN]] : tensor<8xi32>\n+  // CHECK:     %[[RHS_MINUS1:.*]] = arith.cmpi eq, %arg1, %[[C_1]] : tensor<8xi32>\n+  // CHECK:     %[[OVERFLOW:.*]] = arith.andi %[[LHS_MIN]], %[[RHS_MINUS1]] : tensor<8xi1>\n+  // CHECK:     %[[IS_UB:.*]] = arith.ori %[[RHS_ZERO]], %[[OVERFLOW]] : tensor<8xi1>\n+  // CHECK:     %[[BOUNDED_RHS:.*]] = arith.select %[[IS_UB]], %[[C1]], %arg1 : tensor<8xi1>, tensor<8xi32>\n+  // CHECK:     %[[DIV:.*]] = arith.divsi %arg0, %[[BOUNDED_RHS]] : tensor<8xi32>\n+  // CHECK:     %[[OVERFLOW_RESULT:.*]] = arith.select %[[OVERFLOW]], %[[CMIN]], %[[DIV]] : tensor<8xi1>, tensor<8xi32>\n+  // CHECK:     %[[RESULT:.*]] = arith.select %[[RHS_ZERO]], %[[C_1]], %[[OVERFLOW_RESULT]] : tensor<8xi1>, tensor<8xi32>\n+  %0 = arith.divsi %arg0, %arg1 {xla.guard_ub} : tensor<8xi32>\n+  // CHECK: return %[[RESULT]] : tensor<8xi32>\n+  func.return %0 : tensor<8xi32>\n+}\n+\n+// -----\n+\n+\n func.func @unsigned_div(%arg0: i32, %arg1: i32) -> i32 {\n   // CHECK-DAG: %[[C_1:.*]] = arith.constant -1 : i32\n   // CHECK-DAG: %[[C0:.*]] = arith.constant 0 : i32\n@@ -109,6 +131,21 @@ func.func @unsigned_div_vector(%arg0: vector<4xi32>, %arg1: vector<4xi32>) -> ve\n \n // -----\n \n+func.func @unsigned_div_tensor(%arg0: tensor<4xi32>, %arg1: tensor<4xi32>) -> tensor<4xi32> {\n+  // CHECK-DAG: %[[C_1:.*]] = arith.constant dense<-1> : tensor<4xi32>\n+  // CHECK-DAG: %[[C0:.*]] = arith.constant dense<0> : tensor<4xi32>\n+  // CHECK-DAG: %[[C1:.*]] = arith.constant dense<1> : tensor<4xi32>\n+  // CHECK: %[[RHS_ZERO:.*]] = arith.cmpi eq, %arg1, %[[C0]] : tensor<4xi32>\n+  // CHECK: %[[BOUNDED_RHS:.*]] = arith.select %[[RHS_ZERO]], %[[C1]], %arg1 :  tensor<4xi1>, tensor<4xi32>\n+  // CHECK: %[[DIV:.*]] = arith.divui %arg0, %[[BOUNDED_RHS]] : tensor<4xi32>\n+  // CHECK: %[[RESULT:.*]] = arith.select %[[RHS_ZERO]], %[[C_1]], %[[DIV]] :  tensor<4xi1>, tensor<4xi32>\n+  %0 = arith.divui %arg0, %arg1 {xla.guard_ub} : tensor<4xi32>\n+  // CHECK: return %[[RESULT]] : tensor<4xi32>\n+  func.return %0 : tensor<4xi32>\n+}\n+\n+// -----\n+\n func.func @signed_rem(%arg0: i32, %arg1: i32) -> i32 {\n   // CHECK-DAG: %[[C_1:.*]] = arith.constant -1 : i32\n   // CHECK-DAG: %[[CMIN:.*]] = arith.constant -2147483648 : i32\n@@ -151,6 +188,27 @@ func.func @signed_rem_vector(%arg0: vector<2xi32>, %arg1: vector<2xi32>) -> vect\n \n // -----\n \n+func.func @signed_rem_tensor(%arg0: tensor<2xi32>, %arg1: tensor<2xi32>) -> tensor<2xi32> {\n+  // CHECK-DAG: %[[C_1:.*]] = arith.constant dense<-1> : tensor<2xi32>\n+  // CHECK-DAG: %[[CMIN:.*]] = arith.constant dense<-2147483648> : tensor<2xi32>\n+  // CHECK-DAG: %[[C0:.*]] = arith.constant dense<0> : tensor<2xi32>\n+  // CHECK-DAG: %[[C1:.*]] = arith.constant dense<1> : tensor<2xi32>\n+  // CHECK:     %[[RHS_ZERO:.*]] = arith.cmpi eq, %arg1, %[[C0]] : tensor<2xi32>\n+  // CHECK:     %[[LHS_MIN:.*]] = arith.cmpi eq, %arg0, %[[CMIN]] : tensor<2xi32>\n+  // CHECK:     %[[RHS_MINUS1:.*]] = arith.cmpi eq, %arg1, %[[C_1]] : tensor<2xi32>\n+  // CHECK:     %[[OVERFLOW:.*]] = arith.andi %[[LHS_MIN]], %[[RHS_MINUS1]] : tensor<2xi1>\n+  // CHECK:     %[[IS_UB:.*]] = arith.ori %[[RHS_ZERO]], %[[OVERFLOW]] : tensor<2xi1>\n+  // CHECK:     %[[BOUNDED_RHS:.*]] = arith.select %[[IS_UB]], %[[C1]], %arg1 : tensor<2xi1>, tensor<2xi32>\n+  // CHECK:     %[[REM:.*]] = arith.remsi %arg0, %[[BOUNDED_RHS]] : tensor<2xi32>\n+  // CHECK:     %[[OVERFLOW_RESULT:.*]] = arith.select %[[OVERFLOW]], %[[C0]], %[[REM]] : tensor<2xi1>, tensor<2xi32>\n+  // CHECK:     %[[RESULT:.*]] = arith.select %[[RHS_ZERO]], %arg0, %[[OVERFLOW_RESULT]] : tensor<2xi1>, tensor<2xi32>\n+  %0 = arith.remsi %arg0, %arg1 {xla.guard_ub} : tensor<2xi32>\n+  // CHECK: return %[[RESULT]] : tensor<2xi32>\n+  func.return %0 : tensor<2xi32>\n+}\n+\n+// -----\n+\n func.func @unsigned_rem(%arg0: i32, %arg1: i32) -> i32 {\n   // CHECK-DAG: %[[C0:.*]] = arith.constant 0 : i32\n   // CHECK-DAG: %[[C1:.*]] = arith.constant 1 : i32\n@@ -165,7 +223,7 @@ func.func @unsigned_rem(%arg0: i32, %arg1: i32) -> i32 {\n \n // -----\n \n-func.func @unsigned_rem_vectors(%arg0: vector<16xi32>, %arg1: vector<16xi32>) -> vector<16xi32> {\n+func.func @unsigned_rem_vector(%arg0: vector<16xi32>, %arg1: vector<16xi32>) -> vector<16xi32> {\n   // CHECK-DAG: %[[C0:.*]] = arith.constant dense<0> : vector<16xi32>\n   // CHECK-DAG: %[[C1:.*]] = arith.constant dense<1> : vector<16xi32>\n   // CHECK: %[[RHS_ZERO:.*]] = arith.cmpi eq, %arg1, %[[C0]] : vector<16xi32>\n@@ -176,3 +234,17 @@ func.func @unsigned_rem_vectors(%arg0: vector<16xi32>, %arg1: vector<16xi32>) ->\n   // CHECK: return %[[RESULT]] : vector<16xi32>\n   func.return %0 : vector<16xi32>\n }\n+\n+// -----\n+\n+func.func @unsigned_rem_tensor(%arg0: tensor<16xi32>, %arg1: tensor<16xi32>) -> tensor<16xi32> {\n+  // CHECK-DAG: %[[C0:.*]] = arith.constant dense<0> : tensor<16xi32>\n+  // CHECK-DAG: %[[C1:.*]] = arith.constant dense<1> : tensor<16xi32>\n+  // CHECK: %[[RHS_ZERO:.*]] = arith.cmpi eq, %arg1, %[[C0]] : tensor<16xi32>\n+  // CHECK: %[[BOUNDED_RHS:.*]] = arith.select %[[RHS_ZERO]], %[[C1]], %arg1 : tensor<16xi1>, tensor<16xi32>\n+  // CHECK: %[[REM:.*]] = arith.remui %arg0, %[[BOUNDED_RHS]] : tensor<16xi32>\n+  // CHECK: %[[RESULT:.*]] = arith.select %[[RHS_ZERO]], %arg0, %[[REM]] : tensor<16xi1>, tensor<16xi32>\n+  %0 = arith.remui %arg0, %arg1 {xla.guard_ub} : tensor<16xi32>\n+  // CHECK: return %[[RESULT]] : tensor<16xi32>\n+  func.return %0 : tensor<16xi32>\n+}"
        },
        {
            "sha": "a39b2639705942744141f1a49f1d9f9f02e85d06",
            "filename": "third_party/xla/xla/mlir_hlo/mhlo/transforms/map_mhlo_to_scalar_op.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/618e55810a9f86ccb2c762e4a087edb606264a1c/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fmap_mhlo_to_scalar_op.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/618e55810a9f86ccb2c762e4a087edb606264a1c/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fmap_mhlo_to_scalar_op.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fmap_mhlo_to_scalar_op.h?ref=618e55810a9f86ccb2c762e4a087edb606264a1c",
            "patch": "@@ -349,8 +349,8 @@ inline Value mapMhloOpToStdScalarOp<mhlo::AbsOp>(\n // Return a constant for v of type t, splat if t is a vector type.\n inline Value getConstantOrSplat(OpBuilder* b, Location loc, Type t,\n                                 Attribute v) {\n-  if (VectorType vecType = mlir::dyn_cast<VectorType>(t)) {\n-    v = SplatElementsAttr::get(vecType, v);\n+  if (ShapedType shapedType = mlir::dyn_cast<ShapedType>(t)) {\n+    v = SplatElementsAttr::get(shapedType, v);\n   }\n   return b->create<arith::ConstantOp>(loc, t, cast<TypedAttr>(v));\n }"
        }
    ],
    "stats": {
        "total": 84,
        "additions": 78,
        "deletions": 6
    }
}