{
    "author": "bhatuzdaname",
    "message": "Allow HloDCE to remove dead parameters from the entry computation.\n\nThis change introduces a new option `remove_dead_parameters_from_entry_computation` to `HloDCE`. When this option is enabled, HloDCE can remove parameters from the entry computation if they are dead. This is generally not allowed as it breaks the contract with the frontend but is useful for tests.\n\nPiperOrigin-RevId: 836368286",
    "sha": "077856b5935a526f34d9a954b98ac6316bd26216",
    "files": [
        {
            "sha": "f5c32d2377c298d97b5947b0bdb78470d553ddfe",
            "filename": "third_party/xla/xla/hlo/ir/hlo_computation.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 10,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_computation.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_computation.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_computation.cc?ref=077856b5935a526f34d9a954b98ac6316bd26216",
            "patch": "@@ -600,7 +600,8 @@ bool HloComputation::IsSafelyRemovable(\n     const HloInstruction* instruction, bool ignore_control_dependency,\n     std::optional<\n         absl::FunctionRef<std::vector<HloInstruction*>(const HloComputation*)>>\n-        computation_callers) const {\n+        computation_callers,\n+    bool remove_dead_param_from_entry) const {\n   // If the instruction has control predecessors or successors then we cannot\n   // remove the instruction without violating ordering constraints (added, for\n   // example, to avert interference due to buffer aliasing).\n@@ -613,8 +614,11 @@ bool HloComputation::IsSafelyRemovable(\n     if (instruction->parent() == nullptr) {\n       return true;\n     }\n-    // Entry computation parameters can never be removed.\n-    if (instruction->parent()->IsEntryComputation()) {\n+    // Entry computation parameters can never be removed unless explicitly\n+    // specified. Then user needs to update the entry computation layout\n+    // accordingly.\n+    if (instruction->parent()->IsEntryComputation() &&\n+        !remove_dead_param_from_entry) {\n       return false;\n     }\n     // We generally want to be using the call graph to determine who the caller\n@@ -629,11 +633,10 @@ bool HloComputation::IsSafelyRemovable(\n     }\n     std::vector<HloInstruction*> callers =\n         (*computation_callers)(instruction->parent());\n-    if (callers.empty()) {\n+    if (callers.empty() && !instruction->parent()->IsEntryComputation()) {\n       return false;\n     }\n-    for (HloInstruction* caller :\n-         (*computation_callers)(instruction->parent())) {\n+    for (HloInstruction* caller : callers) {\n       if (caller->opcode() != HloOpcode::kFusion &&\n           caller->opcode() != HloOpcode::kCall &&\n           caller->opcode() != HloOpcode::kAsyncStart) {\n@@ -666,12 +669,14 @@ absl::Status HloComputation::RemoveInstructionAndUnusedOperands(\n     bool ignore_control_dependencies,\n     std::optional<\n         absl::FunctionRef<std::vector<HloInstruction*>(const HloComputation*)>>\n-        computation_callers) {\n+        computation_callers,\n+    bool remove_dead_parameters_from_entry_computation) {\n   TF_RET_CHECK(root_instruction() != instruction);\n \n   TF_RET_CHECK(instruction->IsDead());\n   TF_RET_CHECK(IsSafelyRemovable(instruction, ignore_control_dependencies,\n-                                 computation_callers))\n+                                 computation_callers,\n+                                 remove_dead_parameters_from_entry_computation))\n       << \"Cannot remove instruction: \" << instruction->ToString();\n   // Remember the parent, in case we lose all references to it, in order to\n   // clean up the callers.\n@@ -686,7 +691,8 @@ absl::Status HloComputation::RemoveInstructionAndUnusedOperands(\n \n     if (removed.contains(item) || !item->IsDead() ||\n         !IsSafelyRemovable(item, ignore_control_dependencies,\n-                           computation_callers) ||\n+                           computation_callers,\n+                           remove_dead_parameters_from_entry_computation) ||\n         (item->HasSideEffect() && item != instruction)) {\n       continue;\n     }\n@@ -731,8 +737,11 @@ absl::Status HloComputation::RemoveInstructionAndUnusedOperands(\n       callers = {FusionInstruction()};\n     }\n   }\n+  const bool is_entry_computation = parent != nullptr &&\n+                                    parent->parent() != nullptr &&\n+                                    parent->IsEntryComputation();\n   // Only attempt to remove parameters if we can fixup the caller.\n-  if (callers.empty()) {\n+  if (callers.empty() && !is_entry_computation) {\n     return absl::OkStatus();\n   }\n   for (HloInstruction* param : parameters_to_be_removed) {"
        },
        {
            "sha": "f13f1a8a937aa03223eb64ebe404f8caf16852f1",
            "filename": "third_party/xla/xla/hlo/ir/hlo_computation.h",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_computation.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_computation.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_computation.h?ref=077856b5935a526f34d9a954b98ac6316bd26216",
            "patch": "@@ -326,14 +326,21 @@ class HloComputation {\n   // the control dependencies from the predecessors to the successors of the\n   // removed instructions, so that the logical exeuction order of the remaining\n   // unremoved instructions are preserved.\n+  //\n+  // Parameters from the entry computation can never be removed.\n+  // If caller allows this with `remove_dead_parameters_from_entry_computation`\n+  // then they need to update the entry computation layout of the module too.\n+  // Note: This breaks the contract with the frontend. Use only in tests.\n+  //\n   absl::Status RemoveInstructionAndUnusedOperands(\n       HloInstruction* instruction,\n       std::optional<absl::FunctionRef<void(HloInstruction*)>> cleanup =\n           std::nullopt,\n       bool ignore_control_dependencies = false,\n       std::optional<absl::FunctionRef<\n           std::vector<HloInstruction*>(const HloComputation*)>>\n-          computation_callers = std::nullopt);\n+          computation_callers = std::nullopt,\n+      bool remove_dead_parameters_from_entry_computation = false);\n \n   // Set the root of the computation to the given instruction. The instruction\n   // must have already been added to the computation. In addition it must have\n@@ -798,6 +805,11 @@ class HloComputation {\n   // via computation_callers. This is expected to be equivalent to\n   // CallGraph::GetComputationCallers().\n   //\n+  // Parameters from the entry computation can never be removed.\n+  // If caller allows this with `remove_dead_parameters_from_entry_computation`\n+  // then they need to update the entry computation layout of the module too.\n+  // Note: This breaks the contract with the frontend. Use only in tests.\n+  //\n   // Note that IsSafelyRemovable() is a necessary condition to remove an\n   // instruction rather than a sufficient condition. For example, instructions\n   // with side-effect (e.g., Send, Infeed) may be removed from a computation,\n@@ -808,7 +820,8 @@ class HloComputation {\n       const HloInstruction* instruction, bool ignore_control_dependency = false,\n       std::optional<absl::FunctionRef<\n           std::vector<HloInstruction*>(const HloComputation*)>>\n-          computation_callers = std::nullopt) const;\n+          computation_callers = std::nullopt,\n+      bool remove_dead_parameters_from_entry_computation = false) const;\n \n   // Returns a map from an instruction to the group of instructions associated\n   // with the same channel. These instructions will be considered as a single"
        },
        {
            "sha": "b048077a799aa88d84c769b34a0ec64735c9d5d0",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD?ref=077856b5935a526f34d9a954b98ac6316bd26216",
            "patch": "@@ -842,11 +842,13 @@ cc_library(\n     hdrs = [\"hlo_dce.h\"],\n     visibility = internal_visibility([\":friends\"]),\n     deps = [\n+        \"//xla:shape_layout\",\n         \"//xla:shape_util\",\n         \"//xla:util\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/pass:hlo_pass\",\n         \"//xla/service:call_graph\",\n+        \"//xla/service:computation_layout\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\",\n@@ -866,14 +868,12 @@ xla_cc_test(\n         \":hlo_dce\",\n         \"//xla:literal_util\",\n         \"//xla:shape_util\",\n-        \"//xla:types\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/testlib:hlo_hardware_independent_test_base\",\n         \"//xla/hlo/testlib:pattern_matcher_gmock\",\n         \"//xla/hlo/testlib:verified_hlo_module\",\n         \"//xla/service:pattern_matcher\",\n-        \"//xla/tests:literal_test_util\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\","
        },
        {
            "sha": "7493654247e567a6bd1bfabcc243eed0c426b74a",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/hlo_dce.cc",
            "status": "modified",
            "additions": 56,
            "deletions": 10,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fhlo_dce.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fhlo_dce.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fhlo_dce.cc?ref=077856b5935a526f34d9a954b98ac6316bd26216",
            "patch": "@@ -41,7 +41,9 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n #include \"xla/service/call_graph.h\"\n+#include \"xla/service/computation_layout.h\"\n #include \"xla/shape.h\"\n+#include \"xla/shape_layout.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -249,31 +251,66 @@ absl::StatusOr<bool> RemoveDeadRoots(\n   }\n   return changed;\n }\n+absl::Status RemoveDeadParametersFromEntryComputationLayout(\n+    HloModule* module, std::vector<int64_t>& dead_parameter_indexes) {\n+  if (dead_parameter_indexes.empty()) {\n+    return absl::OkStatus();\n+  }\n+  const ComputationLayout& old_layout = module->entry_computation_layout();\n+  ShapeLayout result_layout = old_layout.result_layout();\n+  ComputationLayout new_layout(result_layout);\n+  for (int i = 0; i < old_layout.parameter_count(); ++i) {\n+    if (absl::c_linear_search(dead_parameter_indexes, i)) {\n+      continue;\n+    }\n+    new_layout.add_parameter_layout(old_layout.parameter_layout(i));\n+  }\n+  *module->mutable_entry_computation_layout() = std::move(new_layout);\n+  return absl::OkStatus();\n+}\n \n absl::StatusOr<bool> RemoveDeadParameters(\n     HloComputation* computation,\n     const std::function<std::vector<HloInstruction*>(const HloComputation*)>&\n-        computation_callers) {\n+        computation_callers,\n+    bool remove_dead_parameters_from_entry_computation) {\n   bool changed = false;\n+  bool update_entry_computation_layout =\n+      computation->IsEntryComputation() &&\n+      remove_dead_parameters_from_entry_computation;\n   auto parameters = computation->parameter_instructions();\n   // Sort into decreasing order by parameter number, otherwise the renumbering\n   // of parameters when one parameter is deleted will cause issues.\n   absl::c_reverse(parameters);\n+  std::vector<int64_t> dead_parameters;\n   for (HloInstruction* parameter : parameters) {\n     if (parameter->IsDead() &&\n         computation->IsSafelyRemovable(\n             parameter,\n             /*ignore_control_dependency=*/false,\n-            /*computation_callers=*/computation_callers)) {\n+            /*computation_callers=*/computation_callers,\n+            remove_dead_parameters_from_entry_computation)) {\n       VLOG(1) << \"Removing dead parameter \" << parameter->ToString()\n               << \" and its unused operands\";\n+      int64_t num_parameters = computation->num_parameters();\n+      int64_t parameter_number = parameter->parameter_number();\n       TF_RETURN_IF_ERROR(computation->RemoveInstructionAndUnusedOperands(\n           parameter, /*cleanup=*/std::nullopt,\n           /*ignore_control_dependencies=*/false,\n-          /*computation_callers=*/computation_callers));\n-      changed = true;\n+          /*computation_callers=*/computation_callers,\n+          remove_dead_parameters_from_entry_computation));\n+      if (computation->num_parameters() < num_parameters) {\n+        changed = true;\n+        if (update_entry_computation_layout) {\n+          dead_parameters.push_back(parameter_number);\n+        }\n+      }\n     }\n   }\n+  if (update_entry_computation_layout) {\n+    TF_RETURN_IF_ERROR(RemoveDeadParametersFromEntryComputationLayout(\n+        computation->parent(), dead_parameters));\n+  }\n   return changed;\n }\n \n@@ -297,7 +334,8 @@ absl::StatusOr<bool> ProcessAgenda(\n     HloModule* module, std::stack<HloComputation*>& agenda,\n     absl::flat_hash_set<HloComputation*>& to_remove,\n     const absl::flat_hash_set<absl::string_view>& execution_threads,\n-    bool remove_cross_partition_collective_ops, CallGraph* call_graph) {\n+    bool remove_cross_partition_collective_ops, CallGraph* call_graph,\n+    bool remove_dead_parameters_from_entry_computation) {\n   bool changed = false;\n   while (!agenda.empty()) {\n     HloComputation* computation = agenda.top();\n@@ -308,7 +346,8 @@ absl::StatusOr<bool> ProcessAgenda(\n       TF_ASSIGN_OR_RETURN(\n           bool computation_changed,\n           xla::HloDCE::RunOnComputation(\n-              computation, remove_cross_partition_collective_ops, call_graph));\n+              computation, remove_cross_partition_collective_ops, call_graph,\n+              remove_dead_parameters_from_entry_computation));\n       changed |= computation_changed;\n     }\n \n@@ -361,7 +400,7 @@ absl::StatusOr<bool> RemoveDanglingComputations(\n \n /*static*/ absl::StatusOr<bool> HloDCE::RunOnComputation(\n     HloComputation* computation, bool remove_cross_partition_collective_ops,\n-    CallGraph* call_graph) {\n+    CallGraph* call_graph, bool remove_dead_parameters_from_entry_computation) {\n   auto computation_callers =\n       [call_graph](\n           const HloComputation* computation) -> std::vector<HloInstruction*> {\n@@ -382,8 +421,10 @@ absl::StatusOr<bool> RemoveDanglingComputations(\n                       computation_callers));\n   changed |= dead_roots_changed;\n \n-  TF_ASSIGN_OR_RETURN(bool dead_parameters_changed,\n-                      RemoveDeadParameters(computation, computation_callers));\n+  TF_ASSIGN_OR_RETURN(\n+      bool dead_parameters_changed,\n+      RemoveDeadParameters(computation, computation_callers,\n+                           remove_dead_parameters_from_entry_computation));\n   changed |= dead_parameters_changed;\n \n   return changed;\n@@ -409,7 +450,8 @@ absl::StatusOr<bool> HloDCE::RunImpl(\n   TF_ASSIGN_OR_RETURN(\n       bool agenda_changed,\n       ProcessAgenda(module, agenda, to_remove, execution_threads,\n-                    remove_cross_partition_collective_ops_, call_graph.get()));\n+                    remove_cross_partition_collective_ops_, call_graph.get(),\n+                    remove_dead_parameters_from_entry_computation_));\n   changed |= agenda_changed;\n \n   TF_ASSIGN_OR_RETURN(\n@@ -419,6 +461,10 @@ absl::StatusOr<bool> HloDCE::RunImpl(\n   changed |= dangling_computations_removed;\n \n   if (changed) {\n+    // Update the schedule to reflect the removed instructions.\n+    if (module->has_schedule()) {\n+      TF_RETURN_IF_ERROR(module->schedule().Update(execution_threads));\n+    }\n     VLOG(2) << \"After dce:\";\n     XLA_VLOG_LINES(2, module->ToString());\n   }"
        },
        {
            "sha": "a96b1c8b707bf453abf57e0141f1df9dfaff9a44",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/hlo_dce.h",
            "status": "modified",
            "additions": 14,
            "deletions": 3,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fhlo_dce.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fhlo_dce.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fhlo_dce.h?ref=077856b5935a526f34d9a954b98ac6316bd26216",
            "patch": "@@ -39,19 +39,29 @@ namespace xla {\n // to do so if the graph is not inlined.\n class HloDCE : public HloModulePass {\n  public:\n+  // If `remove_dead_parameters_from_entry_computation` is true, then this pass\n+  // will remove dead parameters from the entry computation and update the entry\n+  // computation layout of the module.\n   explicit HloDCE(bool remove_cross_partition_collective_ops = false,\n-                  bool use_call_analysis = false)\n+                  bool use_call_analysis = false,\n+                  bool remove_dead_parameters_from_entry_computation = false)\n       : remove_cross_partition_collective_ops_(\n             remove_cross_partition_collective_ops),\n-        use_call_analysis_(use_call_analysis) {}\n+        use_call_analysis_(use_call_analysis),\n+        remove_dead_parameters_from_entry_computation_(\n+            remove_dead_parameters_from_entry_computation) {}\n   ~HloDCE() override {}\n   absl::string_view name() const override { return \"dce\"; }\n \n   // Run DCE on a computation.\n+  // If `remove_dead_parameters_from_entry_computation` is true, then remove\n+  // dead parameters from the entry computation and update the entry computation\n+  // layout of the module.\n   static absl::StatusOr<bool> RunOnComputation(\n       HloComputation* computation,\n       bool remove_cross_partition_collective_ops = false,\n-      CallGraph* call_graph = nullptr);\n+      CallGraph* call_graph = nullptr,\n+      bool remove_dead_parameters_from_entry_computation = false);\n \n  protected:\n   // Run the pass on the given module. Returns whether the module was changed\n@@ -63,6 +73,7 @@ class HloDCE : public HloModulePass {\n  private:\n   bool remove_cross_partition_collective_ops_;\n   bool use_call_analysis_;\n+  bool remove_dead_parameters_from_entry_computation_;\n };\n \n }  // namespace xla"
        },
        {
            "sha": "36aae957c5df703a09c5c6ad4d89cbcadaf676a9",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/hlo_dce_test.cc",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fhlo_dce_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/077856b5935a526f34d9a954b98ac6316bd26216/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fhlo_dce_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fhlo_dce_test.cc?ref=077856b5935a526f34d9a954b98ac6316bd26216",
            "patch": "@@ -979,5 +979,41 @@ dangling_computation {\n   EXPECT_EQ(module->GetComputationWithName(\"dangling_computation\"), nullptr);\n }\n \n+TEST_F(HloDceTest, RemoveDeadEntryParametersAndLayout) {\n+  constexpr absl::string_view kHlo = R\"(\n+HloModule test_module, entry_computation_layout={(f32[2,3]{1,0}, f32[4,5]{1,0}, f32[2,3]{1,0})->f32[2,3]{1,0}}\n+\n+ENTRY entry_computation {\n+  p0 = f32[2,3]{1,0} parameter(0)\n+  p1 = f32[4,5]{1,0} parameter(1) // dead parameter\n+  p2 = f32[2,3]{1,0} parameter(2)\n+  ROOT add = f32[2,3]{1,0} add(p0, p2)\n+})\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n+                          ParseAndReturnVerifiedModule(kHlo));\n+  HloComputation* computation = module->entry_computation();\n+\n+  EXPECT_EQ(computation->num_parameters(), 3);\n+  EXPECT_EQ(computation->instruction_count(), 4);\n+  EXPECT_EQ(module->entry_computation_layout().parameter_count(), 3);\n+\n+  HloDCE dce(/*remove_cross_partition_collective_ops=*/false,\n+             /*use_call_analysis=*/false,\n+             /*remove_dead_parameters_from_entry_computation=*/true);\n+  EXPECT_TRUE(dce.Run(module.get()).value());\n+\n+  EXPECT_EQ(computation->num_parameters(), 2);\n+  const Shape p0_p2_shape = ShapeUtil::MakeShape(F32, {2, 3});\n+  EXPECT_TRUE(computation->parameter_instruction(0)->shape() == p0_p2_shape);\n+  EXPECT_TRUE(computation->parameter_instruction(1)->shape() == p0_p2_shape);\n+\n+  EXPECT_EQ(module->entry_computation_layout().parameter_count(), 2);\n+  EXPECT_TRUE(module->entry_computation_layout().parameter_layout(0) ==\n+              ShapeLayout(p0_p2_shape));\n+  EXPECT_TRUE(module->entry_computation_layout().parameter_layout(1) ==\n+              ShapeLayout(p0_p2_shape));\n+}\n+\n }  // namespace\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 169,
        "additions": 142,
        "deletions": 27
    }
}