{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Move AsyncValue::Executor to tsl::Executor\n\nPiperOrigin-RevId: 813750337",
    "sha": "597068cc9a02135e2421fb69126dfacb39815511",
    "files": [
        {
            "sha": "ef05bbeab5f31d41cd91813210df0a15e9a1f4b0",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 8,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2FBUILD?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -117,14 +117,6 @@ cc_library(\n     ],\n )\n \n-cc_library(\n-    name = \"threadpool_async_executor\",\n-    hdrs = [\"threadpool_async_executor.h\"],\n-    deps = [\n-        \"@local_xla//xla/tsl/platform:threadpool_async_executor\",\n-    ],\n-)\n-\n cc_library(\n     name = \"env_impl\",\n     deps = ["
        },
        {
            "sha": "deadc9511168566b2431192a18b33076f46e1c6a",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/threadpool_async_executor.h",
            "status": "removed",
            "additions": 0,
            "deletions": 21,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/42b6f35ee29c22a215f6ff1265c0a0d117ce0af5/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fthreadpool_async_executor.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/42b6f35ee29c22a215f6ff1265c0a0d117ce0af5/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fthreadpool_async_executor.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fthreadpool_async_executor.h?ref=42b6f35ee29c22a215f6ff1265c0a0d117ce0af5",
            "patch": "@@ -1,21 +0,0 @@\n-/* Copyright 2024 The TensorFlow Authors. All Rights Reserved.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#ifndef TENSORFLOW_TSL_PLATFORM_THREADPOOL_ASYNC_EXECUTOR_H_\n-#define TENSORFLOW_TSL_PLATFORM_THREADPOOL_ASYNC_EXECUTOR_H_\n-\n-#include \"xla/tsl/platform/threadpool_async_executor.h\"\n-\n-#endif  // TENSORFLOW_TSL_PLATFORM_THREADPOOL_ASYNC_EXECUTOR_H_"
        },
        {
            "sha": "43cddeb8487c881a74c6e612ed6ee48fac7cc044",
            "filename": "third_party/xla/xla/backends/gpu/collectives/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2FBUILD?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -377,6 +377,7 @@ cc_library(\n         \"//xla/stream_executor:stream_executor_h\",\n         \"//xla/stream_executor/gpu:gpu_stream\",\n         \"//xla/tsl/concurrency:async_value\",\n+        \"//xla/tsl/concurrency:executor\",\n         \"//xla/tsl/platform:env\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:logging\",\n@@ -547,9 +548,9 @@ cc_library(\n     srcs = [\"single_threaded_executor.cc\"],\n     hdrs = [\"single_threaded_executor.h\"],\n     deps = [\n-        \"//xla/tsl/concurrency:async_value\",\n+        \"//xla/tsl/concurrency:executor\",\n         \"//xla/tsl/platform:env\",\n-        \"//xla/tsl/platform:threadpool_async_executor\",\n+        \"//xla/tsl/platform:threadpool_executor\",\n     ],\n )\n "
        },
        {
            "sha": "3f9f1af4a906caec63a972ede0d0ccddef441a94",
            "filename": "third_party/xla/xla/backends/gpu/collectives/nccl_communicator.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fnccl_communicator.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fnccl_communicator.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fnccl_communicator.cc?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -48,6 +48,7 @@ limitations under the License.\n #include \"xla/stream_executor/stream_executor.h\"\n #include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n+#include \"xla/tsl/concurrency/executor.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/logging.h\"\n@@ -182,8 +183,8 @@ class NcclCommunicator::NcclRegisteredBufferHandle\n     : public Communicator::RegisteredBufferHandle {\n  public:\n   NcclRegisteredBufferHandle(NcclCommunicator& comm, void* handle,\n-                             tsl::AsyncValue::Executor* executor,\n-                             bool symmetric_handle, int device_ordinal)\n+                             tsl::Executor* executor, bool symmetric_handle,\n+                             int device_ordinal)\n       : comm_(comm),\n         handle_(handle),\n         executor_(),\n@@ -249,7 +250,7 @@ class NcclCommunicator::NcclRegisteredBufferHandle\n  private:\n   NcclCommunicator& comm_;\n   void* handle_;\n-  tsl::AsyncValue::Executor* executor_;\n+  tsl::Executor* executor_;\n   bool symmetric_handle_;\n   int device_ordinal_;\n };"
        },
        {
            "sha": "27871ca8c7f3c7af883252e11692a8834925cf6f",
            "filename": "third_party/xla/xla/backends/gpu/collectives/nccl_communicator.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fnccl_communicator.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fnccl_communicator.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fnccl_communicator.h?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -38,8 +38,8 @@ limitations under the License.\n #include \"xla/core/collectives/rank_id.h\"\n #include \"xla/service/collective_ops_utils.h\"\n #include \"xla/stream_executor/device_memory.h\"\n-#include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n+#include \"xla/tsl/concurrency/executor.h\"\n #include \"xla/tsl/platform/env.h\"\n \n #if TENSORFLOW_USE_ROCM\n@@ -146,7 +146,7 @@ class NcclCommunicator : public GpuCommunicator {\n   class NcclRegisteredBufferHandle;\n \n   explicit NcclCommunicator(ncclComm_t comm,\n-                            std::unique_ptr<tsl::AsyncValue::Executor> executor)\n+                            std::unique_ptr<tsl::Executor> executor)\n       : comm_(comm), executor_(std::move(executor)) {\n     VLOG(1) << \"Created \" << *this;\n   }\n@@ -226,7 +226,7 @@ class NcclCommunicator : public GpuCommunicator {\n   // ncclComm_t is accessed from multiple threads. Emperically, the lack of\n   // thread safety only manifests as buggy behavior when using non-blocking\n   // communicators.\n-  std::unique_ptr<tsl::AsyncValue::Executor> executor_;\n+  std::unique_ptr<tsl::Executor> executor_;\n \n   // Should all pending collectives cancel?\n   std::atomic_bool canceling_ = false;"
        },
        {
            "sha": "9fd408c9b0a938de0e94739beb0f08047de36d58",
            "filename": "third_party/xla/xla/backends/gpu/collectives/single_threaded_executor.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fsingle_threaded_executor.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fsingle_threaded_executor.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fsingle_threaded_executor.cc?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -19,7 +19,7 @@ limitations under the License.\n \n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n-#include \"xla/tsl/platform/threadpool_async_executor.h\"\n+#include \"xla/tsl/platform/threadpool_executor.h\"\n \n namespace xla::gpu {\n "
        },
        {
            "sha": "a498fed7f897f528f3888f6c773e7a4804eb8858",
            "filename": "third_party/xla/xla/backends/gpu/collectives/single_threaded_executor.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fsingle_threaded_executor.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fsingle_threaded_executor.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fgpu%2Fcollectives%2Fsingle_threaded_executor.h?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -16,25 +16,25 @@ limitations under the License.\n #ifndef XLA_BACKENDS_GPU_COLLECTIVES_SINGLE_THREADED_EXECUTOR_H_\n #define XLA_BACKENDS_GPU_COLLECTIVES_SINGLE_THREADED_EXECUTOR_H_\n \n-#include \"xla/tsl/concurrency/async_value.h\"\n+#include \"xla/tsl/concurrency/executor.h\"\n #include \"xla/tsl/platform/env.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n-#include \"xla/tsl/platform/threadpool_async_executor.h\"\n+#include \"xla/tsl/platform/threadpool_executor.h\"\n \n namespace xla::gpu {\n \n // An Executor that executes all tasks on a single thread.\n //\n // Tasks are executed concurrently to the thread that calls the Execute method,\n // but tasks are not executed concurrently to each other.\n-class SingleThreadedExecutor : public tsl::AsyncValue::Executor {\n+class SingleThreadedExecutor : public tsl::Executor {\n  public:\n   explicit SingleThreadedExecutor(tsl::Env& env = *tsl::Env::Default());\n   void Execute(Task task) override;\n \n  private:\n   tsl::thread::ThreadPool thread_pool_;\n-  tsl::thread::ThreadPoolAsyncExecutor executor_;\n+  tsl::thread::ThreadPoolExecutor executor_;\n };\n \n }  // namespace xla::gpu"
        },
        {
            "sha": "68b12b8196b8523c17df5c800a651aca4d5d7f0b",
            "filename": "third_party/xla/xla/service/cpu/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -405,7 +405,6 @@ cc_library(\n         \"@local_tsl//tsl/platform:platform_port\",\n         \"@local_tsl//tsl/platform:status\",\n         \"@local_tsl//tsl/platform:statusor\",\n-        \"@local_tsl//tsl/platform:threadpool_async_executor\",\n         \"@local_tsl//tsl/profiler/lib:traceme\",\n         \"@local_tsl//tsl/profiler/lib:traceme_encode\",\n     ] + if_llvm_aarch64_available(["
        },
        {
            "sha": "f899bbd68a7966dc071d9650078a082595b0c13b",
            "filename": "third_party/xla/xla/tsl/concurrency/BUILD",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2FBUILD?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -43,6 +43,7 @@ cc_library(\n     compatible_with = get_compatible_with_portable(),\n     deps = [\n         \":concurrent_vector\",\n+        \":executor\",\n         \":ref_count\",\n         \"//xla/tsl/platform:logging\",\n         \"//xla/tsl/util:safe_reinterpret_cast\",\n@@ -76,6 +77,7 @@ tsl_cc_test(\n     srcs = [\"async_value_ptr_test.cc\"],\n     deps = [\n         \":async_value\",\n+        \":executor\",\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/platform:test_benchmark\",\n         \"//xla/tsl/platform:test_main\",\n@@ -91,6 +93,7 @@ tsl_cc_test(\n     srcs = [\"async_value_ref_test.cc\"],\n     deps = [\n         \":async_value\",\n+        \":executor\",\n         \":ref_count\",\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/platform:test_benchmark\",\n@@ -126,6 +129,13 @@ tsl_cc_test(\n     ],\n )\n \n+cc_library(\n+    name = \"executor\",\n+    hdrs = [\"executor.h\"],\n+    compatible_with = get_compatible_with_portable(),\n+    deps = [\"@com_google_absl//absl/functional:any_invocable\"],\n+)\n+\n cc_library(\n     name = \"future\",\n     srcs = [\"future.cc\"],"
        },
        {
            "sha": "33a51581dd5585feea206bc402666c1cf6cfd4c4",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value.h",
            "status": "modified",
            "additions": 1,
            "deletions": 20,
            "changes": 21,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value.h?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -31,6 +31,7 @@ limitations under the License.\n #include \"absl/status/status.h\"\n #include \"absl/types/span.h\"\n #include \"xla/tsl/concurrency/concurrent_vector.h\"\n+#include \"xla/tsl/concurrency/executor.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/logging.h\"\n #include \"xla/tsl/util/safe_reinterpret_cast.h\"\n@@ -59,8 +60,6 @@ constexpr bool kMaybeBase = std::is_class<T>::value && !std::is_final<T>::value;\n // data and the payload data in consecutive memory locations.\n class AsyncValue {\n  public:\n-  class Executor;\n-\n   ~AsyncValue();\n \n   // Return true if state is kUnconstructed.\n@@ -255,24 +254,6 @@ class AsyncValue {\n     return waiters_and_state_.load(std::memory_order_acquire).state();\n   }\n \n-  // AsyncValue executor allows to customize where the waiter callback is\n-  // executed. By default the waiter callback is executed on the caller thread\n-  // if async value is already available, or on a thread that sets async value\n-  // available (emplacing a value or setting an error), which can accidentally\n-  // lead to executing a very expensive computations on a low-latency thread.\n-  //\n-  // IMPORTANT: It's the caller responsibility to ensure that executor passed to\n-  // all `AndThen` or `Map` function calls stay alive while async values have\n-  // unresolved waiters waiting to be invoked.\n-  class Executor {\n-   public:\n-    using Task = absl::AnyInvocable<void()>;\n-\n-    virtual ~Executor() = default;\n-\n-    virtual void Execute(Task task) = 0;\n-  };\n-\n  protected:\n   friend class IndirectAsyncValue;\n "
        },
        {
            "sha": "46fea420afcec116c84c850790dc3862117fed86",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value_ptr_test.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ptr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ptr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ptr_test.cc?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -25,6 +25,7 @@ limitations under the License.\n #include \"absl/types/span.h\"\n #include \"xla/tsl/concurrency/async_value.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n+#include \"xla/tsl/concurrency/executor.h\"\n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/platform/test_benchmark.h\"\n \n@@ -282,15 +283,15 @@ TEST(AsyncValuePtrTest, FlatMapUnavailable) {\n   EXPECT_EQ(fmapped_to_float.get(), 42.0f);\n }\n \n-struct DeferredExecutor : public AsyncValue::Executor {\n+struct DeferredExecutor : public Executor {\n   void Execute(Task task) final { tasks.push_back(std::move(task)); }\n \n   size_t Quiesce() {\n     size_t n = 0;\n     while (!tasks.empty()) {\n       Task task = std::move(tasks.back());\n       tasks.pop_back();\n-      task();\n+      std::move(task)();\n       ++n;\n     }\n     return n;\n@@ -621,8 +622,8 @@ TEST(AsyncValuePtrTest, Cast) {\n // Performance benchmarks below\n //===----------------------------------------------------------------------===//\n \n-struct InlineExecutor : public AsyncValue::Executor {\n-  void Execute(Task task) final { task(); }\n+struct InlineExecutor : public Executor {\n+  void Execute(Task task) final { std::move(task)(); }\n };\n \n static void BM_MapIntToFloat(benchmark::State& state) {"
        },
        {
            "sha": "405bd2a99b94abe44ecac51677139bba2fb2b9e9",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value_ref.h",
            "status": "modified",
            "additions": 20,
            "deletions": 19,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref.h?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -36,6 +36,7 @@ limitations under the License.\n #include \"absl/synchronization/mutex.h\"\n #include \"absl/types/span.h\"\n #include \"xla/tsl/concurrency/async_value.h\"\n+#include \"xla/tsl/concurrency/executor.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/logging.h\"\n \n@@ -260,7 +261,7 @@ class AsyncValueRef {\n   }\n \n   template <typename Waiter>\n-  void AndThen(AsyncValue::Executor& executor, Waiter&& waiter) const {\n+  void AndThen(Executor& executor, Waiter&& waiter) const {\n     AsPtr().AndThen(executor, std::forward<Waiter>(waiter));\n   }\n \n@@ -270,7 +271,7 @@ class AsyncValueRef {\n   }\n \n   template <typename R, typename F>\n-  AsyncValueRef<R> Map(AsyncValue::Executor& executor, F&& f) {\n+  AsyncValueRef<R> Map(Executor& executor, F&& f) {\n     return AsPtr().template Map<R>(executor, std::forward<F>(f));\n   }\n \n@@ -280,7 +281,7 @@ class AsyncValueRef {\n   }\n \n   template <typename F>\n-  auto Map(AsyncValue::Executor& executor, F&& f) {\n+  auto Map(Executor& executor, F&& f) {\n     return AsPtr().template Map<F>(executor, std::forward<F>(f));\n   }\n \n@@ -290,7 +291,7 @@ class AsyncValueRef {\n   }\n \n   template <typename R, typename F>\n-  AsyncValueRef<R> TryMap(AsyncValue::Executor& executor, F&& f) {\n+  AsyncValueRef<R> TryMap(Executor& executor, F&& f) {\n     return AsPtr().template TryMap<R>(executor, std::forward<F>(f));\n   }\n \n@@ -300,7 +301,7 @@ class AsyncValueRef {\n   }\n \n   template <typename F>\n-  auto TryMap(AsyncValue::Executor& executor, F&& f) {\n+  auto TryMap(Executor& executor, F&& f) {\n     return AsPtr().TryMap(executor, std::forward<F>(f));\n   }\n \n@@ -310,7 +311,7 @@ class AsyncValueRef {\n   }\n \n   template <typename F>\n-  auto FlatMap(AsyncValue::Executor& executor, F&& f) {\n+  auto FlatMap(Executor& executor, F&& f) {\n     return AsPtr().FlatMap(executor, std::forward<F>(f));\n   }\n \n@@ -532,7 +533,7 @@ class AsyncValuePtr {\n \n   // An overload that executes `waiter` on a user-provided executor.\n   template <typename Waiter, SimpleWaiter<Waiter>* = nullptr>\n-  void AndThen(AsyncValue::Executor& executor, Waiter&& waiter) const {\n+  void AndThen(Executor& executor, Waiter&& waiter) const {\n     value_->AndThen(executor, std::forward<Waiter>(waiter));\n   }\n \n@@ -563,7 +564,7 @@ class AsyncValuePtr {\n \n   // An overload that executes `waiter` on a user-provided executor.\n   template <typename Waiter, StatusOrWaiter<Waiter>* = nullptr>\n-  void AndThen(AsyncValue::Executor& executor, Waiter&& waiter) const {\n+  void AndThen(Executor& executor, Waiter&& waiter) const {\n     // We don't know when the executor will run the callback, so we need to\n     // copy the AsyncValueRef to keep the underlying value alive.\n     AndThen(executor,\n@@ -604,7 +605,7 @@ class AsyncValuePtr {\n \n   // An overload that executes `waiter` on a user-provided executor.\n   template <typename Waiter, StatusWaiter<Waiter>* = nullptr>\n-  void AndThen(AsyncValue::Executor& executor, Waiter&& waiter) const {\n+  void AndThen(Executor& executor, Waiter&& waiter) const {\n     // We don't know when the executor will run the callback, so we need to\n     // copy the AsyncValueRef to keep the underlying value alive.\n     AndThen(executor,\n@@ -641,7 +642,7 @@ class AsyncValuePtr {\n \n   // An overload that executes `f` on a user-provided executor.\n   template <typename R, typename F, MapFunctor<R, F>* = nullptr>\n-  AsyncValueRef<R> Map(AsyncValue::Executor& executor, F&& f) {\n+  AsyncValueRef<R> Map(Executor& executor, F&& f) {\n     auto result = MakeUnconstructedAsyncValueRef<R>();\n     // We don't know when the executor will run the callback, so we need to\n     // copy the AsyncValueRef to keep the underlying value alive.\n@@ -690,7 +691,7 @@ class AsyncValuePtr {\n \n   // An overload that executes `f` on a user-provided executor.\n   template <typename R, typename F, TryMapFunctor<R, F>* = nullptr>\n-  AsyncValueRef<R> TryMap(AsyncValue::Executor& executor, F&& f) {\n+  AsyncValueRef<R> TryMap(Executor& executor, F&& f) {\n     auto result = MakeUnconstructedAsyncValueRef<R>();\n     // We don't know when the executor will run the callback, so we need to\n     // copy the AsyncValueRef to keep the underlying value alive.\n@@ -719,7 +720,7 @@ class AsyncValuePtr {\n   // A `Map` overload that automatically infers the type of result from `f` and\n   // executes `f` on user-provided executor.\n   template <typename F, typename R = std::invoke_result_t<F, T&>>\n-  auto Map(AsyncValue::Executor& executor, F&& f) {\n+  auto Map(Executor& executor, F&& f) {\n     return Map<R>(executor, std::forward<F>(f));\n   }\n \n@@ -734,7 +735,7 @@ class AsyncValuePtr {\n   // and executes `f` on user-provided executor.\n   template <typename F, typename R = std::invoke_result_t<F, T&>,\n             std::enable_if_t<internal::is_status_or_v<R>>* = nullptr>\n-  auto TryMap(AsyncValue::Executor& executor, F&& f) {\n+  auto TryMap(Executor& executor, F&& f) {\n     return TryMap<typename R::value_type>(executor, std::forward<F>(f));\n   }\n \n@@ -785,7 +786,7 @@ class AsyncValuePtr {\n \n   // An overload that executes `f` on a user-provided executor.\n   template <typename F, typename R = FlatMapFunctor<F>>\n-  AsyncValueRef<R> FlatMap(AsyncValue::Executor& executor, F&& f) {\n+  AsyncValueRef<R> FlatMap(Executor& executor, F&& f) {\n     // We don't have a special handling for concrete values here because\n     // we must execute user functor on a separate executor and can't call it in\n     // the caller thread.\n@@ -1113,7 +1114,7 @@ AsyncValueRef<T> MakeAvailableAsyncValueRef(Args&&... args) {\n //\n template <typename T, typename F, typename R = std::invoke_result_t<F>,\n           std::enable_if_t<std::is_constructible_v<T, R>>* = nullptr>\n-AsyncValueRef<T> MakeAsyncValueRef(AsyncValue::Executor& executor, F&& f) {\n+AsyncValueRef<T> MakeAsyncValueRef(Executor& executor, F&& f) {\n   auto result = MakeUnconstructedAsyncValueRef<T>();\n   executor.Execute(\n       [result, f = std::forward<F>(f)]() mutable { result.emplace(f()); });\n@@ -1123,7 +1124,7 @@ AsyncValueRef<T> MakeAsyncValueRef(AsyncValue::Executor& executor, F&& f) {\n // A `MakeAsyncValueRef` overload that automatically infers the type of result\n // from `f`.\n template <typename F, typename R = std::invoke_result_t<F>>\n-AsyncValueRef<R> MakeAsyncValueRef(AsyncValue::Executor& executor, F&& f) {\n+AsyncValueRef<R> MakeAsyncValueRef(Executor& executor, F&& f) {\n   return MakeAsyncValueRef<R>(executor, std::forward<F>(f));\n }\n \n@@ -1140,7 +1141,7 @@ template <typename T, typename F, typename R = std::invoke_result_t<F>,\n           std::enable_if_t<\n               internal::is_status_or_v<R> &&\n               std::is_constructible_v<T, typename R::value_type>>* = nullptr>\n-AsyncValueRef<T> TryMakeAsyncValueRef(AsyncValue::Executor& executor, F&& f) {\n+AsyncValueRef<T> TryMakeAsyncValueRef(Executor& executor, F&& f) {\n   auto result = MakeUnconstructedAsyncValueRef<T>();\n   executor.Execute([result, f = std::forward<F>(f)]() mutable {\n     absl::StatusOr<typename R::value_type> status_or = f();\n@@ -1157,8 +1158,8 @@ AsyncValueRef<T> TryMakeAsyncValueRef(AsyncValue::Executor& executor, F&& f) {\n // result from `f`.\n template <typename F, typename R = std::invoke_result_t<F>,\n           std::enable_if_t<internal::is_status_or_v<R>>* = nullptr>\n-AsyncValueRef<typename R::value_type> TryMakeAsyncValueRef(\n-    AsyncValue::Executor& executor, F&& f) {\n+AsyncValueRef<typename R::value_type> TryMakeAsyncValueRef(Executor& executor,\n+                                                           F&& f) {\n   return TryMakeAsyncValueRef<typename R::value_type>(executor,\n                                                       std::forward<F>(f));\n }"
        },
        {
            "sha": "5badd35933695cd4b2cd63a36a7059f6fe480b3b",
            "filename": "third_party/xla/xla/tsl/concurrency/async_value_ref_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fasync_value_ref_test.cc?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -30,6 +30,7 @@ limitations under the License.\n #include \"absl/status/statusor.h\"\n #include \"absl/types/span.h\"\n #include \"xla/tsl/concurrency/async_value.h\"\n+#include \"xla/tsl/concurrency/executor.h\"\n #include \"xla/tsl/concurrency/ref_count.h\"\n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/platform/test_benchmark.h\"\n@@ -407,15 +408,15 @@ TEST(AsyncValueRefTest, FlatMapUnavailableError) {\n   EXPECT_EQ(fmapped_to_float.GetError(), absl::InternalError(\"error\"));\n }\n \n-struct DeferredExecutor : public AsyncValue::Executor {\n+struct DeferredExecutor : public Executor {\n   void Execute(Task task) final { tasks.push_back(std::move(task)); }\n \n   size_t Quiesce() {\n     size_t n = 0;\n     while (!tasks.empty()) {\n       Task task = std::move(tasks.back());\n       tasks.pop_back();\n-      task();\n+      std::move(task)();\n       ++n;\n     }\n     return n;"
        },
        {
            "sha": "cadefacd5ae48eefe92c0a303eaa4bdfd9a2ab56",
            "filename": "third_party/xla/xla/tsl/concurrency/executor.h",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fexecutor.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fexecutor.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Fexecutor.h?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -0,0 +1,43 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_TSL_CONCURRENCY_EXECUTOR_H_\n+#define XLA_TSL_CONCURRENCY_EXECUTOR_H_\n+\n+#include \"absl/functional/any_invocable.h\"\n+\n+namespace tsl {\n+\n+// Executor allows to customize where the `AsyncValue` and `Future` callbacks\n+// are executed. By default the callback is executed on the caller thread\n+// if async value (or future) is already available, or on a thread that sets\n+// async value (or future) available (setting a value or an error), which can\n+// accidentally lead to executing a very expensive computations on an IO thread.\n+//\n+// IMPORTANT: It's the caller responsibility to ensure that executor passed to\n+// all `AndThen`, `Map` or `OnReady` function calls stay alive while async\n+// values (or futures) have unresolved callbacks waiting to be invoked.\n+class Executor {\n+ public:\n+  using Task = absl::AnyInvocable<void() &&>;\n+\n+  virtual ~Executor() = default;\n+\n+  virtual void Execute(Task task) = 0;\n+};\n+\n+}  // namespace tsl\n+\n+#endif  // XLA_TSL_CONCURRENCY_EXECUTOR_H_"
        },
        {
            "sha": "acd7228643a42c73d4a512f96218d1e2ff752392",
            "filename": "third_party/xla/xla/tsl/platform/BUILD",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2FBUILD?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -693,22 +693,22 @@ cc_library(\n )\n \n cc_library(\n-    name = \"threadpool_async_executor\",\n-    hdrs = [\"threadpool_async_executor.h\"],\n+    name = \"threadpool_executor\",\n+    hdrs = [\"threadpool_executor.h\"],\n     deps = [\n         \":env\",\n-        \"//xla/tsl/concurrency:async_value\",\n+        \"//xla/tsl/concurrency:executor\",\n     ],\n )\n \n tsl_cc_test(\n-    name = \"threadpool_async_executor_test\",\n-    srcs = [\"threadpool_async_executor_test.cc\"],\n+    name = \"threadpool_executor_test\",\n+    srcs = [\"threadpool_executor_test.cc\"],\n     deps = [\n         \":env\",\n         \":env_impl\",\n         \":test\",\n-        \":threadpool_async_executor\",\n+        \":threadpool_executor\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@com_google_googletest//:gtest_main\",\n     ],"
        },
        {
            "sha": "4db56dec1fbc6345b1e2fe3f0b301c354ffc229a",
            "filename": "third_party/xla/xla/tsl/platform/threadpool_executor.h",
            "status": "renamed",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fthreadpool_executor.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fthreadpool_executor.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fthreadpool_executor.h?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -13,30 +13,30 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#ifndef XLA_TSL_PLATFORM_THREADPOOL_ASYNC_EXECUTOR_H_\n-#define XLA_TSL_PLATFORM_THREADPOOL_ASYNC_EXECUTOR_H_\n+#ifndef XLA_TSL_PLATFORM_THREADPOOL_EXECUTOR_H_\n+#define XLA_TSL_PLATFORM_THREADPOOL_EXECUTOR_H_\n \n #include <utility>\n \n-#include \"xla/tsl/concurrency/async_value.h\"\n+#include \"xla/tsl/concurrency/executor.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n \n namespace tsl::thread {\n \n-// An adaptor for a ThreadPool that converts it into the AsyncValue:Executor.\n+// An adaptor for a ThreadPool that converts it into the tsl::Executor.\n //\n-// AsncValue::Executor task is a move-only absl::AnyInvocable, and ThreadPool\n+// tsl::Executor task is a move-only absl::AnyInvocable, and ThreadPool\n // expects a copyable std::function. This class adapts the two and makes sure\n // that the task is deleted when it's done executing.\n-class ThreadPoolAsyncExecutor : public AsyncValue::Executor {\n+class ThreadPoolExecutor : public Executor {\n  public:\n-  explicit ThreadPoolAsyncExecutor(ThreadPool* thread_pool)\n+  explicit ThreadPoolExecutor(ThreadPool* thread_pool)\n       : thread_pool_(thread_pool) {}\n \n   void Execute(Task task) final {\n     auto* task_ptr = new Task(std::move(task));\n     thread_pool_->Schedule([task_ptr] {\n-      (*task_ptr)();\n+      std::move((*task_ptr))();\n       delete task_ptr;\n     });\n   }\n@@ -47,4 +47,4 @@ class ThreadPoolAsyncExecutor : public AsyncValue::Executor {\n \n }  // namespace tsl::thread\n \n-#endif  // XLA_TSL_PLATFORM_THREADPOOL_ASYNC_EXECUTOR_H_\n+#endif  // XLA_TSL_PLATFORM_THREADPOOL_EXECUTOR_H_",
            "previous_filename": "third_party/xla/xla/tsl/platform/threadpool_async_executor.h"
        },
        {
            "sha": "44d23156a861970028c8c74215d13056dbc28c4a",
            "filename": "third_party/xla/xla/tsl/platform/threadpool_executor_test.cc",
            "status": "renamed",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fthreadpool_executor_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/597068cc9a02135e2421fb69126dfacb39815511/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fthreadpool_executor_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fthreadpool_executor_test.cc?ref=597068cc9a02135e2421fb69126dfacb39815511",
            "patch": "@@ -13,7 +13,7 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#include \"xla/tsl/platform/threadpool_async_executor.h\"\n+#include \"xla/tsl/platform/threadpool_executor.h\"\n \n #include \"absl/synchronization/notification.h\"\n #include \"xla/tsl/platform/env.h\"\n@@ -23,9 +23,9 @@ limitations under the License.\n namespace tsl::thread {\n namespace {\n \n-TEST(ThreadPoolAsyncExecutorTest, ExecuteTasks) {\n+TEST(ThreadPoolExecutorTest, ExecuteTasks) {\n   ThreadPool thread_pool(Env::Default(), \"test\", 4);\n-  ThreadPoolAsyncExecutor executor(&thread_pool);\n+  ThreadPoolExecutor executor(&thread_pool);\n \n   absl::Notification notification;\n   executor.Execute([&] { notification.Notify(); });",
            "previous_filename": "third_party/xla/xla/tsl/platform/threadpool_async_executor_test.cc"
        }
    ],
    "stats": {
        "total": 221,
        "additions": 115,
        "deletions": 106
    }
}