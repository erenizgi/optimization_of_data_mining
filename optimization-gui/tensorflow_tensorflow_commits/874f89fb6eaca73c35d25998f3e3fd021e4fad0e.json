{
    "author": "Varcho",
    "message": "[ReplicaGroupV3][Partitioner][Utilities] cleanup iota functions for creating V2 replica groups and add test for untested function.\n\nPiperOrigin-RevId: 839156336",
    "sha": "874f89fb6eaca73c35d25998f3e3fd021e4fad0e",
    "files": [
        {
            "sha": "5545ddf61609eed64be0e1f8f73b254429f3dc06",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner.cc",
            "status": "modified",
            "additions": 11,
            "deletions": 13,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/874f89fb6eaca73c35d25998f3e3fd021e4fad0e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/874f89fb6eaca73c35d25998f3e3fd021e4fad0e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner.cc?ref=874f89fb6eaca73c35d25998f3e3fd021e4fad0e",
            "patch": "@@ -1765,9 +1765,8 @@ PartitionedHlo PartitionedHlo::ReshardWithAllToAll(\n   HloInstruction* all_to_all = nullptr;\n   // Try to generate replica groups in compressed format.\n   std::optional<IotaReplicaGroupList> groups =\n-      GetIotaPartitionGroupsAcrossTargetDims(\n-          temp_target, {target_dim}, {group_size},\n-          state_.partitioner->num_partitions());\n+      GetIotaPartitionGroupsAcrossTargetDims(temp_target, {target_dim},\n+                                             {group_size});\n   if (state_.collective_ops_creator\n           .create_cross_partition_all_to_all_with_iota_device_list &&\n       groups.has_value()) {\n@@ -1957,9 +1956,8 @@ PartitionedHlo PartitionedHlo::TryMultipleSourceTargetDims(\n   HloInstruction* all_to_all = nullptr;\n   // Try to generate replica groups in compressed format.\n   std::optional<IotaReplicaGroupList> groups =\n-      GetIotaPartitionGroupsAcrossTargetDims(\n-          temp_target, eligible_target_dims, group_sizes,\n-          state_.partitioner->num_partitions());\n+      GetIotaPartitionGroupsAcrossTargetDims(temp_target, eligible_target_dims,\n+                                             group_sizes);\n   if (state_.collective_ops_creator\n           .create_cross_partition_all_to_all_with_iota_device_list &&\n       groups.has_value()) {\n@@ -5231,8 +5229,8 @@ SpmdPartitioner::AllGatherShardsInternal(\n       }\n       // Attempt to generate partition groups in iota format. If infeasible,\n       // fallback to list of lists representation.\n-      auto partition_group_list = GetIotaPartitionGroupsForReplication(\n-          sharding, {*it}, num_partitions_);\n+      auto partition_group_list =\n+          GetIotaPartitionGroupsForReplication(sharding, {*it});\n       if (partition_group_list.has_value() &&\n           collectives_creator\n               .create_cross_partition_all_gather_with_iota_device_list) {\n@@ -5270,8 +5268,8 @@ SpmdPartitioner::AllGatherShardsInternal(\n \n   // Attempt to generate partition groups in iota format. If infeasible,\n   // fallback to list of lists representation.\n-  auto partition_group_list = GetIotaPartitionGroupsForReplication(\n-      sharding, selected_dims, num_partitions_);\n+  auto partition_group_list =\n+      GetIotaPartitionGroupsForReplication(sharding, selected_dims);\n   if (partition_group_list.has_value() &&\n       collectives_creator\n           .create_cross_partition_all_gather_with_iota_device_list) {\n@@ -5365,8 +5363,8 @@ HloInstruction* SpmdPartitioner::AllReduceAlongShardingDimsInternal(\n   if (!per_dim_ar) {\n     // Attempt to generate partition groups in iota format. If infeasible,\n     // fallback to list of lists representation.\n-    auto partition_group_list = GetIotaPartitionGroupsForReplication(\n-        sharding, selected_dims, num_partitions_);\n+    auto partition_group_list =\n+        GetIotaPartitionGroupsForReplication(sharding, selected_dims);\n     if (partition_group_list.has_value() &&\n         collectives_creator\n             .create_cross_partition_all_reduce_with_iota_device_list) {\n@@ -5389,7 +5387,7 @@ HloInstruction* SpmdPartitioner::AllReduceAlongShardingDimsInternal(\n     // Attempt to generate partition groups in iota format. If infeasible,\n     // fallback to list of lists representation.\n     auto partition_group_list =\n-        GetIotaPartitionGroupsForReplication(sharding, {*it}, num_partitions_);\n+        GetIotaPartitionGroupsForReplication(sharding, {*it});\n     if (partition_group_list.has_value() &&\n         collectives_creator\n             .create_cross_partition_all_reduce_with_iota_device_list) {"
        },
        {
            "sha": "51a272caab6be7e16a580b4c62a58d211bec1076",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner_util.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/874f89fb6eaca73c35d25998f3e3fd021e4fad0e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/874f89fb6eaca73c35d25998f3e3fd021e4fad0e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc?ref=874f89fb6eaca73c35d25998f3e3fd021e4fad0e",
            "patch": "@@ -2924,7 +2924,7 @@ std::vector<std::vector<int64_t>> GetPartitionGroupsAcrossTargetDims(\n \n std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsAcrossTargetDims(\n     const HloSharding& sharding, std::vector<int64_t> target_dims,\n-    std::vector<int64_t> group_sizes, int64_t num_partitions) {\n+    std::vector<int64_t> group_sizes) {\n   CHECK(target_dims.size() == group_sizes.size());\n   // If provided sharding is not HloShardingV2, we cannot generate partition\n   // groups in an iota format.\n@@ -3011,8 +3011,7 @@ std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsAcrossTargetDims(\n \n // Returns partition groups in an iota format.\n std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsForReplication(\n-    const HloSharding& sharding, absl::Span<const int64_t> replication_dims,\n-    int64_t num_partitions) {\n+    const HloSharding& sharding, absl::Span<const int64_t> replication_dims) {\n   // If provided sharding is not HloShardingV2, we cannot generate partition\n   // groups in an iota format.\n   if (!sharding.tile_assignment().iota().has_value()) {"
        },
        {
            "sha": "88279750b700602c10b841e53ac4e81f595a2a66",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner_util.h",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/874f89fb6eaca73c35d25998f3e3fd021e4fad0e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/874f89fb6eaca73c35d25998f3e3fd021e4fad0e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.h?ref=874f89fb6eaca73c35d25998f3e3fd021e4fad0e",
            "patch": "@@ -610,7 +610,7 @@ std::vector<std::vector<int64_t>> GetPartitionGroupsAcrossTargetDims(\n // format from sharding.\n std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsAcrossTargetDims(\n     const HloSharding& sharding, std::vector<int64_t> target_dims,\n-    std::vector<int64_t> group_sizes, int64_t num_partitions);\n+    std::vector<int64_t> group_sizes);\n \n // Generates partition groups (groups of devices that will communicate via a\n // collective) in iota format from sharding and provided replication_dims.\n@@ -624,8 +624,7 @@ std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsAcrossTargetDims(\n // The generated device list can cover all partitions if the provided\n // sharding covers all partitions.\n std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsForReplication(\n-    const HloSharding& sharding, absl::Span<const int64_t> replication_dims,\n-    int64_t num_partitions);\n+    const HloSharding& sharding, absl::Span<const int64_t> replication_dims);\n \n // Expands partition group list across all replicas. Expects that provided\n // partition_group_list utilizes all the partitions."
        },
        {
            "sha": "326c35a9b71e5ff09567b644f09de14a6d4a7742",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner_util_test.cc",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/874f89fb6eaca73c35d25998f3e3fd021e4fad0e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/874f89fb6eaca73c35d25998f3e3fd021e4fad0e/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util_test.cc?ref=874f89fb6eaca73c35d25998f3e3fd021e4fad0e",
            "patch": "@@ -93,10 +93,23 @@ TEST(SPMDPartitionerUtilTest, GetPartitionGroupsForReplication2) {\n               testing::ContainerEq(expected_partition_groups));\n }\n \n+TEST(SPMDPartitionerUtilTest, GetIotaPartitionGroupsAcrossTargetDims) {\n+  HloSharding sharding = HloSharding::IotaTile({8, 8, 16});\n+  std::optional<IotaReplicaGroupList> actual_partition_group_list =\n+      GetIotaPartitionGroupsAcrossTargetDims(sharding, {0, 1}, {4, 4});\n+  EXPECT_TRUE(actual_partition_group_list.has_value());\n+  EXPECT_EQ(actual_partition_group_list->num_replica_groups(), 64);\n+  EXPECT_EQ(actual_partition_group_list->num_devices_per_group(), 16);\n+  EXPECT_THAT(actual_partition_group_list->reshape_dims(),\n+              testing::ElementsAre(2, 4, 2, 4, 16));\n+  EXPECT_THAT(actual_partition_group_list->transpose_perm(),\n+              testing::ElementsAre(0, 2, 4, 1, 3));\n+}\n+\n TEST(SPMDPartitionerUtilTest, GetIotaPartitionGroupsForReplication) {\n   HloSharding sharding = HloSharding::IotaTile({2, 2, 2});\n   std::optional<IotaReplicaGroupList> actual_partition_group_list =\n-      GetIotaPartitionGroupsForReplication(sharding, {1}, 8);\n+      GetIotaPartitionGroupsForReplication(sharding, {1});\n   EXPECT_TRUE(actual_partition_group_list.has_value());\n   EXPECT_EQ(actual_partition_group_list->num_replica_groups(), 4);\n   EXPECT_EQ(actual_partition_group_list->num_devices_per_group(), 2);\n@@ -109,7 +122,7 @@ TEST(SPMDPartitionerUtilTest, GetIotaPartitionGroupsForReplication) {\n TEST(SPMDPartitionerUtilTest, GetIotaPartitionGroupsForReplication2) {\n   HloSharding sharding = HloSharding::IotaTile({2, 2, 2}, {2, 2, 2}, {0, 2, 1});\n   std::optional<IotaReplicaGroupList> actual_partition_group_list =\n-      GetIotaPartitionGroupsForReplication(sharding, {0, 2}, 8);\n+      GetIotaPartitionGroupsForReplication(sharding, {0, 2});\n   EXPECT_TRUE(actual_partition_group_list.has_value());\n   EXPECT_EQ(actual_partition_group_list->num_replica_groups(), 2);\n   EXPECT_EQ(actual_partition_group_list->num_devices_per_group(), 4);"
        }
    ],
    "stats": {
        "total": 51,
        "additions": 30,
        "deletions": 21
    }
}