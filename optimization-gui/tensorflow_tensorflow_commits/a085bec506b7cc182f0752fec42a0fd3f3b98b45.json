{
    "author": "zacmustin",
    "message": "Re-add `device_assignment` to the PJRT C API, with version checking.\n\nThis CL calls `PJRT_LoadedExecutable_GetDeviceAssignment` on `LoadedExecutable` construction, but originally did not check the PJRT API version to verify whether that function was callable, causing breakages for folks using an older PJRT version. This change now checks the version (in `pjrt_c_api_client.cc`) and initializes `device_assignment_` to a `nullptr` if using an older version. It is otherwise the same.\n\nReverts 14235e047c28f20321b3453385b20bda9b053457\n\nPiperOrigin-RevId: 813653155",
    "sha": "a085bec506b7cc182f0752fec42a0fd3f3b98b45",
    "files": [
        {
            "sha": "71f15a85f1a4567c8848d2eedaa8a1804566248c",
            "filename": "third_party/xla/xla/pjrt/c/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD?ref=a085bec506b7cc182f0752fec42a0fd3f3b98b45",
            "patch": "@@ -568,13 +568,15 @@ xla_test(\n         \"//xla/pjrt:pjrt_compiler\",\n         \"//xla/pjrt/distributed:in_memory_key_value_store\",\n         \"//xla/pjrt/gpu:se_gpu_pjrt_client\",\n+        \"//xla/service:computation_placer_hdr\",\n         \"//xla/service:custom_call_target_registry\",\n         \"//xla/stream_executor/gpu:gpu_init\",\n         \"//xla/tests:literal_test_util\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:status\",\n         \"//xla/tsl/platform:status_matchers\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/cleanup\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\","
        },
        {
            "sha": "c64afce639210f2a6bc66555fb67346964d3fced",
            "filename": "third_party/xla/xla/pjrt/c/CHANGELOG.md",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md?ref=a085bec506b7cc182f0752fec42a0fd3f3b98b45",
            "patch": "@@ -1,5 +1,9 @@\n # PJRT C API changelog\n \n+## 0.79\n+\n+* Added `PJRT_LoadedExecutable_GetDeviceAssignment.`\n+\n ## 0.78\n \n * Add incarnations to `PJRT_ExecuteOptions`."
        },
        {
            "sha": "f9fb13d1b5c150229e61c7f553e19a6d0d88ce06",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api.h",
            "status": "modified",
            "additions": 32,
            "deletions": 2,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h?ref=a085bec506b7cc182f0752fec42a0fd3f3b98b45",
            "patch": "@@ -102,7 +102,7 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_Extension_Base, next);\n // Changes include:\n // * Adding a new field to the PJRT_Api or argument structs\n // * Renaming a method or argument (doesn't affect ABI)\n-#define PJRT_API_MINOR 78\n+#define PJRT_API_MINOR 79\n \n // The plugin should set the major_version and minor_version of\n // PJRT_Api.pjrt_api_version to be the `PJRT_API_MAJOR` and `PJRT_API_MINOR` in\n@@ -1503,6 +1503,35 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_LoadedExecutable_GetExecutable_Args, executable);\n typedef PJRT_Error* PJRT_LoadedExecutable_GetExecutable(\n     PJRT_LoadedExecutable_GetExecutable_Args* args);\n \n+typedef struct PJRT_DeviceAssignmentSerialized PJRT_DeviceAssignmentSerialized;\n+\n+struct PJRT_LoadedExecutable_GetDeviceAssignment_Args {\n+  size_t struct_size;\n+  PJRT_Extension_Base* extension_start;\n+  PJRT_LoadedExecutable* executable;\n+\n+  // Lives only as long as serialized_device_assignment\n+  const char* serialized_bytes;  // out\n+  size_t serialized_bytes_size;  // out\n+\n+  PJRT_DeviceAssignmentSerialized*\n+      serialized_device_assignment;  // backs serialized_bytes.\n+  // cleanup fn must be called to free the backing memory for serialized_bytes.\n+  // Should only be called once on serialized_device_assignment.\n+  void (*serialized_device_assignment_deleter)(\n+      PJRT_DeviceAssignmentSerialized* da);  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_LoadedExecutable_GetDeviceAssignment_Args,\n+                          serialized_device_assignment_deleter);\n+\n+// Retrieves the serialized DeviceAssignmentProto for a given\n+// PJRT_LoadedExecutable. The implementation allocates the serialized data,\n+// which is valid as long as `serialized_device_assignment` is alive. The\n+// caller must call `serialized_device_assignment_deleter` to free the\n+// backing memory.\n+typedef PJRT_Error* PJRT_LoadedExecutable_GetDeviceAssignment(\n+    PJRT_LoadedExecutable_GetDeviceAssignment_Args* args);\n+\n struct PJRT_Executable_Name_Args {\n   size_t struct_size;\n   PJRT_Extension_Base* extension_start;\n@@ -2647,11 +2676,12 @@ typedef struct PJRT_Api {\n   _PJRT_API_STRUCT_FIELD(PJRT_TopologyDescription_Deserialize);\n   _PJRT_API_STRUCT_FIELD(PJRT_Client_CreateAliasBuffer);\n   _PJRT_API_STRUCT_FIELD(PJRT_Client_FulfillAliasBuffer);\n+  _PJRT_API_STRUCT_FIELD(PJRT_LoadedExecutable_GetDeviceAssignment);\n } PJRT_Api;\n \n enum {\n   PJRT_Api_STRUCT_SIZE =\n-      PJRT_STRUCT_SIZE(PJRT_Api, PJRT_Client_FulfillAliasBuffer)\n+      PJRT_STRUCT_SIZE(PJRT_Api, PJRT_LoadedExecutable_GetDeviceAssignment)\n };\n \n #undef _PJRT_API_STRUCT_FIELD"
        },
        {
            "sha": "7344d292c48604e48a1c0e87e3cf9a014f29cc6e",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_gpu_test.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc?ref=a085bec506b7cc182f0752fec42a0fd3f3b98b45",
            "patch": "@@ -30,6 +30,7 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/cleanup/cleanup.h\"\n #include \"absl/container/flat_hash_map.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n@@ -61,6 +62,7 @@ limitations under the License.\n #include \"xla/pjrt/gpu/se_gpu_pjrt_client.h\"\n #include \"xla/pjrt/pjrt_common.h\"\n #include \"xla/pjrt/pjrt_compiler.h\"\n+#include \"xla/service/computation_placer.h\"\n #include \"xla/service/custom_call_target_registry.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n@@ -284,6 +286,44 @@ TEST_F(PjrtCApiGpuExecutableTest, GetCompiledMemoryStats) {\n   EXPECT_EQ(ref_stats.host_temp_size_in_bytes, stats.host_temp_size_in_bytes);\n }\n \n+TEST_F(PjrtCApiGpuExecutableTest, GetDeviceAssignment) {\n+  PJRT_LoadedExecutable_GetDeviceAssignment_Args args;\n+  args.struct_size = PJRT_LoadedExecutable_GetDeviceAssignment_Args_STRUCT_SIZE;\n+  args.extension_start = nullptr;\n+  args.executable = executable_.get();\n+\n+  PJRT_Error* error = api_->PJRT_LoadedExecutable_GetDeviceAssignment(&args);\n+  ASSERT_EQ(error, nullptr);\n+\n+  absl::Cleanup cleanup = [&args] {\n+    args.serialized_device_assignment_deleter(\n+        args.serialized_device_assignment);\n+  };\n+\n+  // Deserialize\n+  xla::DeviceAssignmentProto proto;\n+  std::string serialized_proto(args.serialized_bytes,\n+                               args.serialized_bytes_size);\n+  ASSERT_TRUE(proto.ParseFromString(serialized_proto));\n+  TF_ASSERT_OK_AND_ASSIGN(auto device_assignment,\n+                          xla::DeviceAssignment::Deserialize(proto));\n+\n+  // Use the PJRT C++ API to create a reference device assignment.\n+  const xla::DeviceAssignment& ref_device_assignment =\n+      executable_->get()->device_assignment();\n+\n+  // Compare with reference to ensure the C++ and C APIs are equivalent.\n+  EXPECT_EQ(device_assignment->replica_count(),\n+            ref_device_assignment.replica_count());\n+  EXPECT_EQ(device_assignment->computation_count(),\n+            ref_device_assignment.computation_count());\n+  for (int i = 0; i < device_assignment->replica_count(); ++i) {\n+    for (int j = 0; j < device_assignment->computation_count(); ++j) {\n+      EXPECT_EQ((*device_assignment)(i, j), ref_device_assignment(i, j));\n+    }\n+  }\n+}\n+\n TEST_F(PjrtCApiGpuTest, CreateAndDestroyExecuteContext) {\n   PJRT_ExecuteContext_Create_Args create_arg;\n   create_arg.struct_size = PJRT_ExecuteContext_Create_Args_STRUCT_SIZE;"
        },
        {
            "sha": "37e7f7504e92b28164d5604721155f9dbb8727bc",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc?ref=a085bec506b7cc182f0752fec42a0fd3f3b98b45",
            "patch": "@@ -942,6 +942,9 @@ FieldOffsetsAndSizesForVersion(int major_version, int minor_version) {\n       add_field(\"PJRT_Client_CreateAliasBuffer\", kFnPtrSize);\n       add_field(\"PJRT_Client_FulfillAliasBuffer\", kFnPtrSize);\n     }\n+    if (minor_version >= 79) {\n+      add_field(\"PJRT_LoadedExecutable_GetDeviceAssignment\", kFnPtrSize);\n+    }\n     return version_offsets_and_sizes;\n   }\n   LOG(FATAL) << \"Unsupported API version: \" << major_version << \".\"\n@@ -1330,6 +1333,9 @@ TEST_F(PjrtCAbiTestBase, FieldOffsetsAndSizes) {\n           {\"PJRT_Client_FulfillAliasBuffer\",\n            {offsetof(PJRT_Api, PJRT_Client_FulfillAliasBuffer),\n             sizeof(PJRT_Api::PJRT_Client_FulfillAliasBuffer)}},\n+          {\"PJRT_LoadedExecutable_GetDeviceAssignment\",\n+           {offsetof(PJRT_Api, PJRT_LoadedExecutable_GetDeviceAssignment),\n+            sizeof(PJRT_Api::PJRT_LoadedExecutable_GetDeviceAssignment)}},\n       };\n   ASSERT_EQ(api_->pjrt_api_version.major_version, PJRT_API_MAJOR);\n   ASSERT_EQ(api_->pjrt_api_version.minor_version, PJRT_API_MINOR);"
        },
        {
            "sha": "61c718e85c70c32b0ba3d0baa148fd75dd9b7a95",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.cc",
            "status": "modified",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc?ref=a085bec506b7cc182f0752fec42a0fd3f3b98b45",
            "patch": "@@ -2583,6 +2583,57 @@ PJRT_Error* PJRT_TopologyDescription_Deserialize(\n   return nullptr;\n }\n \n+PJRT_Error* PJRT_LoadedExecutable_GetDeviceAssignment(\n+    PJRT_LoadedExecutable_GetDeviceAssignment_Args* args) {\n+  PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n+      \"PJRT_LoadedExecutable_GetDeviceAssignment_Args\",\n+      PJRT_LoadedExecutable_GetDeviceAssignment_Args_STRUCT_SIZE,\n+      args->struct_size));\n+\n+  // A portable executable doesn't have a device assignment. Return an empty\n+  // assignment and no-op deleter in this case.\n+  PJRT_ASSIGN_OR_RETURN(\n+      xla::CompileOptions compile_options,\n+      args->executable->executable->GetExecutable()->GetCompileOptions());\n+  if (compile_options.compile_portable_executable) {\n+    args->serialized_bytes_size = 0;\n+    args->serialized_device_assignment = nullptr;\n+    args->serialized_device_assignment_deleter =\n+        +[](PJRT_DeviceAssignmentSerialized* serialized_device_assignment) {};\n+    return nullptr;\n+  }\n+\n+  const xla::DeviceAssignment& device_assignment =\n+      args->executable->executable->device_assignment();\n+\n+  xla::DeviceAssignmentProto proto;\n+  device_assignment.Serialize(&proto);\n+\n+  std::string serialized_proto;\n+  if (!proto.SerializeToString(&serialized_proto)) {\n+    return new PJRT_Error{xla::ResourceExhausted(\n+        \"%s: Device assignment serialization failed, likely due to exceeding \"\n+        \"the max supported protobuf size of 2 GiB.\",\n+        __func__)};\n+  }\n+\n+  PJRT_DeviceAssignmentSerialized* serialized_da =\n+      new PJRT_DeviceAssignmentSerialized;\n+  if (serialized_da == nullptr) {\n+    return new PJRT_Error{xla::ResourceExhausted(\n+        \"Out of memory for `PJRT_LoadedExecutable_GetDeviceAssignment()`\")};\n+  }\n+  serialized_da->serialized = std::move(serialized_proto);\n+  args->serialized_device_assignment = serialized_da;\n+  args->serialized_bytes = serialized_da->serialized.data();\n+  args->serialized_bytes_size = serialized_da->serialized.size();\n+  args->serialized_device_assignment_deleter =\n+      +[](PJRT_DeviceAssignmentSerialized* serialized_device_assignment) {\n+        delete serialized_device_assignment;\n+      };\n+  return nullptr;\n+}\n+\n // ---------------------------------- Layouts ----------------------------------\n \n PJRT_Error* PJRT_Layouts_MemoryLayout_Destroy(\n@@ -3046,6 +3097,8 @@ PJRT_Api CreatePjrtApi(PJRT_Client_Create* create_fn,\n       pjrt::PJRT_Client_CreateAliasBuffer,\n       /*PJRT_Client_FulfillAliasBuffer=*/\n       pjrt::PJRT_Client_FulfillAliasBuffer,\n+      /*PJRT_LoadedExecutable_GetDeviceAssignment=*/\n+      pjrt::PJRT_LoadedExecutable_GetDeviceAssignment,\n   };\n }\n "
        },
        {
            "sha": "dcb59ef6c1436b6b73be2d6ac3066b03864a5f3d",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.h",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.h?ref=a085bec506b7cc182f0752fec42a0fd3f3b98b45",
            "patch": "@@ -210,6 +210,10 @@ struct PJRT_SerializedExecutable {\n   std::string serialized;\n };\n \n+struct PJRT_DeviceAssignmentSerialized {\n+  std::string serialized;\n+};\n+\n struct PJRT_SerializedTopology {\n   std::string serialized;\n };\n@@ -384,6 +388,8 @@ PJRT_Error* PJRT_LoadedExecutable_GetExecutable(\n // until the next major version upgrade.\n PJRT_Error* PJRT_LoadedExecutable_Fingerprint(\n     PJRT_LoadedExecutable_Fingerprint_Args* args);\n+PJRT_Error* PJRT_LoadedExecutable_GetDeviceAssignment(\n+    PJRT_LoadedExecutable_GetDeviceAssignment_Args* args);\n \n PJRT_Error* PJRT_Buffer_Destroy(PJRT_Buffer_Destroy_Args* args);\n PJRT_Error* PJRT_Buffer_ElementType(PJRT_Buffer_ElementType_Args* args);"
        },
        {
            "sha": "55873126507a502b0292323375ac313741177f91",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.cc?ref=a085bec506b7cc182f0752fec42a0fd3f3b98b45",
            "patch": "@@ -1822,6 +1822,7 @@ PjRtCApiLoadedExecutable::PjRtCApiLoadedExecutable(\n   executable_ =\n       std::make_unique<PjRtCApiExecutable>(pjrt_c_api(), args.executable);\n   InitDevices();\n+  InitDeviceAssignment();\n }\n \n void PjRtCApiLoadedExecutable::InitDevices() {\n@@ -1846,6 +1847,45 @@ void PjRtCApiLoadedExecutable::InitDevices() {\n   }\n }\n \n+void PjRtCApiLoadedExecutable::InitDeviceAssignment() {\n+  if (pjrt_c_api()->pjrt_api_version.major_version == 0 &&\n+      pjrt_c_api()->pjrt_api_version.minor_version < 79) {\n+    device_assignment_ = nullptr;\n+    return;\n+  }\n+  PJRT_LoadedExecutable_GetDeviceAssignment_Args args;\n+  args.struct_size = PJRT_LoadedExecutable_GetDeviceAssignment_Args_STRUCT_SIZE;\n+  args.extension_start = nullptr;\n+  args.executable = c_loaded_executable();\n+\n+  const PJRT_Api* api = pjrt_c_api();\n+\n+  pjrt::LogFatalIfPjrtError(\n+      api->PJRT_LoadedExecutable_GetDeviceAssignment(&args), api);\n+\n+  absl::Cleanup cleanup = [&args] {\n+    args.serialized_device_assignment_deleter(\n+        args.serialized_device_assignment);\n+  };\n+\n+  // If `serialized_bytes_size` is 0, this executable is portable and has no\n+  // device assignment.\n+  if (args.serialized_bytes_size == 0) {\n+    device_assignment_ = nullptr;\n+    return;\n+  }\n+\n+  std::string serialized_proto(args.serialized_bytes,\n+                               args.serialized_bytes_size);\n+  DeviceAssignmentProto proto;\n+  CHECK(proto.ParseFromString(serialized_proto));\n+\n+  absl::StatusOr<std::unique_ptr<DeviceAssignment>> device_assignment =\n+      DeviceAssignment::Deserialize(proto);\n+  CHECK_OK(device_assignment.status());\n+  device_assignment_ = std::move(*device_assignment);\n+}\n+\n static std::vector<std::vector<PJRT_Buffer*>> Convert2DCppBuffersToCBuffers(\n     absl::Span<const std::vector<PjRtBuffer*>> cpp_lists) {\n   std::vector<std::vector<PJRT_Buffer*>> c_lists;"
        },
        {
            "sha": "8e8bf651f2b4e0e8dd53f6e0aa2f25c81c8b2aec",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client.h?ref=a085bec506b7cc182f0752fec42a0fd3f3b98b45",
            "patch": "@@ -624,7 +624,11 @@ class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n   }\n \n   const DeviceAssignment& device_assignment() const override {\n-    CHECK(false) << \"PJRT C API does not support device_assignment\";\n+    CHECK(device_assignment_ != nullptr)\n+        << \"device_assignment_ is a nullptr. This is likely because \"\n+           \"PjRtCApiLoadedExecutable::device_assignment() was called on a \"\n+           \"portable executable, which does not have a device assignment.\";\n+    return *device_assignment_;\n   }\n \n   absl::Span<const LogicalDeviceIds> addressable_device_logical_ids()\n@@ -755,8 +759,10 @@ class PjRtCApiLoadedExecutable : public PjRtLoadedExecutable {\n       loaded_executable_;\n   std::unique_ptr<PjRtCApiExecutable> executable_;\n   std::vector<PjRtDevice*> addressable_devices_;\n+  std::unique_ptr<const DeviceAssignment> device_assignment_;\n \n   void InitDevices();\n+  void InitDeviceAssignment();\n };\n \n class CApiCopyToDeviceStream : public CopyToDeviceStream {"
        },
        {
            "sha": "639cf7add67873185faa1c52c12f17fff50ecec9",
            "filename": "third_party/xla/xla/pjrt/pjrt_c_api_client_test.cc",
            "status": "modified",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/a085bec506b7cc182f0752fec42a0fd3f3b98b45/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_c_api_client_test.cc?ref=a085bec506b7cc182f0752fec42a0fd3f3b98b45",
            "patch": "@@ -350,6 +350,35 @@ TEST(PjRtClientTest, CanQueryMemoryDescriptions) {\n   }\n }\n \n+TEST(PjRtCApiClientTest, GetDeviceAssignment) {\n+  SetUpCpuPjRtApi();\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtClient> client,\n+                          GetCApiClient(\"cpu\"));\n+  ASSERT_GT(client->addressable_devices().size(), 1);\n+\n+  XlaBuilder builder(\"Identity\");\n+  Shape shape = ShapeUtil::MakeShape(S32, {2, 3});\n+  auto input = Parameter(&builder, 0, shape, \"input\");\n+  auto computation = builder.Build(input).value();\n+\n+  DeviceAssignment device_assignment(1, 2);\n+  device_assignment(0, 0) = 0;\n+  device_assignment(0, 1) = 1;\n+\n+  CompileOptions options;\n+  options.executable_build_options.set_device_assignment(device_assignment);\n+\n+  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtLoadedExecutable> executable,\n+                          client->CompileAndLoad(computation, options));\n+\n+  const DeviceAssignment& retrieved_assignment =\n+      executable->device_assignment();\n+  EXPECT_EQ(retrieved_assignment.replica_count(), 1);\n+  EXPECT_EQ(retrieved_assignment.computation_count(), 2);\n+  EXPECT_EQ(retrieved_assignment(0, 0), 0);\n+  EXPECT_EQ(retrieved_assignment(0, 1), 1);\n+}\n+\n TEST(PjRtCApiClientTest, WrapClientAroundCApi) {\n   const PJRT_Api* c_api = ::pjrt::cpu_plugin::GetCpuPjrtApi();\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtClient> client,"
        }
    ],
    "stats": {
        "total": 222,
        "additions": 219,
        "deletions": 3
    }
}