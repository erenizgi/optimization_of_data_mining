{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 829328949",
    "sha": "cad893c92dfe3188562485fc46692fd68827a3ec",
    "files": [
        {
            "sha": "42ec4e98b04071f09c9280bc34ed12d2a9d5aeb5",
            "filename": "tensorflow/core/util/ragged_to_dense_util.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fragged_to_dense_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fragged_to_dense_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fragged_to_dense_util.cc?ref=cad893c92dfe3188562485fc46692fd68827a3ec",
            "patch": "@@ -28,7 +28,7 @@ namespace tensorflow {\n using errors::InvalidArgument;\n \n absl::Status GetRowPartitionTypesHelper(\n-    const std::vector<string>& row_partition_type_strings,\n+    const std::vector<std::string>& row_partition_type_strings,\n     std::vector<RowPartitionType>* row_partition_types) {\n   *row_partition_types = GetRowPartitionTypesHelper(row_partition_type_strings);\n   if (row_partition_types->size() != row_partition_type_strings.size()) {"
        },
        {
            "sha": "28d698b73a3ca847c4a32429384428bb046e0be9",
            "filename": "tensorflow/core/util/ragged_to_dense_util.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fragged_to_dense_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fragged_to_dense_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fragged_to_dense_util.h?ref=cad893c92dfe3188562485fc46692fd68827a3ec",
            "patch": "@@ -26,25 +26,25 @@ limitations under the License.\n \n namespace tensorflow {\n \n-string RowPartitionTypeToString(RowPartitionType row_partition_type);\n+std::string RowPartitionTypeToString(RowPartitionType row_partition_type);\n \n absl::Status GetRowPartitionTypesHelper(\n-    const std::vector<string>& row_partition_type_strings,\n+    const std::vector<std::string>& row_partition_type_strings,\n     std::vector<RowPartitionType>* row_partition_types);\n \n // ContextType must be InferenceContext or OpKernelConstruction.\n template <typename ContextType>\n absl::Status GetRowPartitionTypes(\n     ContextType* context, std::vector<RowPartitionType>* row_partition_types) {\n-  std::vector<string> row_partition_type_strings;\n+  std::vector<std::string> row_partition_type_strings;\n   TF_RETURN_IF_ERROR(\n       context->GetAttr(\"row_partition_types\", &row_partition_type_strings));\n   return GetRowPartitionTypesHelper(row_partition_type_strings,\n                                     row_partition_types);\n }\n \n absl::Status GetRowPartitionTypesHelper(\n-    const std::vector<string>& row_partition_type_strings,\n+    const std::vector<std::string>& row_partition_type_strings,\n     std::vector<RowPartitionType>* row_partition_types);\n \n absl::Status CombineRaggedTensorToTensorShapes("
        },
        {
            "sha": "ad3af9c6267e205247704b24d432b227cab0eb7b",
            "filename": "tensorflow/core/util/ragged_to_dense_util_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fragged_to_dense_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fragged_to_dense_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fragged_to_dense_util_test.cc?ref=cad893c92dfe3188562485fc46692fd68827a3ec",
            "patch": "@@ -77,7 +77,7 @@ TEST(CombineRaggedTensorToTensorShapes, UnknownShapeDenseValue) {\n }\n \n TEST(GetRowPartitionTypesHelper, BasicTest) {\n-  const std::vector<string> row_partition_type_strings = {\n+  const std::vector<std::string> row_partition_type_strings = {\n       \"FIRST_DIM_SIZE\", \"VALUE_ROWIDS\", \"ROW_SPLITS\"};\n   std::vector<RowPartitionType> row_partition_types;\n   TF_ASSERT_OK(GetRowPartitionTypesHelper(row_partition_type_strings,"
        },
        {
            "sha": "c8f40a224756e0e29ea583ff4922d65c9b80b919",
            "filename": "tensorflow/core/util/reporter_test.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 11,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Freporter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Freporter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Freporter_test.cc?ref=cad893c92dfe3188562485fc46692fd68827a3ec",
            "patch": "@@ -44,8 +44,8 @@ TEST(TestReporter, UsesEnv) {\n \n   // Set a file we can't possibly create, check for failure\n   setenv(TestReporter::kTestReporterEnv, \"/cant/find/me:!\", 1);\n-  CHECK_EQ(string(std::getenv(TestReporter::kTestReporterEnv)),\n-           string(\"/cant/find/me:!\"));\n+  CHECK_EQ(std::string(std::getenv(TestReporter::kTestReporterEnv)),\n+           std::string(\"/cant/find/me:!\"));\n   TestReporter test_reporter(\"b1\");\n   absl::Status s = test_reporter.Initialize();\n   ExpectHasSubstr(s.ToString(), \"/cant/find/me\");\n@@ -92,14 +92,15 @@ TEST(TestReporter, CreateCloseCreateAgainSkipsSecond) {\n }\n \n TEST(TestReporter, Benchmark) {\n-  string fname = absl::StrCat(testing::TmpDir(), \"/test_reporter_benchmarks_\");\n+  std::string fname =\n+      absl::StrCat(testing::TmpDir(), \"/test_reporter_benchmarks_\");\n   TestReporter test_reporter(fname, \"b1/2/3\");\n   TF_EXPECT_OK(test_reporter.Initialize());\n   TF_EXPECT_OK(test_reporter.Benchmark(1, 1.0, 2.0, 3.0));\n   TF_EXPECT_OK(test_reporter.Close());\n \n-  string expected_fname = absl::StrCat(fname, \"b1__2__3\");\n-  string read;\n+  std::string expected_fname = absl::StrCat(fname, \"b1__2__3\");\n+  std::string read;\n   TF_EXPECT_OK(ReadFileToString(Env::Default(), expected_fname, &read));\n \n   BenchmarkEntries benchmark_entries;\n@@ -115,15 +116,16 @@ TEST(TestReporter, Benchmark) {\n }\n \n TEST(TestReporter, SetProperties) {\n-  string fname = absl::StrCat(testing::TmpDir(), \"/test_reporter_benchmarks_\");\n+  std::string fname =\n+      absl::StrCat(testing::TmpDir(), \"/test_reporter_benchmarks_\");\n   TestReporter test_reporter(fname, \"b2/3/4\");\n   TF_EXPECT_OK(test_reporter.Initialize());\n   TF_EXPECT_OK(test_reporter.SetProperty(\"string_prop\", \"abc\"));\n   TF_EXPECT_OK(test_reporter.SetProperty(\"double_prop\", 4.0));\n \n   TF_EXPECT_OK(test_reporter.Close());\n-  string expected_fname = absl::StrCat(fname, \"b2__3__4\");\n-  string read;\n+  std::string expected_fname = absl::StrCat(fname, \"b2__3__4\");\n+  std::string read;\n   TF_EXPECT_OK(ReadFileToString(Env::Default(), expected_fname, &read));\n \n   BenchmarkEntries benchmark_entries;\n@@ -137,15 +139,16 @@ TEST(TestReporter, SetProperties) {\n }\n \n TEST(TestReporter, AddMetrics) {\n-  string fname = absl::StrCat(testing::TmpDir(), \"/test_reporter_benchmarks_\");\n+  std::string fname =\n+      absl::StrCat(testing::TmpDir(), \"/test_reporter_benchmarks_\");\n   TestReporter test_reporter(fname, \"b3/4/5\");\n   TF_EXPECT_OK(test_reporter.Initialize());\n   TF_EXPECT_OK(test_reporter.AddMetric(\"metric1\", 2.0));\n   TF_EXPECT_OK(test_reporter.AddMetric(\"metric2\", 3.0));\n \n   TF_EXPECT_OK(test_reporter.Close());\n-  string expected_fname = absl::StrCat(fname, \"b3__4__5\");\n-  string read;\n+  std::string expected_fname = absl::StrCat(fname, \"b3__4__5\");\n+  std::string read;\n   TF_EXPECT_OK(ReadFileToString(Env::Default(), expected_fname, &read));\n \n   BenchmarkEntries benchmark_entries;"
        },
        {
            "sha": "25d7562ba2f35970d53d8fc176a9e3116f7f2c79",
            "filename": "tensorflow/core/util/saved_tensor_slice_util.cc",
            "status": "modified",
            "additions": 9,
            "deletions": 8,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fsaved_tensor_slice_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fsaved_tensor_slice_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fsaved_tensor_slice_util.cc?ref=cad893c92dfe3188562485fc46692fd68827a3ec",
            "patch": "@@ -27,8 +27,9 @@ namespace checkpoint {\n \n const char kSavedTensorSlicesKey[] = \"\";\n \n-string EncodeTensorNameSlice(const string& name, const TensorSlice& slice) {\n-  string buffer;\n+std::string EncodeTensorNameSlice(const std::string& name,\n+                                  const TensorSlice& slice) {\n+  std::string buffer;\n   // All the tensor slice keys will start with a 0\n   tensorflow::strings::OrderedCode::WriteNumIncreasing(&buffer, 0);\n   tensorflow::strings::OrderedCode::WriteString(&buffer, name);\n@@ -44,10 +45,10 @@ string EncodeTensorNameSlice(const string& name, const TensorSlice& slice) {\n   return buffer;\n }\n \n-absl::Status DecodeTensorNameSlice(const string& code, string* name,\n+absl::Status DecodeTensorNameSlice(const std::string& code, std::string* name,\n                                    tensorflow::TensorSlice* slice) {\n   absl::string_view src(code);\n-  uint64 x;\n+  uint64_t x;\n   if (!tensorflow::strings::OrderedCode::ReadNumIncreasing(&src, &x)) {\n     return errors::Internal(\"Failed to parse the leading number: src = \", src);\n   }\n@@ -65,11 +66,11 @@ absl::Status DecodeTensorNameSlice(const string& code, string* name,\n     return errors::Internal(\"Expecting positive rank of the tensor, got \", x,\n                             \", src = \", src);\n   }\n-  if (x >= kint32max) {\n+  if (x >= std::numeric_limits<int32_t>::max()) {\n     return errors::Internal(\"Too many elements \", x);\n   }\n   slice->SetFullSlice(x);\n-  for (int d = 0; d < static_cast<int32>(x); ++d) {\n+  for (int d = 0; d < static_cast<int32_t>(x); ++d) {\n     // We expected 2x integers\n     int64_t start, length;\n     if (!tensorflow::strings::OrderedCode::ReadSignedNumIncreasing(&src,\n@@ -89,13 +90,13 @@ absl::Status DecodeTensorNameSlice(const string& code, string* name,\n   return absl::OkStatus();\n }\n \n-absl::Status ParseShapeAndSlice(const string& shape_and_slice,\n+absl::Status ParseShapeAndSlice(const std::string& shape_and_slice,\n                                 TensorShape* shape, TensorSlice* slice,\n                                 TensorShape* shape_slice) {\n   CHECK(!shape_and_slice.empty());\n   // Syntax: dim0 dim1 dim2 ... <slice string>\n   // Where slice string is defined in core/framework/tensor_slice.h\n-  std::vector<string> splits = str_util::Split(shape_and_slice, ' ');\n+  std::vector<std::string> splits = str_util::Split(shape_and_slice, ' ');\n \n   // Must have at least 2 strings.\n   if (splits.size() < 2) {"
        },
        {
            "sha": "8b3d8f355b3ba035b9ecee4debaa39c4b99f68be",
            "filename": "tensorflow/core/util/saved_tensor_slice_util.h",
            "status": "modified",
            "additions": 29,
            "deletions": 28,
            "changes": 57,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fsaved_tensor_slice_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fsaved_tensor_slice_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fsaved_tensor_slice_util.h?ref=cad893c92dfe3188562485fc46692fd68827a3ec",
            "patch": "@@ -43,17 +43,17 @@ extern const char kSavedTensorSlicesKey[];\n //  <dim-1-start><dim-1-length>\n //  ...\n \n-string EncodeTensorNameSlice(const string& name,\n-                             const tensorflow::TensorSlice& slice);\n+std::string EncodeTensorNameSlice(const std::string& name,\n+                                  const tensorflow::TensorSlice& slice);\n \n // Parse out the name and the slice from string encoded as an ordered code.\n-absl::Status DecodeTensorNameSlice(const string& code, string* name,\n+absl::Status DecodeTensorNameSlice(const std::string& code, std::string* name,\n                                    tensorflow::TensorSlice* slice);\n \n // Extracts the full shape, slice spec, and shape of the slice from\n // \"shape_and_slice\".  On non-OK return, caller must clear the out-arguments\n // before reusing.\n-absl::Status ParseShapeAndSlice(const string& shape_and_slice,\n+absl::Status ParseShapeAndSlice(const std::string& shape_and_slice,\n                                 TensorShape* shape, TensorSlice* slice,\n                                 TensorShape* shape_slice);\n \n@@ -127,17 +127,17 @@ TENSOR_PROTO_EXTRACT_TYPE(float, float, float);\n TENSOR_PROTO_EXTRACT_TYPE(double, double, double);\n TENSOR_PROTO_EXTRACT_TYPE_COMPLEX(complex64, scomplex, float);\n TENSOR_PROTO_EXTRACT_TYPE_COMPLEX(complex128, dcomplex, double);\n-TENSOR_PROTO_EXTRACT_TYPE(int32, int, int32);\n-TENSOR_PROTO_EXTRACT_TYPE(uint32, uint32, uint32);\n+TENSOR_PROTO_EXTRACT_TYPE(int32_t, int, int32_t);\n+TENSOR_PROTO_EXTRACT_TYPE(uint32_t, uint32, uint32_t);\n TENSOR_PROTO_EXTRACT_TYPE(int64_t, int64, protobuf_int64);\n-TENSOR_PROTO_EXTRACT_TYPE(uint64, uint64, protobuf_uint64);\n-TENSOR_PROTO_EXTRACT_TYPE(uint16, int, int32);\n-TENSOR_PROTO_EXTRACT_TYPE(uint8, int, int32);\n-TENSOR_PROTO_EXTRACT_TYPE(int8, int, int32);\n-TENSOR_PROTO_EXTRACT_TYPE(int16, int, int32);\n-TENSOR_PROTO_EXTRACT_TYPE(qint8, int, int32);\n-TENSOR_PROTO_EXTRACT_TYPE(quint8, int, int32);\n-TENSOR_PROTO_EXTRACT_TYPE(quint16, int, int32);\n+TENSOR_PROTO_EXTRACT_TYPE(uint64_t, uint64, protobuf_uint64);\n+TENSOR_PROTO_EXTRACT_TYPE(uint16_t, int, int32_t);\n+TENSOR_PROTO_EXTRACT_TYPE(uint8_t, int, int32_t);\n+TENSOR_PROTO_EXTRACT_TYPE(int8_t, int, int32_t);\n+TENSOR_PROTO_EXTRACT_TYPE(int16_t, int, int32_t);\n+TENSOR_PROTO_EXTRACT_TYPE(qint8, int, int32_t);\n+TENSOR_PROTO_EXTRACT_TYPE(quint8, int, int32_t);\n+TENSOR_PROTO_EXTRACT_TYPE(quint16, int, int32_t);\n \n #undef TENSOR_PROTO_EXTRACT_TYPE_COMPLEX\n #undef TENSOR_PROTO_EXTRACT_TYPE_HELPER\n@@ -146,23 +146,23 @@ TENSOR_PROTO_EXTRACT_TYPE(quint16, int, int32);\n // Custom implementation for qint32, based on the one for int32.\n \n template <>\n-struct SaveTypeTraits<qint32> : SaveTypeTraits<int32> {};\n+struct SaveTypeTraits<qint32> : SaveTypeTraits<int32_t> {};\n \n template <>\n inline int TensorProtoDataSize<qint32>(const TensorProto& t) {\n   return t.int_val_size();\n }\n \n template <>\n-inline const int32* TensorProtoData<qint32>(const TensorProto& t) {\n+inline const int32_t* TensorProtoData<qint32>(const TensorProto& t) {\n   static_assert(SaveTypeTraits<qint32>::supported,\n                 \"Specified type qint32 not supported for Restore\");\n-  return reinterpret_cast<const int32*>(t.int_val().data());\n+  return reinterpret_cast<const int32_t*>(t.int_val().data());\n }\n \n inline void Fill(const qint32* data, size_t n, TensorProto* t) {\n-  const int32* p = reinterpret_cast<const int32*>(data);\n-  typename protobuf::RepeatedField<int32> copy(p, p + n);\n+  const int32_t* p = reinterpret_cast<const int32_t*>(data);\n+  typename protobuf::RepeatedField<int32_t> copy(p, p + n);\n   t->mutable_int_val()->Swap(&copy);\n }\n \n@@ -172,7 +172,7 @@ template <>\n struct SaveTypeTraits<Eigen::half> {\n   static constexpr bool supported = true;\n   typedef int SavedType;\n-  typedef protobuf::RepeatedField<int32> RepeatedField;\n+  typedef protobuf::RepeatedField<int32_t> RepeatedField;\n };\n \n template <>\n@@ -186,17 +186,17 @@ inline const int* TensorProtoData<Eigen::half>(const TensorProto& t) {\n }\n \n template <>\n-inline protobuf::RepeatedField<int32>* MutableTensorProtoData<Eigen::half>(\n+inline protobuf::RepeatedField<int32_t>* MutableTensorProtoData<Eigen::half>(\n     TensorProto* t) {\n   return t->mutable_half_val();\n }\n \n template <>\n inline void Fill(const Eigen::half* data, size_t n, TensorProto* t) {\n-  typename protobuf::RepeatedField<int32>* val = t->mutable_half_val();\n+  typename protobuf::RepeatedField<int32_t>* val = t->mutable_half_val();\n   val->Resize(n, 0);\n   for (size_t i = 0; i < n; ++i) {\n-    val->Set(i, Eigen::numext::bit_cast<uint16>(data[i]));\n+    val->Set(i, Eigen::numext::bit_cast<uint16_t>(data[i]));\n   }\n }\n \n@@ -205,8 +205,8 @@ inline void Fill(const Eigen::half* data, size_t n, TensorProto* t) {\n template <>\n struct SaveTypeTraits<tstring> {\n   static constexpr bool supported = true;\n-  typedef const string* SavedType;\n-  typedef protobuf::RepeatedPtrField<string> RepeatedField;\n+  typedef const std::string* SavedType;\n+  typedef protobuf::RepeatedPtrField<std::string> RepeatedField;\n };\n \n template <>\n@@ -215,14 +215,15 @@ inline int TensorProtoDataSize<tstring>(const TensorProto& t) {\n }\n \n template <>\n-inline const string* const* TensorProtoData<tstring>(const TensorProto& t) {\n+inline const std::string* const* TensorProtoData<tstring>(\n+    const TensorProto& t) {\n   static_assert(SaveTypeTraits<tstring>::supported,\n                 \"Specified type tstring not supported for Restore\");\n   return t.string_val().data();\n }\n \n template <>\n-inline protobuf::RepeatedPtrField<string>* MutableTensorProtoData<tstring>(\n+inline protobuf::RepeatedPtrField<std::string>* MutableTensorProtoData<tstring>(\n     TensorProto* t) {\n   static_assert(SaveTypeTraits<tstring>::supported,\n                 \"Specified type tstring not supported for Save\");\n@@ -231,7 +232,7 @@ inline protobuf::RepeatedPtrField<string>* MutableTensorProtoData<tstring>(\n \n template <>\n inline void Fill(const tstring* data, size_t n, TensorProto* t) {\n-  typename protobuf::RepeatedPtrField<string> copy(data, data + n);\n+  typename protobuf::RepeatedPtrField<std::string> copy(data, data + n);\n   t->mutable_string_val()->Swap(&copy);\n }\n "
        },
        {
            "sha": "40fb0b581c70d392734a516e66917ae9f5cfc7c2",
            "filename": "tensorflow/core/util/saved_tensor_slice_util_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fsaved_tensor_slice_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fsaved_tensor_slice_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fsaved_tensor_slice_util_test.cc?ref=cad893c92dfe3188562485fc46692fd68827a3ec",
            "patch": "@@ -31,8 +31,8 @@ namespace {\n TEST(TensorShapeUtilTest, TensorNameSliceToOrderedCode) {\n   {\n     TensorSlice s = TensorSlice::ParseOrDie(\"-:-:1,3:4,5\");\n-    string buffer = EncodeTensorNameSlice(\"foo\", s);\n-    string name;\n+    std::string buffer = EncodeTensorNameSlice(\"foo\", s);\n+    std::string name;\n     s.Clear();\n     TF_CHECK_OK(DecodeTensorNameSlice(buffer, &name, &s));\n     EXPECT_EQ(\"foo\", name);"
        },
        {
            "sha": "468ecf7c5829a4d9213adec64f7c057abedea31b",
            "filename": "tensorflow/core/util/semver_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fsemver_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cad893c92dfe3188562485fc46692fd68827a3ec/tensorflow%2Fcore%2Futil%2Fsemver_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Futil%2Fsemver_test.cc?ref=cad893c92dfe3188562485fc46692fd68827a3ec",
            "patch": "@@ -33,7 +33,8 @@ bool IsDotOrIdentifierChar(char c) {\n   return false;\n }\n \n-bool ConsumeDotSeparatedIdentifiers(absl::string_view* s, const string& prefix,\n+bool ConsumeDotSeparatedIdentifiers(absl::string_view* s,\n+                                    const std::string& prefix,\n                                     absl::string_view* val) {\n   if (!absl::ConsumePrefix(s, prefix)) return false;\n   size_t i;\n@@ -50,7 +51,7 @@ TEST(SemverTest, VersionStringFollowsSemver) {\n   // Poor approximation of the semver 2.0 specification at www.semver.org.  Feel\n   // free to refine further (for example, check for leading 0s in numbers), but\n   // avoid adding dependencies.\n-  uint64 major, minor, patch;\n+  uint64_t major, minor, patch;\n   absl::string_view prerelease, metadata;\n   absl::string_view semver(TF_VERSION_STRING);\n "
        }
    ],
    "stats": {
        "total": 120,
        "additions": 63,
        "deletions": 57
    }
}