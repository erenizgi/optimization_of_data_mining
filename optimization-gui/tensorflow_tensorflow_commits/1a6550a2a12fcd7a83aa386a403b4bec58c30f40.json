{
    "author": "basioli-k",
    "message": "[XLA:CPU] Implement CPU AOT loader.\n\nA simple class with minimal llvm dependencies capable of loading AOT CPU compilation results.\n\nPiperOrigin-RevId: 810642399",
    "sha": "1a6550a2a12fcd7a83aa386a403b4bec58c30f40",
    "files": [
        {
            "sha": "6d8a3cc59bfa7f2de96caaa6df874ed844e2cc95",
            "filename": "third_party/xla/xla/service/cpu/BUILD",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1a6550a2a12fcd7a83aa386a403b4bec58c30f40/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1a6550a2a12fcd7a83aa386a403b4bec58c30f40/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2FBUILD?ref=1a6550a2a12fcd7a83aa386a403b4bec58c30f40",
            "patch": "@@ -333,6 +333,7 @@ cc_library(\n         \"//xla/service:while_loop_constant_sinking\",\n         \"//xla/service:while_loop_invariant_code_motion\",\n         \"//xla/service:while_loop_simplifier\",\n+        \"//xla/service/cpu:cpu_aot_loader\",\n         \"//xla/service/llvm_ir:llvm_command_line_options\",\n         \"//xla/service/llvm_ir:llvm_util\",\n         \"//xla/service/spmd:stateful_rng_spmd_partitioner\",\n@@ -2167,3 +2168,33 @@ xla_cc_test(\n         \"@local_tsl//tsl/platform:test\",\n     ],\n )\n+\n+cc_library(\n+    name = \"cpu_aot_loader\",\n+    srcs = [\"cpu_aot_loader.cc\"],\n+    hdrs = [\"cpu_aot_loader.h\"],\n+    deps = [\n+        \":cpu_aot_compilation_result\",\n+        \":executable_proto_cc\",\n+        \":runtime_symbol_generator\",\n+        \"//xla:util\",\n+        \"//xla/backends/cpu/codegen:cpu_features\",\n+        \"//xla/backends/cpu/codegen:execution_engine\",\n+        \"//xla/backends/cpu/codegen:ir_compiler\",\n+        \"//xla/backends/cpu/codegen:object_loader\",\n+        \"//xla/backends/cpu/runtime:function_library\",\n+        \"//xla/hlo/ir:hlo\",\n+        \"//xla/service:compiler\",\n+        \"//xla/service:executable\",\n+        \"//xla/service:hlo_module_config\",\n+        \"//xla/tsl/platform:errors\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/log\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/types:span\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//llvm:Target\",\n+        \"@llvm-project//llvm:ir_headers\",\n+    ],\n+)"
        },
        {
            "sha": "419d0f53fcd569b6ca3cbc0cbab2f3b871795b50",
            "filename": "third_party/xla/xla/service/cpu/cpu_aot_loader.cc",
            "status": "added",
            "additions": 182,
            "deletions": 0,
            "changes": 182,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1a6550a2a12fcd7a83aa386a403b4bec58c30f40/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_loader.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1a6550a2a12fcd7a83aa386a403b4bec58c30f40/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_loader.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_loader.cc?ref=1a6550a2a12fcd7a83aa386a403b4bec58c30f40",
            "patch": "@@ -0,0 +1,182 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/service/cpu/cpu_aot_loader.h\"\n+\n+#include <cstddef>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"llvm/ADT/StringRef.h\"\n+#include \"llvm/IR/DataLayout.h\"\n+#include \"llvm/Target/TargetMachine.h\"\n+#include \"llvm/Target/TargetOptions.h\"\n+#include \"xla/backends/cpu/codegen/cpu_features.h\"\n+#include \"xla/backends/cpu/codegen/execution_engine.h\"\n+#include \"xla/backends/cpu/codegen/ir_compiler.h\"\n+#include \"xla/backends/cpu/codegen/object_loader.h\"\n+#include \"xla/backends/cpu/runtime/function_library.h\"\n+#include \"xla/service/compiler.h\"\n+#include \"xla/service/cpu/cpu_aot_compilation_result.h\"\n+#include \"xla/service/cpu/executable.pb.h\"\n+#include \"xla/service/cpu/runtime_symbol_generator.h\"\n+#include \"xla/service/executable.h\"\n+#include \"xla/service/hlo_module_config.h\"\n+#include \"xla/tsl/platform/errors.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/util.h\"\n+\n+namespace xla::cpu {\n+\n+llvm::TargetOptions CompilerTargetOptions(\n+    const HloModuleConfig& module_config) {\n+  llvm::TargetOptions target_options;\n+  // Always allow FMA fusion. This increases precision instead of decreasing it.\n+  target_options.AllowFPOpFusion = llvm::FPOpFusion::Fast;\n+  return target_options;\n+}\n+\n+absl::StatusOr<std::vector<FunctionLibrary::Symbol>>\n+GetCompiledSymbolsFromProto(\n+    absl::Span<const SymbolProto> compiled_symbols_proto) {\n+  std::vector<FunctionLibrary::Symbol> compiled_symbols;\n+  for (const auto& symbol_proto : compiled_symbols_proto) {\n+    switch (symbol_proto.function_type_id()) {\n+      case SymbolProto::KERNEL:\n+        compiled_symbols.push_back(\n+            FunctionLibrary::Sym<FunctionLibrary::Kernel>(symbol_proto.name()));\n+        break;\n+      case SymbolProto::COMPARATOR:\n+        compiled_symbols.push_back(\n+            FunctionLibrary::Sym<FunctionLibrary::Comparator>(\n+                symbol_proto.name()));\n+        break;\n+      default:\n+        return Internal(\n+            \"Unknown function type id %s\",\n+            SymbolProto_FunctionTypeId_Name(symbol_proto.function_type_id()));\n+    }\n+  }\n+  VLOG(3) << \"Collected \" << compiled_symbols.size() << \" compiled symbols\";\n+  for (const auto& symbol : compiled_symbols) {\n+    VLOG(3) << \" Symbol: \" << symbol.name;\n+  }\n+\n+  return compiled_symbols;\n+}\n+\n+absl::StatusOr<std::unique_ptr<FunctionLibrary>> LoadFunctionLibrary(\n+    const std::vector<FunctionLibrary::Symbol>& compiled_symbols,\n+    absl::Span<const ObjFileProto> obj_files, const HloModule* hlo_module) {\n+  const HloModuleConfig& config = hlo_module->config();\n+  const DebugOptions& debug_options = config.debug_options();\n+  TF_ASSIGN_OR_RETURN(\n+      std::unique_ptr<llvm::TargetMachine> target_machine,\n+      IrCompiler::InferTargetMachine(\n+          std::move(CompilerTargetOptions(hlo_module->config())),\n+          IrCompiler::GetCodeGenOptLevel(config),\n+          CpuFeatureFromString(debug_options.xla_cpu_max_isa())));\n+\n+  // Definition generator to link with XLA:CPU host runtime symbols.\n+  ExecutionEngine::DefinitionGenerator definition_generator =\n+      [](const llvm::DataLayout& data_layout) {\n+        return std::make_unique<RuntimeSymbolGenerator>(data_layout);\n+      };\n+\n+  ObjectLoader object_loader(/*num_dylibs=*/1,\n+                             target_machine->createDataLayout(),\n+                             definition_generator);\n+\n+  for (size_t i = 0; i < object_loader.num_dylibs(); ++i) {\n+    object_loader.dylib(i).value()->addGenerator(\n+        std::make_unique<RuntimeSymbolGenerator>(\n+            target_machine->createDataLayout()));\n+  }\n+\n+  for (auto& obj_file : obj_files) {\n+    llvm::StringRef data(obj_file.contents().data(),\n+                         obj_file.contents().size());\n+    TF_RETURN_IF_ERROR(object_loader.AddObjFile(\n+        llvm::MemoryBuffer::getMemBuffer(data, obj_file.name())));\n+  }\n+\n+  return std::move(object_loader).Load(compiled_symbols);\n+}\n+\n+absl::StatusOr<std::unique_ptr<Executable>> CpuAotLoader::LoadExecutable(\n+    const std::string& serialized_aot_result) {\n+  xla::cpu::CompilationResultProto proto;\n+  if (!proto.ParseFromString(serialized_aot_result)) {\n+    return Internal(\"Failed to parse serialized CpuAotCompilationResult.\");\n+  }\n+  return LoadExecutable(proto);\n+}\n+\n+absl::StatusOr<std::unique_ptr<Executable>> CpuAotLoader::LoadExecutable(\n+    const xla::cpu::CompilationResultProto& aot_result_proto) {\n+  TF_ASSIGN_OR_RETURN(auto aot_result,\n+                      LoadAotCompilationResult(aot_result_proto));\n+  return LoadExecutable(std::move(*aot_result));\n+}\n+\n+absl::StatusOr<std::unique_ptr<Executable>> CpuAotLoader::LoadExecutable(\n+    xla::AotCompilationResult&& compilation_result) {\n+  return std::move(compilation_result).LoadExecutable(nullptr, nullptr);\n+}\n+\n+absl::StatusOr<std::unique_ptr<AotCompilationResult>>\n+CpuAotLoader::LoadAotCompilationResult(\n+    const std::string& serialized_aot_result) {\n+  xla::cpu::CompilationResultProto proto;\n+  if (!proto.ParseFromString(serialized_aot_result)) {\n+    return Internal(\"Failed to parse serialized CpuAotCompilationResult.\");\n+  }\n+  return LoadAotCompilationResult(proto);\n+}\n+\n+absl::StatusOr<std::unique_ptr<AotCompilationResult>>\n+CpuAotLoader::LoadAotCompilationResult(\n+    const xla::cpu::CompilationResultProto& aot_result_proto) {\n+  TF_ASSIGN_OR_RETURN(\n+      std::unique_ptr<HloModule> hlo_module,\n+      HloModule::CreateFromProtoWithConfig(aot_result_proto.hlo_module()));\n+  std::vector<SymbolProto> compiled_symbols_proto;\n+  for (const auto& symbol_proto : aot_result_proto.compiled_symbols()) {\n+    compiled_symbols_proto.push_back(symbol_proto);\n+  }\n+\n+  TF_ASSIGN_OR_RETURN(auto compiled_symbols,\n+                      GetCompiledSymbolsFromProto(compiled_symbols_proto));\n+\n+  std::vector<ObjFileProto> obj_files;\n+  for (const auto& obj_file : aot_result_proto.object_files()) {\n+    obj_files.push_back(obj_file);\n+  }\n+\n+  TF_ASSIGN_OR_RETURN(\n+      auto function_library,\n+      LoadFunctionLibrary(compiled_symbols, obj_files, hlo_module.get()));\n+\n+  return CpuAotCompilationResult::FromProto(aot_result_proto,\n+                                            std::move(function_library));\n+}\n+\n+}  // namespace xla::cpu"
        },
        {
            "sha": "635154729b709ff0ce56385a374d63a75a0d40a3",
            "filename": "third_party/xla/xla/service/cpu/cpu_aot_loader.h",
            "status": "added",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1a6550a2a12fcd7a83aa386a403b4bec58c30f40/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_loader.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1a6550a2a12fcd7a83aa386a403b4bec58c30f40/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_loader.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_loader.h?ref=1a6550a2a12fcd7a83aa386a403b4bec58c30f40",
            "patch": "@@ -0,0 +1,66 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_SERVICE_CPU_CPU_AOT_LOADER_H_\n+#define XLA_SERVICE_CPU_CPU_AOT_LOADER_H_\n+\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include \"absl/status/statusor.h\"\n+#include \"absl/types/span.h\"\n+#include \"llvm/Target/TargetOptions.h\"\n+#include \"xla/backends/cpu/runtime/function_library.h\"\n+#include \"xla/hlo/ir/hlo_module.h\"\n+#include \"xla/service/compiler.h\"\n+#include \"xla/service/cpu/executable.pb.h\"\n+#include \"xla/service/executable.h\"\n+#include \"xla/service/hlo_module_config.h\"\n+\n+namespace xla::cpu {\n+\n+llvm::TargetOptions CompilerTargetOptions(const HloModuleConfig& module_config);\n+\n+absl::StatusOr<std::unique_ptr<FunctionLibrary>> LoadFunctionLibrary(\n+    const std::vector<FunctionLibrary::Symbol>& compiled_symbols,\n+    absl::Span<const ObjFileProto> obj_files, const HloModule* hlo_module);\n+\n+absl::StatusOr<std::vector<FunctionLibrary::Symbol>>\n+GetCompiledSymbolsFromProto(\n+    absl::Span<const SymbolProto> compiled_symbols_proto);\n+\n+class CpuAotLoader {\n+ public:\n+  static absl::StatusOr<std::unique_ptr<Executable>> LoadExecutable(\n+      const std::string& serialized_aot_result);\n+\n+  static absl::StatusOr<std::unique_ptr<Executable>> LoadExecutable(\n+      const xla::cpu::CompilationResultProto& aot_result_proto);\n+\n+  static absl::StatusOr<std::unique_ptr<Executable>> LoadExecutable(\n+      xla::AotCompilationResult&& compilation_result);\n+\n+  static absl::StatusOr<std::unique_ptr<AotCompilationResult>>\n+  LoadAotCompilationResult(const std::string& serialized_aot_result);\n+\n+  static absl::StatusOr<std::unique_ptr<AotCompilationResult>>\n+  LoadAotCompilationResult(\n+      const xla::cpu::CompilationResultProto& aot_result_proto);\n+};\n+\n+}  // namespace xla::cpu\n+\n+#endif  // XLA_SERVICE_CPU_CPU_AOT_LOADER_H_"
        },
        {
            "sha": "adca954e8a8aedff40b8414948a4fc4e9ec3e3fa",
            "filename": "third_party/xla/xla/service/cpu/cpu_compiler.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 106,
            "changes": 108,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1a6550a2a12fcd7a83aa386a403b4bec58c30f40/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1a6550a2a12fcd7a83aa386a403b4bec58c30f40/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc?ref=1a6550a2a12fcd7a83aa386a403b4bec58c30f40",
            "patch": "@@ -176,6 +176,7 @@ limitations under the License.\n #include \"xla/service/cpu/buffer_info_util.h\"\n #include \"xla/service/cpu/conv_canonicalization.h\"\n #include \"xla/service/cpu/cpu_aot_compilation_result.h\"\n+#include \"xla/service/cpu/cpu_aot_loader.h\"\n #include \"xla/service/cpu/cpu_executable.h\"\n #include \"xla/service/cpu/cpu_float_support.h\"\n #include \"xla/service/cpu/cpu_instruction_fusion.h\"\n@@ -1064,14 +1065,6 @@ namespace {\n // Align buffers to XLA:CPU minimal alignment.\n int64_t memory_alignment(LogicalBuffer::Color) { return MinAlign(); }\n \n-llvm::TargetOptions CompilerTargetOptions(\n-    const HloModuleConfig& module_config) {\n-  llvm::TargetOptions target_options;\n-  // Always allow FMA fusion. This increases precision instead of decreasing it.\n-  target_options.AllowFPOpFusion = llvm::FPOpFusion::Fast;\n-  return target_options;\n-}\n-\n std::pair<LLVMCompiler::ModuleHook, LLVMCompiler::ModuleHook> GetIRModuleHooks(\n     const HloModule& hlo_module,\n     const LLVMCompiler::ModuleHook& user_pre_optimization_hook,\n@@ -2311,78 +2304,6 @@ HloCostAnalysis::ShapeSizeFunction CpuCompiler::ShapeSizeBytesFunction() const {\n   return CpuExecutable::ShapeSizeBytes;\n }\n \n-namespace {\n-\n-absl::StatusOr<std::vector<FunctionLibrary::Symbol>>\n-GetCompiledSymbolsFromProto(\n-    absl::Span<const SymbolProto> compiled_symbols_proto) {\n-  std::vector<FunctionLibrary::Symbol> compiled_symbols;\n-  for (const auto& symbol_proto : compiled_symbols_proto) {\n-    switch (symbol_proto.function_type_id()) {\n-      case SymbolProto::KERNEL:\n-        compiled_symbols.push_back(\n-            FunctionLibrary::Sym<FunctionLibrary::Kernel>(symbol_proto.name()));\n-        break;\n-      case SymbolProto::COMPARATOR:\n-        compiled_symbols.push_back(\n-            FunctionLibrary::Sym<FunctionLibrary::Comparator>(\n-                symbol_proto.name()));\n-        break;\n-      default:\n-        return Internal(\n-            \"Unknown function type id %s\",\n-            SymbolProto_FunctionTypeId_Name(symbol_proto.function_type_id()));\n-    }\n-  }\n-  VLOG(3) << \"Collected \" << compiled_symbols.size() << \" compiled symbols\";\n-  for (const auto& symbol : compiled_symbols) {\n-    VLOG(3) << \" Symbol: \" << symbol.name;\n-  }\n-\n-  return compiled_symbols;\n-}\n-\n-absl::StatusOr<std::unique_ptr<FunctionLibrary>> LoadFunctionLibrary(\n-    const std::vector<FunctionLibrary::Symbol>& compiled_symbols,\n-    absl::Span<const ObjFileProto> obj_files, const HloModule* hlo_module) {\n-  const HloModuleConfig& config = hlo_module->config();\n-  const DebugOptions& debug_options = config.debug_options();\n-\n-  TF_ASSIGN_OR_RETURN(\n-      std::unique_ptr<llvm::TargetMachine> target_machine,\n-      IrCompiler::InferTargetMachine(\n-          std::move(CompilerTargetOptions(hlo_module->config())),\n-          IrCompiler::GetCodeGenOptLevel(config),\n-          CpuFeatureFromString(debug_options.xla_cpu_max_isa())));\n-\n-  // Definition generator to link with XLA:CPU host runtime symbols.\n-  ExecutionEngine::DefinitionGenerator definition_generator =\n-      [](const llvm::DataLayout& data_layout) {\n-        return std::make_unique<RuntimeSymbolGenerator>(data_layout);\n-      };\n-\n-  ObjectLoader object_loader(/*num_dylibs=*/1,\n-                             target_machine->createDataLayout(),\n-                             definition_generator);\n-\n-  for (size_t i = 0; i < object_loader.num_dylibs(); ++i) {\n-    object_loader.dylib(i).value()->addGenerator(\n-        std::make_unique<RuntimeSymbolGenerator>(\n-            target_machine->createDataLayout()));\n-  }\n-\n-  for (auto& obj_file : obj_files) {\n-    llvm::StringRef data(obj_file.contents().data(),\n-                         obj_file.contents().size());\n-    TF_RETURN_IF_ERROR(object_loader.AddObjFile(\n-        llvm::MemoryBuffer::getMemBuffer(data, obj_file.name())));\n-  }\n-\n-  return std::move(object_loader).Load(compiled_symbols);\n-}\n-\n-}  // namespace\n-\n absl::StatusOr<std::unique_ptr<AotCompilationResult>> CpuCompiler::Export(\n     Executable* executable) const {\n   auto* cpu_executable = tensorflow::down_cast<CpuExecutable*>(executable);\n@@ -2428,32 +2349,7 @@ absl::StatusOr<std::unique_ptr<AotCompilationResult>> CpuCompiler::Export(\n absl::StatusOr<std::unique_ptr<AotCompilationResult>>\n CpuCompiler::LoadAotCompilationResult(\n     const std::string& serialized_aot_result) {\n-  CompilationResultProto proto;\n-  if (!proto.ParseFromString(serialized_aot_result)) {\n-    return Internal(\"Failed to parse serialized CpuAotCompilationResult.\");\n-  }\n-\n-  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloModule> hlo_module,\n-                      HloModule::CreateFromProtoWithConfig(proto.hlo_module()));\n-  std::vector<SymbolProto> compiled_symbols_proto;\n-  for (const auto& symbol_proto : proto.compiled_symbols()) {\n-    compiled_symbols_proto.push_back(symbol_proto);\n-  }\n-\n-  TF_ASSIGN_OR_RETURN(auto compiled_symbols,\n-                      GetCompiledSymbolsFromProto(compiled_symbols_proto));\n-\n-  std::vector<ObjFileProto> obj_files;\n-  for (const auto& obj_file : proto.object_files()) {\n-    obj_files.push_back(obj_file);\n-  }\n-\n-  TF_ASSIGN_OR_RETURN(\n-      auto function_library,\n-      LoadFunctionLibrary(compiled_symbols, obj_files, hlo_module.get()));\n-\n-  return CpuAotCompilationResult::FromProto(std::move(proto),\n-                                            std::move(function_library));\n+  return CpuAotLoader::LoadAotCompilationResult(serialized_aot_result);\n }\n \n absl::StatusOr<HloSchedule> CpuCompiler::CreateHloSchedule("
        }
    ],
    "stats": {
        "total": 387,
        "additions": 281,
        "deletions": 106
    }
}