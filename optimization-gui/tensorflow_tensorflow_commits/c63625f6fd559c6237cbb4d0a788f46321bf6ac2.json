{
    "author": "tensorflower-gardener",
    "message": "[XLA] Hoist slices through transpose operations.\n\nPiperOrigin-RevId: 805489709",
    "sha": "c63625f6fd559c6237cbb4d0a788f46321bf6ac2",
    "files": [
        {
            "sha": "4e3bc9ff41261a8371b9277ac08fb200ce0057f3",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c63625f6fd559c6237cbb4d0a788f46321bf6ac2/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c63625f6fd559c6237cbb4d0a788f46321bf6ac2/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2FBUILD?ref=c63625f6fd559c6237cbb4d0a788f46321bf6ac2",
            "patch": "@@ -1711,6 +1711,8 @@ cc_library(\n     srcs = [\"slice_hoister.cc\"],\n     hdrs = [\"slice_hoister.h\"],\n     deps = [\n+        \"//xla:permutation_util\",\n+        \"//xla:shape_util\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/pass:hlo_pass\",\n         \"//xla/tsl/platform:errors\","
        },
        {
            "sha": "488c97bd570d2752cefc1dbd0d6e5f6281d3009c",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/slice_hoister.cc",
            "status": "modified",
            "additions": 79,
            "deletions": 23,
            "changes": 102,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c63625f6fd559c6237cbb4d0a788f46321bf6ac2/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c63625f6fd559c6237cbb4d0a788f46321bf6ac2/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister.cc?ref=c63625f6fd559c6237cbb4d0a788f46321bf6ac2",
            "patch": "@@ -15,31 +15,71 @@ limitations under the License.\n \n #include \"xla/hlo/transforms/simplifiers/slice_hoister.h\"\n \n+#include <cstdint>\n #include <vector>\n \n #include \"absl/container/flat_hash_set.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n+#include \"xla/hlo/ir/hlo_casting_utils.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/hlo/ir/hlo_instruction.h\"\n+#include \"xla/hlo/ir/hlo_instructions.h\"\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n+#include \"xla/permutation_util.h\"\n+#include \"xla/shape.h\"\n+#include \"xla/shape_util.h\"\n #include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n \n namespace xla {\n \n namespace {\n \n+// Helper function to attempt hoisting a slice through a transpose operation.\n+// Returns true if a change was made.\n+absl::StatusOr<bool> TryHoistSliceThroughTranspose(\n+    HloSliceInstruction* slice_instruction, HloComputation* computation) {\n+  HloInstruction* transpose = slice_instruction->mutable_operand(0);\n+  if (transpose->opcode() != HloOpcode::kTranspose) {\n+    return false;\n+  }\n+\n+  // All checks passed, perform the hoisting.\n+  auto dimensions_permutation = transpose->dimensions();\n+  auto inversed_dimensions_permutation =\n+      InversePermutation(dimensions_permutation);\n+\n+  std::vector<int64_t> new_slice_starts = Permute(\n+      slice_instruction->slice_starts(), inversed_dimensions_permutation);\n+  std::vector<int64_t> new_slice_limits = Permute(\n+      slice_instruction->slice_limits(), inversed_dimensions_permutation);\n+  std::vector<int64_t> new_slice_strides = Permute(\n+      slice_instruction->slice_strides(), inversed_dimensions_permutation);\n+\n+  HloInstruction* transpose_operand = transpose->mutable_operand(0);\n+  Shape new_slice_shape = ShapeUtil::PermuteDimensions(\n+      inversed_dimensions_permutation, slice_instruction->shape());\n+\n+  HloInstruction* new_slice =\n+      computation->AddInstruction(HloInstruction::CreateSlice(\n+          new_slice_shape, transpose_operand, new_slice_starts,\n+          new_slice_limits, new_slice_strides));\n+  HloInstruction* new_transpose =\n+      computation->AddInstruction(HloInstruction::CreateTranspose(\n+          slice_instruction->shape(), new_slice, dimensions_permutation));\n+  TF_RETURN_IF_ERROR(\n+      computation->ReplaceInstruction(slice_instruction, new_transpose));\n+  return true;\n+}\n+\n // Helper function to attempt hoisting a slice through an element-wise binary\n // operation. Returns true if a change was made.\n absl::StatusOr<bool> TryHoistSliceThroughElementwiseBinaryOperation(\n-    HloInstruction* instruction, HloComputation* computation) {\n-  if (instruction->opcode() != HloOpcode::kSlice) {\n-    return false;\n-  }\n-  HloInstruction* slice_operand = instruction->mutable_operand(0);\n+    HloSliceInstruction* slice_instruction, HloComputation* computation) {\n+  HloInstruction* slice_operand = slice_instruction->mutable_operand(0);\n   if (!slice_operand->IsElementwiseBinary()) {\n     return false;\n   }\n@@ -52,36 +92,53 @@ absl::StatusOr<bool> TryHoistSliceThroughElementwiseBinaryOperation(\n             << rhs->shape();\n     return false;\n   }\n-  if (lhs->shape().element_type() != instruction->shape().element_type()) {\n+  if (lhs->shape().element_type() !=\n+      slice_instruction->shape().element_type()) {\n     VLOG(1) << \" Slice element type does not match operand element type: \"\n             << lhs->shape().element_type() << \" and \"\n-            << instruction->shape().element_type();\n-    return false;\n-  }\n-  if (instruction->shape().element_type() !=\n-      slice_operand->shape().element_type()) {\n-    VLOG(1) << \" Slice element type does not match slice operand element type: \"\n-            << instruction->shape().element_type() << \" and \"\n-            << slice_operand->shape().element_type();\n+            << slice_instruction->shape().element_type();\n     return false;\n   }\n \n   // All checks passed, perform the hoisting.\n   HloInstruction* lhs_slice =\n       computation->AddInstruction(HloInstruction::CreateSlice(\n-          instruction->shape(), lhs, instruction->slice_starts(),\n-          instruction->slice_limits(), instruction->slice_strides()));\n+          slice_instruction->shape(), lhs, slice_instruction->slice_starts(),\n+          slice_instruction->slice_limits(),\n+          slice_instruction->slice_strides()));\n   HloInstruction* rhs_slice =\n       computation->AddInstruction(HloInstruction::CreateSlice(\n-          instruction->shape(), rhs, instruction->slice_starts(),\n-          instruction->slice_limits(), instruction->slice_strides()));\n+          slice_instruction->shape(), rhs, slice_instruction->slice_starts(),\n+          slice_instruction->slice_limits(),\n+          slice_instruction->slice_strides()));\n   TF_RETURN_IF_ERROR(computation->ReplaceWithNewInstruction(\n-      instruction, HloInstruction::CreateBinary(instruction->shape(),\n-                                                slice_operand->opcode(),\n-                                                lhs_slice, rhs_slice)));\n+      slice_instruction, HloInstruction::CreateBinary(\n+                             slice_instruction->shape(),\n+                             slice_operand->opcode(), lhs_slice, rhs_slice)));\n   return true;\n }\n \n+// Helper function that goes through a list of potential hoisting scenarios.\n+// Returns true if a change was made.\n+absl::StatusOr<bool> TryHoistingSlice(HloInstruction* instruction,\n+                                      HloComputation* computation) {\n+  if (instruction->opcode() != HloOpcode::kSlice) {\n+    return false;\n+  }\n+  HloSliceInstruction* slice_instruction =\n+      Cast<HloSliceInstruction>(instruction);\n+  auto hoisting_functions = {TryHoistSliceThroughElementwiseBinaryOperation,\n+                             TryHoistSliceThroughTranspose};\n+  for (auto hoisting_function : hoisting_functions) {\n+    TF_ASSIGN_OR_RETURN(bool changed,\n+                        hoisting_function(slice_instruction, computation));\n+    if (changed) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n // As slices reduce the size of the input, it can be beneficial to hoist\n // slices as high in the graph as possible, ideally right after parameter\n // reads, which could reduce both compute and memory costs.\n@@ -105,8 +162,7 @@ absl::StatusOr<bool> HoistSliceOperations(HloComputation* computation) {\n         computation->MakeInstructionPostOrder();\n     for (HloInstruction* instruction : instructions) {\n       TF_ASSIGN_OR_RETURN(bool instruction_changed,\n-                          TryHoistSliceThroughElementwiseBinaryOperation(\n-                              instruction, computation));\n+                          TryHoistingSlice(instruction, computation));\n       if (instruction_changed) {\n         changed_on_last_iteration = true;\n         break;"
        },
        {
            "sha": "98b0d0a96c96124b18d5ccc12959cc4d859d17f8",
            "filename": "third_party/xla/xla/hlo/transforms/simplifiers/slice_hoister_test.cc",
            "status": "modified",
            "additions": 56,
            "deletions": 48,
            "changes": 104,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c63625f6fd559c6237cbb4d0a788f46321bf6ac2/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c63625f6fd559c6237cbb4d0a788f46321bf6ac2/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fsimplifiers%2Fslice_hoister_test.cc?ref=c63625f6fd559c6237cbb4d0a788f46321bf6ac2",
            "patch": "@@ -39,7 +39,7 @@ class SliceHoisterTest : public HloHardwareIndependentTestBase {\n   SliceHoisterTest()\n       : HloHardwareIndependentTestBase(\n             /*verifier_layout_sensitive=*/false,\n-            /*allow_mixed_precision_in_hlo_verifier=*/true) {};\n+            /*allow_mixed_precision_in_hlo_verifier=*/false) {};\n };\n \n TEST_F(SliceHoisterTest, HoistSliceThroughAdd) {\n@@ -135,32 +135,15 @@ TEST_F(SliceHoisterTest, HoistSliceThroughMultipleElementwiseBinaryOperations) {\n   check_slice_attributes(param_2_slice_1);\n }\n \n-TEST_F(SliceHoisterTest, DoesNotHoistSliceThroughAddIfElementTypesDoNotMatch) {\n-  absl::string_view module_str = R\"(\n-    HloModule module\n-    ENTRY main {\n-      add_op = f32[8,9] add(f16[8,9] parameter(0), f32[8,9] parameter(1))\n-      ROOT slice_op = f32[2,9] slice(f32[8,9] add_op), slice={[0:2], [0:9]}\n-    }\n-  )\";\n-  TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(module_str));\n-\n-  SliceHoister slice_hoister;\n-  TF_ASSERT_OK_AND_ASSIGN(bool changed,\n-                          RunHloPass(&slice_hoister, module.get()));\n-\n-  SCOPED_TRACE(module->ToString());\n-  EXPECT_FALSE(changed);\n-}\n-\n-TEST_F(SliceHoisterTest,\n-       DoesNotHoistSliceThroughAddIfAddTypeDoesNotMatchSliceType) {\n+// Dot is not an element-wise operation.\n+TEST_F(SliceHoisterTest, DoesNotHoistSliceThroughDot) {\n   absl::string_view module_str = R\"(\n     HloModule module\n     ENTRY main {\n-      add_op = f32[8,9] add(f32[8,9] parameter(0), f32[8,9] parameter(1))\n-      ROOT slice_op = f16[2,9] slice(f32[8,9] add_op), slice={[0:2], [0:9]}\n+      p0 = f32[8,10] parameter(0)\n+      p1 = f32[10,9] parameter(1)\n+      dot_op = f32[8,9] dot(p0, p1), lhs_contracting_dims={1}, rhs_contracting_dims={0}\n+      ROOT slice_op = f32[2,9] slice(f32[8,9] dot_op), slice={[0:2], [0:9]}\n     }\n   )\";\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n@@ -174,13 +157,15 @@ TEST_F(SliceHoisterTest,\n   EXPECT_FALSE(changed);\n }\n \n-TEST_F(SliceHoisterTest,\n-       DoesNotHoistSliceThroughAddIfAddTypeDoesNotMatchOperandsType) {\n+// Negate is not a binary operation.\n+// TODO(b/434724820): Hoist slices through element-wise unary operations.\n+TEST_F(SliceHoisterTest, DoesNotHoistSliceThroughNegate) {\n   absl::string_view module_str = R\"(\n     HloModule module\n     ENTRY main {\n-      add_op = f32[8,9] add(f16[8,9] parameter(0), f16[8,9] parameter(1))\n-      ROOT slice_op = f32[2,9] slice(f32[8,9] add_op), slice={[0:2], [0:9]}\n+      p0 = f32[8,9] parameter(0)\n+      neg_op = f32[8,9] negate(p0)\n+      ROOT slice_op = f32[2,9] slice(f32[8,9] neg_op), slice={[0:2], [0:9]}\n     }\n   )\";\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n@@ -194,48 +179,71 @@ TEST_F(SliceHoisterTest,\n   EXPECT_FALSE(changed);\n }\n \n-// Dot is not an element-wise operation.\n-TEST_F(SliceHoisterTest, DoesNotHoistSliceThroughDot) {\n-  absl::string_view module_str = R\"(\n+TEST_F(SliceHoisterTest, HoistSliceThroughTranspose) {\n+  const absl::string_view hlo_string = R\"(\n     HloModule module\n     ENTRY main {\n-      p0 = f32[8,10] parameter(0)\n-      p1 = f32[10,9] parameter(1)\n-      dot_op = f32[8,9] dot(p0, p1), lhs_contracting_dims={1}, rhs_contracting_dims={0}\n-      ROOT slice_op = f32[2,9] slice(f32[8,9] dot_op), slice={[0:2], [0:9]}\n+      param_0 = f32[2,3,5] parameter(0)\n+      transpose_op = f32[3,2,5] transpose(param_0), dimensions={1,0,2}\n+      ROOT slice = f32[2,1,2] slice(transpose_op), slice={[1:3], [0:1:2], [0:4:3]}\n     }\n-  )\";\n+    )\";\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(module_str));\n+                          ParseAndReturnVerifiedModule(hlo_string));\n \n   SliceHoister slice_hoister;\n   TF_ASSERT_OK_AND_ASSIGN(bool changed,\n                           RunHloPass(&slice_hoister, module.get()));\n \n   SCOPED_TRACE(module->ToString());\n-  EXPECT_FALSE(changed);\n+  EXPECT_TRUE(changed);\n+  const HloInstruction* transpose_op = nullptr;\n+  const HloInstruction* slice_op = nullptr;\n+  EXPECT_THAT(module->entry_computation()->root_instruction(),\n+              GmockMatch(m::Transpose(&transpose_op,\n+                                      m::Slice(&slice_op, m::Parameter(0)))));\n+  EXPECT_THAT(transpose_op->dimensions(), ElementsAre(1, 0, 2));\n+  EXPECT_THAT(slice_op->slice_starts(), ElementsAre(0, 1, 0));\n+  EXPECT_THAT(slice_op->slice_limits(), ElementsAre(1, 3, 4));\n+  EXPECT_THAT(slice_op->slice_strides(), ElementsAre(2, 1, 3));\n }\n \n-// Negate is not a binary operation.\n-// TODO(b/434724820): Hoist slices through element-wise unary operations.\n-TEST_F(SliceHoisterTest, DoesNotHoistSliceThroughNegate) {\n-  absl::string_view module_str = R\"(\n+TEST_F(SliceHoisterTest, HoistSliceThroughTransposeAndAdd) {\n+  const absl::string_view hlo_string = R\"(\n     HloModule module\n     ENTRY main {\n-      p0 = f32[8,9] parameter(0)\n-      neg_op = f32[8,9] negate(p0)\n-      ROOT slice_op = f32[2,9] slice(f32[8,9] neg_op), slice={[0:2], [0:9]}\n+      p0 = f32[2,3,5] parameter(0)\n+      p1 = f32[2,3,5] parameter(1)\n+      add_op = f32[2,3,5] add(p0, p1)\n+      transpose_op = f32[3,2,5] transpose(add_op), dimensions={1,0,2}\n+      ROOT slice_op = f32[2,1,2] slice(transpose_op), slice={[1:3], [0:1:2], [0:4:3]}\n     }\n-  )\";\n+    )\";\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> module,\n-                          ParseAndReturnVerifiedModule(module_str));\n+                          ParseAndReturnVerifiedModule(hlo_string));\n \n   SliceHoister slice_hoister;\n   TF_ASSERT_OK_AND_ASSIGN(bool changed,\n                           RunHloPass(&slice_hoister, module.get()));\n \n   SCOPED_TRACE(module->ToString());\n-  EXPECT_FALSE(changed);\n+  EXPECT_TRUE(changed);\n+  const HloInstruction* transpose_op = nullptr;\n+  const HloInstruction* p0_slice = nullptr;\n+  const HloInstruction* p1_slice = nullptr;\n+  EXPECT_THAT(\n+      module->entry_computation()->root_instruction(),\n+      GmockMatch(m::Transpose(&transpose_op,\n+                              m::Add(m::Slice(&p0_slice, m::Parameter(0)),\n+                                     m::Slice(&p1_slice, m::Parameter(1))))));\n+  EXPECT_THAT(transpose_op->dimensions(), ElementsAre(1, 0, 2));\n+  auto check_slice_attributes = [](const HloInstruction* slice) {\n+    EXPECT_THAT(slice->slice_starts(), ElementsAre(0, 1, 0));\n+    EXPECT_THAT(slice->slice_limits(), ElementsAre(1, 3, 4));\n+    EXPECT_THAT(slice->slice_strides(), ElementsAre(2, 1, 3));\n+  };\n+  check_slice_attributes(p0_slice);\n+  check_slice_attributes(p1_slice);\n }\n \n }  // anonymous namespace"
        }
    ],
    "stats": {
        "total": 208,
        "additions": 137,
        "deletions": 71
    }
}