{
    "author": "Varcho",
    "message": "[ReplicaGroupV3][Partitioner][Utilities] add functions for creating V3 replica groups from V2/V3 shardings.\n\nPiperOrigin-RevId: 840173065",
    "sha": "330aba81657ab5a3c4dbbf6139f26567fcdc831c",
    "files": [
        {
            "sha": "61ce724cc45a91180170f95db409e87269755119",
            "filename": "third_party/xla/xla/hlo/ir/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2FBUILD?ref=330aba81657ab5a3c4dbbf6139f26567fcdc831c",
            "patch": "@@ -206,8 +206,6 @@ cc_library(\n     deps = [\n         \":mesh_and_axis\",\n         \":tile_assignment\",\n-        \"//xla:shape_util\",\n-        \"//xla:util\",\n         \"//xla:xla_data_proto_cc\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/types:span\","
        },
        {
            "sha": "b55e051cc5cf80eb4d5f4edc4161d4742484ec94",
            "filename": "third_party/xla/xla/hlo/ir/hlo_sharding.h",
            "status": "modified",
            "additions": 14,
            "deletions": 9,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_sharding.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_sharding.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_sharding.h?ref=330aba81657ab5a3c4dbbf6139f26567fcdc831c",
            "patch": "@@ -130,6 +130,16 @@ class HloSharding {\n                        metadata);\n   }\n \n+  explicit HloSharding(NamedSharding named_sharding)\n+      : replicated_(false),\n+        maximal_(false),\n+        tuple_(false),\n+        manual_(false),\n+        unknown_(false),\n+        unreduced_(false),\n+        replicate_on_last_tile_dim_(false),\n+        named_sharding_(std::move(named_sharding)) {}\n+\n   // Creates a subgroup sharding with device-level tile assignment, the\n   // sharding type of each subgroup is defined by subgroup_types. When creating\n   // the HloSharding, subgroup dims of the same type will be merged.\n@@ -672,6 +682,10 @@ class HloSharding {\n \n   const ShardGroup& GetShardGroup() const { return shard_group_; }\n \n+  std::optional<NamedSharding> named_sharding() const {\n+    return named_sharding_;\n+  }\n+\n  private:\n   explicit HloSharding(bool manual, bool replicated, bool unknown,\n                        bool unreduced, absl::Span<const OpMetadata> metadata)\n@@ -738,15 +752,6 @@ class HloSharding {\n         unreduced_(false),\n         replicate_on_last_tile_dim_(false),\n         named_sharding_(std::nullopt) {}\n-  explicit HloSharding(NamedSharding named_sharding)\n-      : replicated_(false),\n-        maximal_(false),\n-        tuple_(false),\n-        manual_(false),\n-        unknown_(false),\n-        unreduced_(false),\n-        replicate_on_last_tile_dim_(false),\n-        named_sharding_(std::move(named_sharding)) {}\n \n   // Test-only constructor for sharding format code coverage. Copies the\n   // original sharding with provided tile assignment."
        },
        {
            "sha": "6c93bed8d40c742eb983220c229701a4bed2cd5e",
            "filename": "third_party/xla/xla/hlo/ir/named_sharding.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fnamed_sharding.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fnamed_sharding.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fnamed_sharding.h?ref=330aba81657ab5a3c4dbbf6139f26567fcdc831c",
            "patch": "@@ -60,6 +60,8 @@ class NamedSharding {\n     return !(*this == other);\n   }\n \n+  const Mesh& mesh() const { return mesh_; }\n+\n   // TODO(b/456212087): Add validation checks\n   explicit NamedSharding(Mesh mesh,\n                          absl::Span<const DimensionSharding> dim_shardings = {},"
        },
        {
            "sha": "ff5fdaf4ea5b0b848a39f2568e18abeb5d70835f",
            "filename": "third_party/xla/xla/service/spmd/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2FBUILD?ref=330aba81657ab5a3c4dbbf6139f26567fcdc831c",
            "patch": "@@ -52,6 +52,7 @@ cc_library(\n         \"//xla/hlo/builder:xla_computation\",\n         \"//xla/hlo/builder/lib:comparators\",\n         \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/ir:mesh_and_axis\",\n         \"//xla/hlo/ir:tile_assignment\",\n         \"//xla/hlo/parser:hlo_lexer\",\n         \"//xla/hlo/pass:hlo_pass\",\n@@ -424,6 +425,8 @@ xla_cc_test(\n     deps = [\n         \":spmd_partitioner\",\n         \"//xla/hlo/ir:hlo\",\n+        \"//xla/hlo/ir:mesh_and_axis\",\n+        \"//xla/hlo/ir:named_sharding\",\n         \"//xla/hlo/ir:tile_assignment\",\n         \"@com_google_googletest//:gtest_main\",\n     ],"
        },
        {
            "sha": "8821a09db044ea01449e6d683692b751c6fe0e19",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner_util.cc",
            "status": "modified",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.cc?ref=330aba81657ab5a3c4dbbf6139f26567fcdc831c",
            "patch": "@@ -25,6 +25,7 @@ limitations under the License.\n #include <numeric>\n #include <optional>\n #include <string>\n+#include <string_view>\n #include <utility>\n #include <vector>\n \n@@ -35,6 +36,7 @@ limitations under the License.\n #include \"absl/log/log.h\"\n #include \"absl/strings/str_cat.h\"\n #include \"absl/strings/str_join.h\"\n+#include \"absl/strings/string_view.h\"\n #include \"absl/types/span.h\"\n #include \"xla/array.h\"\n #include \"xla/comparison_util.h\"\n@@ -45,6 +47,7 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_module.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n #include \"xla/hlo/ir/hlo_sharding.h\"\n+#include \"xla/hlo/ir/mesh_and_axis.h\"\n #include \"xla/hlo/ir/replica_group.h\"\n #include \"xla/hlo/utils/hlo_sharding_util.h\"\n #include \"xla/layout.h\"\n@@ -3062,6 +3065,82 @@ std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsForReplication(\n                               transpose_iota_tile_assignment->transpose_perm());\n }\n \n+std::optional<Mesh> GetMeshFromSharding(const HloSharding& sharding) {\n+  // For V3 shardings, use the mesh associated with the named sharding.\n+  if (sharding.UseNamedShardingLeaf()) {\n+    return sharding.named_sharding()->mesh();\n+  }\n+\n+  // For V2 shardings, create the mesh from the tile assignment.\n+  if (sharding.tile_assignment().iota().has_value()) {\n+    TileAssignment device_assignment = sharding.tile_assignment();\n+    std::vector<std::string> axis_names(device_assignment.dimensions().size());\n+    std::vector<absl::string_view> axis_name_view;\n+    for (int64_t i = 0; i < device_assignment.dimensions().size(); ++i) {\n+      axis_names[i] = absl::StrCat(\"axis_\", i);\n+    }\n+    axis_name_view.assign(axis_names.begin(), axis_names.end());\n+    return Mesh(device_assignment, axis_name_view);\n+  }\n+\n+  // For V1 shardings, we cannot generate a mesh.\n+  return std::nullopt;\n+}\n+\n+std::optional<MeshAxesReplicaGroupList>\n+GetMeshAxesPartitionGroupsAcrossTargetDims(const HloSharding& sharding,\n+                                           std::vector<int64_t> target_dims,\n+                                           std::vector<int64_t> group_sizes) {\n+  CHECK_EQ(target_dims.size(), group_sizes.size())\n+      << \"target_dims and group_sizes must have the same size.\";\n+  if (target_dims.empty()) {\n+    return std::nullopt;\n+  }\n+\n+  // Use the mesh with named axes if HloShardingV3 is used. Otherwise, create a\n+  // mesh with generic axis names.\n+  std::optional<Mesh> mesh = GetMeshFromSharding(sharding);\n+  if (!mesh.has_value()) {\n+    return std::nullopt;\n+  }\n+\n+  CHECK_EQ(target_dims.size(), group_sizes.size());\n+  std::vector<AxisRef> axis_refs;\n+  axis_refs.reserve(target_dims.size());\n+  for (int64_t i = 0; i < target_dims.size(); ++i) {\n+    int64_t target_dim = target_dims[i];\n+    int64_t axis_size = mesh->axis_size(target_dim);\n+    int64_t group_size = group_sizes[i];\n+    if (axis_size == group_size) {\n+      axis_refs.push_back(AxisRef(target_dim));\n+      continue;\n+    }\n+    axis_refs.push_back(\n+        AxisRef(target_dim, {axis_size / group_size, group_size}));\n+  }\n+  return MeshAxesReplicaGroupList(mesh.value(), axis_refs);\n+}\n+\n+std::optional<MeshAxesReplicaGroupList>\n+GetMeshAxesPartitionGroupsForReplication(\n+    const HloSharding& sharding, absl::Span<const int64_t> replication_dims) {\n+  if (replication_dims.empty()) {\n+    return std::nullopt;\n+  }\n+  // Use the mesh with named axes if HloShardingV3 is used. Otherwise, create a\n+  // mesh with generic axis names.\n+  std::optional<Mesh> mesh = GetMeshFromSharding(sharding);\n+  if (!mesh.has_value()) {\n+    return std::nullopt;\n+  }\n+  std::vector<AxisRef> axis_refs;\n+  axis_refs.reserve(replication_dims.size());\n+  for (int64_t dim : replication_dims) {\n+    axis_refs.push_back(AxisRef(dim));\n+  }\n+  return MeshAxesReplicaGroupList(*mesh, axis_refs);\n+}\n+\n // Expands partition group list across all replicas. Expects that provided\n // partition group list utilizes all the partitions.\n CollectiveDeviceList ExpandPartitionGroupListAcrossReplicas("
        },
        {
            "sha": "01ca99b7f5edf745ddbd4e39abff1569bb108e21",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner_util.h",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util.h?ref=330aba81657ab5a3c4dbbf6139f26567fcdc831c",
            "patch": "@@ -626,6 +626,24 @@ std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsAcrossTargetDims(\n std::optional<IotaReplicaGroupList> GetIotaPartitionGroupsForReplication(\n     const HloSharding& sharding, absl::Span<const int64_t> replication_dims);\n \n+// Generates mesh-based (V3) partition groups across the provided target dims\n+// with the provided group sizes. The group sizes must divide their\n+// corresponding target dims. Assuming that the hlo sharding has mesh axis\n+// sizes [d1,d2,...dn], the target dims are [a,b,...d] and the group sizes are\n+// [ga,gb,...gd] then ga must divide da, gb must divide db, etc. This is\n+// equivalent to replicating across the list of sub-axes\n+// [a:(da/ga)ga, b:(db/gb)gb, ... d:(dn/gd)gd].\n+std::optional<MeshAxesReplicaGroupList>\n+GetMeshAxesPartitionGroupsAcrossTargetDims(const HloSharding& sharding,\n+                                           std::vector<int64_t> target_dims,\n+                                           std::vector<int64_t> group_sizes);\n+\n+// Generates mesh-based (V3) partition groups for replication across the axes\n+// corresponding to the provided replication dims.\n+std::optional<MeshAxesReplicaGroupList>\n+GetMeshAxesPartitionGroupsForReplication(\n+    const HloSharding& sharding, absl::Span<const int64_t> replication_dims);\n+\n // Expands partition group list across all replicas. Expects that provided\n // partition_group_list utilizes all the partitions.\n CollectiveDeviceList ExpandPartitionGroupListAcrossReplicas("
        },
        {
            "sha": "dff93ecb7d4f98139e0fa90df20ede5c31dbcbcf",
            "filename": "third_party/xla/xla/service/spmd/spmd_partitioner_util_test.cc",
            "status": "modified",
            "additions": 261,
            "deletions": 0,
            "changes": 261,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/330aba81657ab5a3c4dbbf6139f26567fcdc831c/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fspmd_partitioner_util_test.cc?ref=330aba81657ab5a3c4dbbf6139f26567fcdc831c",
            "patch": "@@ -22,6 +22,8 @@ limitations under the License.\n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"xla/hlo/ir/hlo_sharding.h\"\n+#include \"xla/hlo/ir/mesh_and_axis.h\"\n+#include \"xla/hlo/ir/named_sharding.h\"\n #include \"xla/hlo/ir/replica_group.h\"\n #include \"xla/hlo/ir/tile_assignment.h\"\n \n@@ -162,6 +164,265 @@ TEST(SPMDPartitionerUtilDeathTest, ExpandPartitionGroupListAcrossReplicas) {\n       \"num_partitions \\\\(50 vs\\\\. 60\\\\)\");\n }\n \n+TEST(SPMDPartitionerUtilTest, GetMeshAxesPartitionGroupsAcrossTargetDims) {\n+  // V2 Sharding\n+  HloSharding sharding_v2 = HloSharding::IotaTile({8, 8, 16});\n+  std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+      GetMeshAxesPartitionGroupsAcrossTargetDims(sharding_v2, {0, 1}, {4, 4});\n+  EXPECT_TRUE(v3_group_list.has_value());\n+  EXPECT_EQ(v3_group_list->num_replica_groups(), 64);\n+  EXPECT_EQ(v3_group_list->num_devices_per_group(), 16);\n+  EXPECT_EQ(v3_group_list->ToString(),\n+            \"@mesh<axis_0=8,axis_1=8,axis_2=16> {axis_0:(2)4,axis_1:(2)4}\");\n+\n+  // V3 Sharding (Will correctly reflect the real mesh axis names)\n+  NamedSharding named_sharding(Mesh({8, 8, 16}, {\"a\", \"b\", \"c\"}));\n+  HloSharding sharding_v3 = HloSharding(named_sharding);\n+  v3_group_list =\n+      GetMeshAxesPartitionGroupsAcrossTargetDims(sharding_v3, {0, 1}, {4, 4});\n+  EXPECT_TRUE(v3_group_list.has_value());\n+  EXPECT_EQ(v3_group_list->num_replica_groups(), 64);\n+  EXPECT_EQ(v3_group_list->num_devices_per_group(), 16);\n+  EXPECT_EQ(v3_group_list->ToString(), \"@mesh<a=8,b=8,c=16> {a:(2)4,b:(2)4}\");\n+}\n+\n+TEST(SPMDPartitionerUtilTest, GetMeshAxesPartitionGroupsForReplication) {\n+  // V2 Sharding\n+  HloSharding sharding_v2 = HloSharding::IotaTile({2, 2, 2});\n+  std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+      GetMeshAxesPartitionGroupsForReplication(sharding_v2, {1});\n+  EXPECT_TRUE(v3_group_list.has_value());\n+  EXPECT_EQ(v3_group_list->num_replica_groups(), 4);\n+  EXPECT_EQ(v3_group_list->num_devices_per_group(), 2);\n+  EXPECT_EQ(v3_group_list->ToString(),\n+            \"@mesh<axis_0=2,axis_1=2,axis_2=2> {axis_1}\");\n+\n+  // V3 Sharding (Will correctly reflect the real mesh axis names)\n+  NamedSharding named_sharding(Mesh({2, 2, 2}, {\"Q\", \"K\", \"V\"}));\n+  HloSharding sharding_v3 = HloSharding(named_sharding);\n+  v3_group_list = GetMeshAxesPartitionGroupsForReplication(sharding_v3, {1});\n+  EXPECT_TRUE(v3_group_list.has_value());\n+  EXPECT_EQ(v3_group_list->num_replica_groups(), 4);\n+  EXPECT_EQ(v3_group_list->num_devices_per_group(), 2);\n+  EXPECT_EQ(v3_group_list->ToString(), \"@mesh<Q=2,K=2,V=2> {K}\");\n+}\n+\n+TEST(SPMDPartitionerUtilTest, ReturnNulloptForEmptyReplicationDims) {\n+  HloSharding sharding_v2 = HloSharding::IotaTile({3, 5, 7});\n+  {\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsAcrossTargetDims(sharding_v2, {}, {});\n+    EXPECT_FALSE(v3_group_list.has_value());\n+  }\n+  {\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsForReplication(sharding_v2, {});\n+    EXPECT_FALSE(v3_group_list.has_value());\n+  }\n+}\n+\n+TEST(SPMDPartitionerUtilDeathTest, V3PartitionGroupsFailForInvalidInputs) {\n+  HloSharding sharding_v2 =\n+      HloSharding::IotaTile({2, 3, 6, 11, 23, 47, 106, 235});\n+  ASSERT_DEATH(\n+      {\n+        std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+            GetMeshAxesPartitionGroupsAcrossTargetDims(sharding_v2, {0, 3, 6},\n+                                                       {2, 2});\n+      },\n+      \"target_dims and group_sizes must\");\n+}\n+\n+TEST(SPMDPartitionerUtilTest,\n+     ValidateEqualityOfV2AndV3ReplicaGroupsAcrossTargetDims) {\n+  auto v2AndV3ReplicaGroupsMatch =\n+      [](std::optional<IotaReplicaGroupList> v2_group_list,\n+         std::optional<MeshAxesReplicaGroupList> v3_group_list,\n+         int64_t expected_num_replica_groups,\n+         int64_t expected_num_devices_per_group) {\n+        EXPECT_TRUE(v2_group_list.has_value());\n+        EXPECT_TRUE(v3_group_list.has_value());\n+        EXPECT_EQ(v2_group_list->num_replica_groups(),\n+                  expected_num_replica_groups);\n+        EXPECT_EQ(v3_group_list->num_replica_groups(),\n+                  expected_num_replica_groups);\n+        EXPECT_EQ(v2_group_list->num_devices_per_group(),\n+                  expected_num_devices_per_group);\n+        EXPECT_EQ(v3_group_list->num_devices_per_group(),\n+                  expected_num_devices_per_group);\n+        EXPECT_EQ(v2_group_list->flattened_replica_groups(),\n+                  v3_group_list->flattened_replica_groups());\n+      };\n+  {\n+    HloSharding sharding = HloSharding::IotaTile({32, 32});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsAcrossTargetDims(sharding, {0}, {16});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsAcrossTargetDims(sharding, {0}, {16});\n+    v2AndV3ReplicaGroupsMatch(v2_group_list, v3_group_list,\n+                              /*expected_num_replica_groups=*/(32 * 32) / (16),\n+                              /*expected_num_devices_per_group=*/16);\n+  }\n+  {\n+    HloSharding sharding = HloSharding::IotaTile({16, 64});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsAcrossTargetDims(sharding, {1}, {32});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsAcrossTargetDims(sharding, {1}, {32});\n+    v2AndV3ReplicaGroupsMatch(v2_group_list, v3_group_list,\n+                              /*expected_num_replica_groups=*/(16 * 64) / (32),\n+                              /*expected_num_devices_per_group=*/32);\n+  }\n+  {\n+    HloSharding sharding = HloSharding::IotaTile({8, 8, 16});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsAcrossTargetDims(sharding, {0, 1}, {4, 4});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsAcrossTargetDims(sharding, {0, 1}, {4, 4});\n+    v2AndV3ReplicaGroupsMatch(\n+        v2_group_list, v3_group_list,\n+        /*expected_num_replica_groups=*/(8 * 8 * 16) / (4 * 4),\n+        /*expected_num_devices_per_group=*/4 * 4);\n+  }\n+  {\n+    HloSharding sharding = HloSharding::IotaTile({16, 8, 16});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsAcrossTargetDims(sharding, {0, 2}, {8, 2});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsAcrossTargetDims(sharding, {0, 2}, {8, 2});\n+    v2AndV3ReplicaGroupsMatch(\n+        v2_group_list, v3_group_list,\n+        /*expected_num_replica_groups=*/(16 * 8 * 16) / (8 * 2),\n+        /*expected_num_devices_per_group=*/8 * 2);\n+  }\n+  {\n+    // Non-trivial v2 sharding.\n+    HloSharding sharding =\n+        HloSharding::IotaTile({6, 35}, {7, 10, 3}, {2, 1, 0});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsAcrossTargetDims(sharding, {0, 1}, {3, 5});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsAcrossTargetDims(sharding, {0, 1}, {3, 5});\n+    // V2 representation cannot create a compressed representation...\n+    EXPECT_FALSE(v2_group_list.has_value());\n+    // ... but V3 can via subaxes.\n+    EXPECT_TRUE(v3_group_list.has_value());\n+    EXPECT_EQ(v3_group_list->num_replica_groups(), (6 * 35) / (3 * 5));\n+    EXPECT_EQ(v3_group_list->num_devices_per_group(), 3 * 5);\n+  }\n+}\n+\n+TEST(SPMDPartitionerUtilTest,\n+     ValidateEqualityOfV2AndV3PartitionGroupsForReplication) {\n+  auto v2AndV3ReplicaGroupsMatch =\n+      [](std::optional<IotaReplicaGroupList> v2_group_list,\n+         std::optional<MeshAxesReplicaGroupList> v3_group_list,\n+         int64_t expected_num_replica_groups,\n+         int64_t expected_num_devices_per_group) {\n+        EXPECT_TRUE(v2_group_list.has_value());\n+        EXPECT_TRUE(v3_group_list.has_value());\n+        EXPECT_EQ(v2_group_list->num_replica_groups(),\n+                  expected_num_replica_groups);\n+        EXPECT_EQ(v3_group_list->num_replica_groups(),\n+                  expected_num_replica_groups);\n+        EXPECT_EQ(v2_group_list->num_devices_per_group(),\n+                  expected_num_devices_per_group);\n+        EXPECT_EQ(v3_group_list->num_devices_per_group(),\n+                  expected_num_devices_per_group);\n+        EXPECT_EQ(v2_group_list->flattened_replica_groups(),\n+                  v3_group_list->flattened_replica_groups());\n+      };\n+  {\n+    HloSharding sharding = HloSharding::IotaTile({32, 32});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsForReplication(sharding, {0});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsForReplication(sharding, {0});\n+    v2AndV3ReplicaGroupsMatch(v2_group_list, v3_group_list,\n+                              /*expected_num_replica_groups=*/32,\n+                              /*expected_num_devices_per_group=*/32);\n+  }\n+  {\n+    HloSharding sharding = HloSharding::IotaTile({16, 64});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsForReplication(sharding, {1});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsForReplication(sharding, {1});\n+    v2AndV3ReplicaGroupsMatch(v2_group_list, v3_group_list,\n+                              /*expected_num_replica_groups=*/16,\n+                              /*expected_num_devices_per_group=*/64);\n+  }\n+  {\n+    HloSharding sharding = HloSharding::IotaTile({8, 8, 16});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsForReplication(sharding, {0, 1});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsForReplication(sharding, {0, 1});\n+    v2AndV3ReplicaGroupsMatch(v2_group_list, v3_group_list,\n+                              /*expected_num_replica_groups=*/16,\n+                              /*expected_num_devices_per_group=*/64);\n+  }\n+  {\n+    HloSharding sharding = HloSharding::IotaTile({16, 8, 16});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsForReplication(sharding, {0, 2});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsForReplication(sharding, {0, 2});\n+    v2AndV3ReplicaGroupsMatch(v2_group_list, v3_group_list,\n+                              /*expected_num_replica_groups=*/8,\n+                              /*expected_num_devices_per_group=*/256);\n+  }\n+  // Test non-trivial v2 shardings.\n+  {\n+    HloSharding sharding =\n+        HloSharding::IotaTile({6, 35}, {7, 10, 3}, {2, 1, 0});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsForReplication(sharding, {0});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsForReplication(sharding, {0});\n+    v2AndV3ReplicaGroupsMatch(v2_group_list, v3_group_list,\n+                              /*expected_num_replica_groups=*/35,\n+                              /*expected_num_devices_per_group=*/6);\n+    EXPECT_EQ(v2_group_list->ToString(), \"[35,6]<=[7,2,5,3]T(2,0,3,1)\");\n+  }\n+  {\n+    HloSharding sharding =\n+        HloSharding::IotaTile({6, 35}, {7, 10, 3}, {2, 1, 0});\n+    std::optional<IotaReplicaGroupList> v2_group_list =\n+        GetIotaPartitionGroupsForReplication(sharding, {1});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list =\n+        GetMeshAxesPartitionGroupsForReplication(sharding, {1});\n+    v2AndV3ReplicaGroupsMatch(v2_group_list, v3_group_list,\n+                              /*expected_num_replica_groups=*/6,\n+                              /*expected_num_devices_per_group=*/35);\n+    EXPECT_EQ(v2_group_list->ToString(), \"[6,35]<=[7,10,3]T(2,1,0)\");\n+  }\n+  // Validate order of replication dims doesn't impact groups.\n+  {\n+    HloSharding sharding = HloSharding::IotaTile({2, 3, 5, 7, 11});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list_1 =\n+        GetMeshAxesPartitionGroupsForReplication(sharding, {0, 2, 3});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list_2 =\n+        GetMeshAxesPartitionGroupsForReplication(sharding, {3, 0, 2});\n+    EXPECT_TRUE(v3_group_list_1.has_value());\n+    EXPECT_TRUE(v3_group_list_2.has_value());\n+    EXPECT_EQ(v3_group_list_1->flattened_replica_groups(),\n+              v3_group_list_2->flattened_replica_groups());\n+  }\n+  {\n+    HloSharding sharding =\n+        HloSharding::IotaTile({3, 7, 2, 5}, {7, 10, 3}, {1, 2, 0});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list_1 =\n+        GetMeshAxesPartitionGroupsForReplication(sharding, {0, 2});\n+    std::optional<MeshAxesReplicaGroupList> v3_group_list_2 =\n+        GetMeshAxesPartitionGroupsForReplication(sharding, {2, 0});\n+    EXPECT_TRUE(v3_group_list_1.has_value());\n+    EXPECT_TRUE(v3_group_list_2.has_value());\n+    EXPECT_EQ(v3_group_list_1->flattened_replica_groups(),\n+              v3_group_list_2->flattened_replica_groups());\n+  }\n+}\n+\n }  // namespace\n }  // namespace spmd\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 388,
        "additions": 377,
        "deletions": 11
    }
}