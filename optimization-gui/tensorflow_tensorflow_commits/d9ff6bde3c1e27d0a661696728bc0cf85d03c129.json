{
    "author": "tensorflower-gardener",
    "message": "Merge pull request #99380 from DottsGit:fix/ValueError-on-3-channels-image-decode\n\nPiperOrigin-RevId: 810046991",
    "sha": "d9ff6bde3c1e27d0a661696728bc0cf85d03c129",
    "files": [
        {
            "sha": "087af6a842fc86882f56b724564a23264170e232",
            "filename": "tensorflow/python/ops/image_ops_impl.py",
            "status": "modified",
            "additions": 23,
            "deletions": 13,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d9ff6bde3c1e27d0a661696728bc0cf85d03c129/tensorflow%2Fpython%2Fops%2Fimage_ops_impl.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d9ff6bde3c1e27d0a661696728bc0cf85d03c129/tensorflow%2Fpython%2Fops%2Fimage_ops_impl.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fops%2Fimage_ops_impl.py?ref=d9ff6bde3c1e27d0a661696728bc0cf85d03c129",
            "patch": "@@ -3323,21 +3323,31 @@ def decode_image(contents,\n   \"\"\"\n   with ops.name_scope(name, 'decode_image'):\n     channels = 0 if channels is None else channels\n+    original_dtype = dtype\n     if dtype not in [dtypes.float32, dtypes.uint8, dtypes.uint16]:\n-      dest_dtype = dtype\n-      dtype = dtypes.uint16\n-      return convert_image_dtype(\n-          gen_image_ops.decode_image(\n-              contents=contents,\n-              channels=channels,\n-              expand_animations=expand_animations,\n-              dtype=dtype), dest_dtype)\n+      dtype_for_decode = dtypes.uint16\n     else:\n-      return gen_image_ops.decode_image(\n-          contents=contents,\n-          channels=channels,\n-          expand_animations=expand_animations,\n-          dtype=dtype)\n+      dtype_for_decode = dtype\n+\n+    image = gen_image_ops.decode_image(\n+        contents=contents,\n+        channels=channels,\n+        expand_animations=expand_animations,\n+        dtype=dtype_for_decode,\n+    )\n+\n+    if dtype_for_decode != original_dtype:\n+      image = convert_image_dtype(image, original_dtype)\n+\n+    if not expand_animations:\n+      # If not expanding animations, the output is always 3D.\n+      if channels != 0:\n+        image.set_shape([None, None, channels])\n+      else:\n+        # We can still set the rank, which is what matters for the resize op.\n+        image.set_shape([None, None, None])\n+\n+    return image\n \n \n @tf_export('image.total_variation')"
        },
        {
            "sha": "a1bdc1931e12aaae7089de4f6875a24939dae2ef",
            "filename": "tensorflow/python/ops/image_ops_test.py",
            "status": "modified",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d9ff6bde3c1e27d0a661696728bc0cf85d03c129/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d9ff6bde3c1e27d0a661696728bc0cf85d03c129/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2Fops%2Fimage_ops_test.py?ref=d9ff6bde3c1e27d0a661696728bc0cf85d03c129",
            "patch": "@@ -6613,6 +6613,116 @@ def testGifFramesWithDiffSize(self):\n     image0, image1_0 = self.evaluate([image0, image1_0])\n     self.assertAllEqual(image0, image1_0)\n \n+  def testDecodeImageShapeInferenceInDataPipeline(self):\n+    \"\"\"Test that decode_image sets proper shape inference in tf.data pipelines.\n+\n+    This test verifies the fix for the issue where tf.image.decode_image\n+    followed by tf.image.resize would fail with \"ValueError: 'images' contains\n+    no shape\" when used in tf.data.Dataset.map() operations.\n+\n+    The fix ensures that when expand_animations=False, the output tensor shape\n+    is properly set to [None, None, channels] for known channel counts or\n+    [None, None, None] for unknown channel counts, enabling proper shape\n+    inference for subsequent operations like resize.\n+    \"\"\"\n+    # Create 2x2 RGB test image.\n+    test_image = constant_op.constant(\n+        [[[255, 0, 0], [0, 255, 0]], [[0, 0, 255], [255, 255, 0]]],\n+        dtype=dtypes.uint8,\n+    )\n+    jpeg_bytes = gen_image_ops.encode_jpeg(test_image)\n+\n+    def process_image_fixed(image_bytes):\n+      \"\"\"Process function using expand_animations=False for shape inference.\"\"\"\n+      decoded = image_ops.decode_image(\n+          image_bytes, channels=3, expand_animations=False\n+      )\n+      resized = image_ops.resize_images(decoded, [224, 224])\n+      return resized\n+\n+    with self.cached_session():\n+      # Test tf.data pipeline with decode_image + resize.\n+      dataset_fixed = dataset_ops.Dataset.from_tensor_slices([jpeg_bytes])\n+      dataset_fixed = dataset_fixed.map(process_image_fixed)\n+\n+      # Use get_single_element for graph mode compatibility.\n+      processed_image = get_single_element.get_single_element(dataset_fixed)\n+      processed_image_val = self.evaluate(processed_image)\n+      self.assertEqual(processed_image_val.shape, (224, 224, 3))\n+\n+      # Verify shape inference with expand_animations=False.\n+      decoded_fixed = image_ops.decode_image(\n+          jpeg_bytes, channels=3, expand_animations=False\n+      )\n+      self.assertEqual(decoded_fixed.shape.rank, 3)\n+\n+      # Check shape compatibility in both graph and eager modes.\n+      shape_list = decoded_fixed.get_shape().as_list()\n+      self.assertEqual(shape_list[2], 3)\n+      self.assertTrue(shape_list[0] is None or shape_list[0] == 2)\n+      self.assertTrue(shape_list[1] is None or shape_list[1] == 2)\n+\n+      # Test different channel configurations.\n+      # Note: decode_image only supports channels 0, 1, 3, 4 (not 2).\n+      for channels in [0, 1, 3, 4]:\n+        if channels == 0:\n+          # Use auto-detection with RGB JPEG.\n+          test_bytes = jpeg_bytes\n+        elif channels == 1:\n+          # Create grayscale test image.\n+          gray_image = constant_op.constant(\n+              [[128, 64], [192, 32]], dtype=dtypes.uint8\n+          )\n+          gray_image = array_ops.expand_dims(gray_image, -1)\n+          test_bytes = gen_image_ops.encode_png(gray_image)\n+        elif channels == 4:\n+          # Create RGBA test image using PNG (JPEG doesn't support 4 channels).\n+          rgba_image = constant_op.constant(\n+              [\n+                  [[255, 0, 0, 255], [0, 255, 0, 128]],\n+                  [[0, 0, 255, 64], [255, 255, 0, 192]],\n+              ],\n+              dtype=dtypes.uint8,\n+          )\n+          test_bytes = gen_image_ops.encode_png(rgba_image)\n+        else:\n+          # Use RGB JPEG for 3-channel tests.\n+          test_bytes = jpeg_bytes\n+\n+        decoded = image_ops.decode_image(\n+            test_bytes, channels=channels, expand_animations=False\n+        )\n+        self.assertEqual(decoded.shape.rank, 3)\n+\n+        if channels == 0:\n+          # Auto-detection case - shape depends on the image format used.\n+          expected_shape = [None, None, None]\n+        elif channels <= 4:\n+          expected_shape = [None, None, channels]\n+        else:\n+          expected_shape = [None, None, None]\n+\n+        # Shape must be compatible for resize operations.\n+        self.assertTrue(decoded.shape.is_compatible_with(expected_shape))\n+\n+      # Test automatic channel detection.\n+      decoded_unknown = image_ops.decode_image(\n+          jpeg_bytes, expand_animations=False\n+      )\n+      self.assertEqual(decoded_unknown.shape.rank, 3)\n+\n+      # Check shape compatibility with automatic channel detection.\n+      shape_list_unknown = decoded_unknown.get_shape().as_list()\n+      self.assertTrue(\n+          shape_list_unknown[0] is None or shape_list_unknown[0] == 2\n+      )\n+      self.assertTrue(\n+          shape_list_unknown[1] is None or shape_list_unknown[1] == 2\n+      )\n+      self.assertTrue(\n+          shape_list_unknown[2] is None or shape_list_unknown[2] == 3\n+      )\n+\n \n if __name__ == \"__main__\":\n   googletest.main()"
        }
    ],
    "stats": {
        "total": 146,
        "additions": 133,
        "deletions": 13
    }
}