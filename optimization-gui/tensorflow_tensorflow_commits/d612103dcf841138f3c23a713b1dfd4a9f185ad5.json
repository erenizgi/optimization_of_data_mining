{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 848075753",
    "sha": "d612103dcf841138f3c23a713b1dfd4a9f185ad5",
    "files": [
        {
            "sha": "85c7ef3d268372dcf7d877a1f99c98aa08dc7c4e",
            "filename": "tensorflow/core/lib/jpeg/jpeg_mem.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 22,
            "changes": 44,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d612103dcf841138f3c23a713b1dfd4a9f185ad5/tensorflow%2Fcore%2Flib%2Fjpeg%2Fjpeg_mem.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d612103dcf841138f3c23a713b1dfd4a9f185ad5/tensorflow%2Fcore%2Flib%2Fjpeg%2Fjpeg_mem.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fjpeg%2Fjpeg_mem.cc?ref=d612103dcf841138f3c23a713b1dfd4a9f185ad5",
            "patch": "@@ -58,7 +58,7 @@ class FewerArgsForCompiler {\n  public:\n   FewerArgsForCompiler(int datasize, const UncompressFlags& flags,\n                        int64_t* nwarn,\n-                       std::function<uint8*(int, int, int)> allocate_output)\n+                       std::function<uint8_t*(int, int, int)> allocate_output)\n       : datasize_(datasize),\n         flags_(flags),\n         pnwarn_(nwarn),\n@@ -72,7 +72,7 @@ class FewerArgsForCompiler {\n   const int datasize_;\n   const UncompressFlags flags_;\n   int64_t* const pnwarn_;\n-  std::function<uint8*(int, int, int)> allocate_output_;\n+  std::function<uint8_t*(int, int, int)> allocate_output_;\n   int height_read_;  // number of scanline lines successfully read\n   int height_;\n   int stride_;\n@@ -95,7 +95,7 @@ bool IsCropWindowValid(const UncompressFlags& flags, int input_image_width,\n void no_print(j_common_ptr cinfo) {}\n #endif\n \n-uint8* UncompressLow(const void* srcdata, FewerArgsForCompiler* argball) {\n+uint8_t* UncompressLow(const void* srcdata, FewerArgsForCompiler* argball) {\n   // unpack the argball\n   const int datasize = argball->datasize_;\n   const auto& flags = argball->flags_;\n@@ -252,8 +252,8 @@ uint8* UncompressLow(const void* srcdata, FewerArgsForCompiler* argball) {\n                                         target_output_height, components);\n   }\n #else\n-  uint8* dstdata = argball->allocate_output_(target_output_width,\n-                                             target_output_height, components);\n+  uint8_t* dstdata = argball->allocate_output_(\n+      target_output_width, target_output_height, components);\n #endif\n   if (dstdata == nullptr) {\n     jpeg_destroy_decompress(&cinfo);\n@@ -509,12 +509,12 @@ uint8* UncompressLow(const void* srcdata, FewerArgsForCompiler* argball) {\n //  associated libraries aren't good enough to guarantee that 7\n //  parameters won't get clobbered by the longjmp.  So we help\n //  it out a little.\n-uint8* Uncompress(const void* srcdata, int datasize,\n-                  const UncompressFlags& flags, int64_t* nwarn,\n-                  std::function<uint8*(int, int, int)> allocate_output) {\n+uint8_t* Uncompress(const void* srcdata, int datasize,\n+                    const UncompressFlags& flags, int64_t* nwarn,\n+                    std::function<uint8_t*(int, int, int)> allocate_output) {\n   FewerArgsForCompiler argball(datasize, flags, nwarn,\n                                std::move(allocate_output));\n-  uint8* const dstdata = UncompressLow(srcdata, &argball);\n+  uint8_t* const dstdata = UncompressLow(srcdata, &argball);\n \n   const float fraction_read =\n       argball.height_ == 0\n@@ -530,25 +530,25 @@ uint8* Uncompress(const void* srcdata, int datasize,\n   // set the unread pixels to black\n   if (argball.height_read_ != argball.height_) {\n     const int first_bad_line = argball.height_read_;\n-    uint8* start = dstdata + first_bad_line * argball.stride_;\n+    uint8_t* start = dstdata + first_bad_line * argball.stride_;\n     const int nbytes = (argball.height_ - first_bad_line) * argball.stride_;\n     memset(static_cast<void*>(start), 0, nbytes);\n   }\n \n   return dstdata;\n }\n \n-uint8* Uncompress(const void* srcdata, int datasize,\n-                  const UncompressFlags& flags, int* pwidth, int* pheight,\n-                  int* pcomponents, int64_t* nwarn) {\n-  uint8* buffer = nullptr;\n-  uint8* result =\n+uint8_t* Uncompress(const void* srcdata, int datasize,\n+                    const UncompressFlags& flags, int* pwidth, int* pheight,\n+                    int* pcomponents, int64_t* nwarn) {\n+  uint8_t* buffer = nullptr;\n+  uint8_t* result =\n       Uncompress(srcdata, datasize, flags, nwarn,\n                  [=, &buffer](int width, int height, int components) {\n                    if (pwidth != nullptr) *pwidth = width;\n                    if (pheight != nullptr) *pheight = height;\n                    if (pcomponents != nullptr) *pcomponents = components;\n-                   buffer = new uint8[height * width * components];\n+                   buffer = new uint8_t[height * width * components];\n                    return buffer;\n                  });\n   if (!result) delete[] buffer;\n@@ -599,7 +599,7 @@ bool GetImageInfo(const void* srcdata, int datasize, int* width, int* height,\n // Compression\n \n namespace {\n-bool CompressInternal(const uint8* srcdata, int width, int height,\n+bool CompressInternal(const uint8_t* srcdata, int width, int height,\n                       const CompressFlags& flags, tstring* output) {\n   if (output == nullptr) {\n     LOG(ERROR) << \"Output buffer is null: \";\n@@ -711,7 +711,7 @@ bool CompressInternal(const uint8* srcdata, int width, int height,\n   if (!flags.xmp_metadata.empty()) {\n     // XMP metadata is embedded in the APP1 tag of JPEG and requires this\n     // namespace header string (null-terminated)\n-    const string name_space = \"http://ns.adobe.com/xap/1.0/\";\n+    const std::string name_space = \"http://ns.adobe.com/xap/1.0/\";\n     const int name_space_length = name_space.size();\n     const int metadata_length = flags.xmp_metadata.size();\n     const int packet_length = metadata_length + name_space_length + 1;\n@@ -736,8 +736,8 @@ bool CompressInternal(const uint8* srcdata, int width, int height,\n       new JSAMPLE[width * cinfo.input_components]);\n   while (cinfo.next_scanline < cinfo.image_height) {\n     JSAMPROW row_pointer[1];  // pointer to JSAMPLE row[s]\n-    const uint8* r = &srcdata[cinfo.next_scanline * in_stride];\n-    uint8* p = static_cast<uint8*>(row_temp.get());\n+    const uint8_t* r = &srcdata[cinfo.next_scanline * in_stride];\n+    uint8_t* p = static_cast<uint8_t*>(row_temp.get());\n     switch (flags.format) {\n       case FORMAT_RGBA: {\n         for (int i = 0; i < width; ++i, p += 3, r += 4) {\n@@ -777,14 +777,14 @@ bool CompressInternal(const uint8* srcdata, int width, int height,\n \n bool Compress(const void* srcdata, int width, int height,\n               const CompressFlags& flags, tstring* output) {\n-  return CompressInternal(static_cast<const uint8*>(srcdata), width, height,\n+  return CompressInternal(static_cast<const uint8_t*>(srcdata), width, height,\n                           flags, output);\n }\n \n tstring Compress(const void* srcdata, int width, int height,\n                  const CompressFlags& flags) {\n   tstring temp;\n-  CompressInternal(static_cast<const uint8*>(srcdata), width, height, flags,\n+  CompressInternal(static_cast<const uint8_t*>(srcdata), width, height, flags,\n                    &temp);\n   // If CompressInternal fails, temp will be empty.\n   return temp;"
        },
        {
            "sha": "569abb6b79bf7404177bbaddc2847f5527388ead",
            "filename": "tensorflow/core/lib/jpeg/jpeg_mem.h",
            "status": "modified",
            "additions": 7,
            "deletions": 7,
            "changes": 14,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d612103dcf841138f3c23a713b1dfd4a9f185ad5/tensorflow%2Fcore%2Flib%2Fjpeg%2Fjpeg_mem.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d612103dcf841138f3c23a713b1dfd4a9f185ad5/tensorflow%2Fcore%2Flib%2Fjpeg%2Fjpeg_mem.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fjpeg%2Fjpeg_mem.h?ref=d612103dcf841138f3c23a713b1dfd4a9f185ad5",
            "patch": "@@ -87,19 +87,19 @@ struct UncompressFlags {\n // The function returns a pointer to the raw uncompressed data or NULL if\n // there was an error. The caller of the function is responsible for\n // freeing the memory (using delete []).\n-uint8* Uncompress(const void* srcdata, int datasize,\n-                  const UncompressFlags& flags, int* width, int* height,\n-                  int* components,  // Output only: useful with autodetect\n-                  int64_t* nwarn);\n+uint8_t* Uncompress(const void* srcdata, int datasize,\n+                    const UncompressFlags& flags, int* width, int* height,\n+                    int* components,  // Output only: useful with autodetect\n+                    int64_t* nwarn);\n \n // Version of Uncompress that allocates memory via a callback.  The callback\n // arguments are (width, height, components).  If the size is known ahead of\n // time this function can return an existing buffer; passing a callback allows\n // the buffer to be shaped based on the JPEG header.  The caller is responsible\n // for freeing the memory *even along error paths*.\n-uint8* Uncompress(const void* srcdata, int datasize,\n-                  const UncompressFlags& flags, int64_t* nwarn,\n-                  std::function<uint8*(int, int, int)> allocate_output);\n+uint8_t* Uncompress(const void* srcdata, int datasize,\n+                    const UncompressFlags& flags, int64_t* nwarn,\n+                    std::function<uint8_t*(int, int, int)> allocate_output);\n \n // Read jpeg header and get image information.  Returns true on success.\n // The width, height, and components points may be null."
        },
        {
            "sha": "a8c5401bf52e011c327c5d423ddfac98a3c350e7",
            "filename": "tensorflow/core/lib/jpeg/jpeg_mem_unittest.cc",
            "status": "modified",
            "additions": 51,
            "deletions": 50,
            "changes": 101,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d612103dcf841138f3c23a713b1dfd4a9f185ad5/tensorflow%2Fcore%2Flib%2Fjpeg%2Fjpeg_mem_unittest.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d612103dcf841138f3c23a713b1dfd4a9f185ad5/tensorflow%2Fcore%2Flib%2Fjpeg%2Fjpeg_mem_unittest.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fjpeg%2Fjpeg_mem_unittest.cc?ref=d612103dcf841138f3c23a713b1dfd4a9f185ad5",
            "patch": "@@ -41,12 +41,12 @@ namespace {\n \n const char kTestData[] = \"tensorflow/core/lib/jpeg/testdata/\";\n \n-int ComputeSumAbsoluteDifference(const uint8* a, const uint8* b, int width,\n+int ComputeSumAbsoluteDifference(const uint8_t* a, const uint8_t* b, int width,\n                                  int height, int a_stride, int b_stride) {\n   int totalerr = 0;\n   for (int i = 0; i < height; i++) {\n-    const uint8* const pa = a + i * a_stride;\n-    const uint8* const pb = b + i * b_stride;\n+    const uint8_t* const pa = a + i * a_stride;\n+    const uint8_t* const pb = b + i * b_stride;\n     for (int j = 0; j < 3 * width; j++) {\n       totalerr += abs(static_cast<int>(pa[j]) - static_cast<int>(pb[j]));\n     }\n@@ -55,20 +55,21 @@ int ComputeSumAbsoluteDifference(const uint8* a, const uint8* b, int width,\n }\n \n // Reads the contents of the file into output\n-void ReadFileToStringOrDie(Env* env, const string& filename, string* output) {\n+void ReadFileToStringOrDie(Env* env, const std::string& filename,\n+                           std::string* output) {\n   TF_CHECK_OK(ReadFileToString(env, filename, output));\n }\n \n-void TestJPEG(Env* env, const string& jpegfile) {\n+void TestJPEG(Env* env, const std::string& jpegfile) {\n   // Read the data from the jpeg file into memory\n-  string jpeg;\n+  std::string jpeg;\n   ReadFileToStringOrDie(env, jpegfile, &jpeg);\n   const int fsize = jpeg.size();\n-  const uint8* const temp = absl::bit_cast<const uint8*>(jpeg.data());\n+  const uint8_t* const temp = absl::bit_cast<const uint8_t*>(jpeg.data());\n \n   // Try partial decoding (half of the data)\n   int w, h, c;\n-  std::unique_ptr<uint8[]> imgdata;\n+  std::unique_ptr<uint8_t[]> imgdata;\n \n   UncompressFlags flags;\n   flags.components = 3;\n@@ -91,7 +92,7 @@ void TestJPEG(Env* env, const string& jpegfile) {\n \n TEST(JpegMemTest, Jpeg) {\n   Env* env = Env::Default();\n-  const string data_path = kTestData;\n+  const std::string data_path = kTestData;\n \n   // Name of a valid jpeg file on the disk\n   TestJPEG(env, data_path + \"jpeg_merge_test1.jpg\");\n@@ -100,16 +101,16 @@ TEST(JpegMemTest, Jpeg) {\n   TestJPEG(env, data_path + \"jpeg_merge_test1_cmyk.jpg\");\n }\n \n-void TestCropAndDecodeJpeg(Env* env, const string& jpegfile,\n+void TestCropAndDecodeJpeg(Env* env, const std::string& jpegfile,\n                            const UncompressFlags& default_flags) {\n   // Read the data from the jpeg file into memory\n-  string jpeg;\n+  std::string jpeg;\n   ReadFileToStringOrDie(env, jpegfile, &jpeg);\n   const int fsize = jpeg.size();\n-  const auto* temp = absl::bit_cast<const uint8*>(jpeg.data());\n+  const auto* temp = absl::bit_cast<const uint8_t*>(jpeg.data());\n \n   // Decode the whole image.\n-  std::unique_ptr<uint8[]> imgdata1;\n+  std::unique_ptr<uint8_t[]> imgdata1;\n   int w1, h1, c1;\n   {\n     UncompressFlags flags = default_flags;\n@@ -119,13 +120,13 @@ void TestCropAndDecodeJpeg(Env* env, const string& jpegfile,\n       // If stride is not zero, the default allocator would fail because it\n       // allocate w*h*c bytes, but the actual required bytes should be stride*h.\n       // Therefore, we provide a specialized allocator here.\n-      uint8* buffer = nullptr;\n+      uint8_t* buffer = nullptr;\n       imgdata1.reset(Uncompress(temp, fsize, flags, nullptr,\n                                 [&](int width, int height, int components) {\n                                   w1 = width;\n                                   h1 = height;\n                                   c1 = components;\n-                                  buffer = new uint8[flags.stride * height];\n+                                  buffer = new uint8_t[flags.stride * height];\n                                   return buffer;\n                                 }));\n     }\n@@ -134,7 +135,7 @@ void TestCropAndDecodeJpeg(Env* env, const string& jpegfile,\n \n   auto check_crop_and_decode_func = [&](int crop_x, int crop_y, int crop_width,\n                                         int crop_height) {\n-    std::unique_ptr<uint8[]> imgdata2;\n+    std::unique_ptr<uint8_t[]> imgdata2;\n     int w, h, c;\n     UncompressFlags flags = default_flags;\n     flags.crop = true;\n@@ -145,13 +146,13 @@ void TestCropAndDecodeJpeg(Env* env, const string& jpegfile,\n     if (flags.stride == 0) {\n       imgdata2.reset(Uncompress(temp, fsize, flags, &w, &h, &c, nullptr));\n     } else {\n-      uint8* buffer = nullptr;\n+      uint8_t* buffer = nullptr;\n       imgdata2.reset(Uncompress(temp, fsize, flags, nullptr,\n                                 [&](int width, int height, int components) {\n                                   w = width;\n                                   h = height;\n                                   c = components;\n-                                  buffer = new uint8[flags.stride * height];\n+                                  buffer = new uint8_t[flags.stride * height];\n                                   return buffer;\n                                 }));\n     }\n@@ -164,8 +165,8 @@ void TestCropAndDecodeJpeg(Env* env, const string& jpegfile,\n     const int stride1 = (flags.stride != 0) ? flags.stride : w1 * c;\n     const int stride2 = (flags.stride != 0) ? flags.stride : w * c;\n     for (int i = 0; i < crop_height; i++) {\n-      const uint8* p1 = &imgdata1[(i + crop_y) * stride1 + crop_x * c];\n-      const uint8* p2 = &imgdata2[i * stride2];\n+      const uint8_t* p1 = &imgdata1[(i + crop_y) * stride1 + crop_x * c];\n+      const uint8_t* p2 = &imgdata2[i * stride2];\n \n       for (int j = 0; j < c * w; j++) {\n         ASSERT_EQ(p1[j], p2[j])\n@@ -185,7 +186,7 @@ void TestCropAndDecodeJpeg(Env* env, const string& jpegfile,\n \n TEST(JpegMemTest, CropAndDecodeJpeg) {\n   Env* env = Env::Default();\n-  const string data_path = kTestData;\n+  const std::string data_path = kTestData;\n   UncompressFlags flags;\n \n   // Test basic flags for jpeg and cmyk jpeg.\n@@ -195,7 +196,7 @@ TEST(JpegMemTest, CropAndDecodeJpeg) {\n \n TEST(JpegMemTest, CropAndDecodeJpegWithRatio) {\n   Env* env = Env::Default();\n-  const string data_path = kTestData;\n+  const std::string data_path = kTestData;\n   UncompressFlags flags;\n   for (int ratio : {1, 2, 4, 8}) {\n     flags.ratio = ratio;\n@@ -205,7 +206,7 @@ TEST(JpegMemTest, CropAndDecodeJpegWithRatio) {\n \n TEST(JpegMemTest, CropAndDecodeJpegWithComponents) {\n   Env* env = Env::Default();\n-  const string data_path = kTestData;\n+  const std::string data_path = kTestData;\n   UncompressFlags flags;\n   for (const int components : {0, 1, 3}) {\n     flags.components = components;\n@@ -215,21 +216,21 @@ TEST(JpegMemTest, CropAndDecodeJpegWithComponents) {\n \n TEST(JpegMemTest, CropAndDecodeJpegWithUpScaling) {\n   Env* env = Env::Default();\n-  const string data_path = kTestData;\n+  const std::string data_path = kTestData;\n   UncompressFlags flags;\n   flags.fancy_upscaling = true;\n   TestCropAndDecodeJpeg(env, data_path + \"jpeg_merge_test1.jpg\", flags);\n }\n \n TEST(JpegMemTest, CropAndDecodeJpegWithStride) {\n   Env* env = Env::Default();\n-  const string data_path = kTestData;\n+  const std::string data_path = kTestData;\n \n   // Read the data from the jpeg file into memory\n-  string jpeg;\n+  std::string jpeg;\n   ReadFileToStringOrDie(env, data_path + \"jpeg_merge_test1.jpg\", &jpeg);\n   const int fsize = jpeg.size();\n-  const auto* temp = absl::bit_cast<const uint8*>(jpeg.data());\n+  const auto* temp = absl::bit_cast<const uint8_t*>(jpeg.data());\n \n   int w, h, c;\n   ASSERT_TRUE(GetImageInfo(temp, fsize, &w, &h, &c));\n@@ -244,9 +245,9 @@ TEST(JpegMemTest, CropAndDecodeJpegWithStride) {\n   TestCropAndDecodeJpeg(env, data_path + \"jpeg_merge_test1.jpg\", flags);\n }\n \n-void CheckInvalidCropWindowFailed(const uint8* const temp, int fsize, int x,\n+void CheckInvalidCropWindowFailed(const uint8_t* const temp, int fsize, int x,\n                                   int y, int w, int h) {\n-  std::unique_ptr<uint8[]> imgdata;\n+  std::unique_ptr<uint8_t[]> imgdata;\n   int ww, hh, cc;\n   UncompressFlags flags;\n   flags.components = 3;\n@@ -261,13 +262,13 @@ void CheckInvalidCropWindowFailed(const uint8* const temp, int fsize, int x,\n \n TEST(JpegMemTest, CropAndDecodeJpegWithInvalidCropWindow) {\n   Env* env = Env::Default();\n-  const string data_path = kTestData;\n+  const std::string data_path = kTestData;\n \n   // Read the data from the jpeg file into memory\n-  string jpeg;\n+  std::string jpeg;\n   ReadFileToStringOrDie(env, data_path + \"jpeg_merge_test1.jpg\", &jpeg);\n   const int fsize = jpeg.size();\n-  const auto* temp = absl::bit_cast<const uint8*>(jpeg.data());\n+  const auto* temp = absl::bit_cast<const uint8_t*>(jpeg.data());\n \n   int w, h, c;\n   ASSERT_TRUE(GetImageInfo(temp, fsize, &w, &h, &c));\n@@ -293,27 +294,27 @@ TEST(JpegMemTest, Jpeg2) {\n   const int in_w = 256;\n   const int in_h = 256;\n   const int stride1 = 3 * in_w;\n-  const std::unique_ptr<uint8[]> refdata1(new uint8[stride1 * in_h]);\n+  const std::unique_ptr<uint8_t[]> refdata1(new uint8_t[stride1 * in_h]);\n   for (int i = 0; i < in_h; i++) {\n     for (int j = 0; j < in_w; j++) {\n       const int offset = i * stride1 + 3 * j;\n       refdata1[offset + 0] = i;\n       refdata1[offset + 1] = j;\n-      refdata1[offset + 2] = static_cast<uint8>((i + j) >> 1);\n+      refdata1[offset + 2] = static_cast<uint8_t>((i + j) >> 1);\n     }\n   }\n \n   // duplicate with weird input stride\n   const int stride2 = 3 * 357;\n-  const std::unique_ptr<uint8[]> refdata2(new uint8[stride2 * in_h]);\n+  const std::unique_ptr<uint8_t[]> refdata2(new uint8_t[stride2 * in_h]);\n   for (int i = 0; i < in_h; i++) {\n     memcpy(&refdata2[i * stride2], &refdata1[i * stride1], 3 * in_w);\n   }\n \n   // Test compression\n-  string cpdata1, cpdata2;\n+  std::string cpdata1, cpdata2;\n   {\n-    const string kXMP = \"XMP_TEST_123\";\n+    const std::string kXMP = \"XMP_TEST_123\";\n \n     // Compress it to JPEG\n     CompressFlags flags;\n@@ -327,7 +328,7 @@ TEST(JpegMemTest, Jpeg2) {\n     CHECK_EQ(cpdata1, cpdata2);\n \n     // Verify valid XMP.\n-    CHECK_NE(string::npos, cpdata1.find(kXMP));\n+    CHECK_NE(std::string::npos, cpdata1.find(kXMP));\n \n     // Test the other API, where a storage string is supplied\n     tstring cptest;\n@@ -340,7 +341,7 @@ TEST(JpegMemTest, Jpeg2) {\n   }\n \n   // Uncompress twice: once with 3 components and once with autodetect.\n-  std::unique_ptr<uint8[]> imgdata1;\n+  std::unique_ptr<uint8_t[]> imgdata1;\n   for (const int components : {0, 3}) {\n     // Uncompress it\n     UncompressFlags flags;\n@@ -366,7 +367,7 @@ TEST(JpegMemTest, Jpeg2) {\n   {\n     UncompressFlags flags;\n     flags.stride = 3 * 411;\n-    const std::unique_ptr<uint8[]> imgdata2(new uint8[flags.stride * in_h]);\n+    const std::unique_ptr<uint8_t[]> imgdata2(new uint8_t[flags.stride * in_h]);\n     CHECK(imgdata2.get() == Uncompress(cpdata2.c_str(), cpdata2.length(), flags,\n                                        nullptr /* nwarn */,\n                                        [=, &imgdata2](int w, int h, int c) {\n@@ -404,7 +405,7 @@ TEST(JpegMemTest, Jpeg2) {\n \n // Takes JPEG data and reads its headers to determine whether or not the JPEG\n // was chroma downsampled.\n-bool IsChromaDownsampled(const string& jpegdata) {\n+bool IsChromaDownsampled(const std::string& jpegdata) {\n   // Initialize libjpeg structures to have a memory source\n   // Modify the usual jpeg error manager to catch fatal errors.\n   struct jpeg_decompress_struct cinfo;\n@@ -447,8 +448,8 @@ bool IsChromaDownsampled(const string& jpegdata) {\n \n TEST(JpegMemTest, ChromaDownsampling) {\n   // Read the data from a test jpeg file into memory\n-  const string jpegfile = string(kTestData) + \"jpeg_merge_test1.jpg\";\n-  string jpeg;\n+  const std::string jpegfile = std::string(kTestData) + \"jpeg_merge_test1.jpg\";\n+  std::string jpeg;\n   ReadFileToStringOrDie(Env::Default(), jpegfile, &jpeg);\n \n   // Verify that compressing the JPEG with chroma downsampling works.\n@@ -458,7 +459,7 @@ TEST(JpegMemTest, ChromaDownsampling) {\n   unflags.components = 3;\n   int w, h, c;\n   int64_t num_warnings;\n-  std::unique_ptr<uint8[]> uncompressed(Uncompress(\n+  std::unique_ptr<uint8_t[]> uncompressed(Uncompress(\n       jpeg.c_str(), jpeg.size(), unflags, &w, &h, &c, &num_warnings));\n   CHECK(uncompressed != nullptr);\n   CHECK_EQ(num_warnings, 0);\n@@ -476,18 +477,18 @@ TEST(JpegMemTest, ChromaDownsampling) {\n   }\n }\n \n-void TestBadJPEG(Env* env, const string& bad_jpeg_file, int expected_width,\n-                 int expected_height, const string& reference_RGB_file,\n+void TestBadJPEG(Env* env, const std::string& bad_jpeg_file, int expected_width,\n+                 int expected_height, const std::string& reference_RGB_file,\n                  const bool try_recover_truncated_jpeg) {\n-  string jpeg;\n+  std::string jpeg;\n   ReadFileToStringOrDie(env, bad_jpeg_file, &jpeg);\n \n   UncompressFlags flags;\n   flags.components = 3;\n   flags.try_recover_truncated_jpeg = try_recover_truncated_jpeg;\n \n   int width, height, components;\n-  std::unique_ptr<uint8[]> imgdata;\n+  std::unique_ptr<uint8_t[]> imgdata;\n   imgdata.reset(Uncompress(jpeg.c_str(), jpeg.size(), flags, &width, &height,\n                            &components, nullptr));\n   if (expected_width > 0) {  // we expect the file to decode into 'something'\n@@ -496,7 +497,7 @@ void TestBadJPEG(Env* env, const string& bad_jpeg_file, int expected_width,\n     CHECK_EQ(components, 3);\n     CHECK(imgdata.get());\n     if (!reference_RGB_file.empty()) {\n-      string ref;\n+      std::string ref;\n       ReadFileToStringOrDie(env, reference_RGB_file, &ref);\n       CHECK(!memcmp(ref.data(), imgdata.get(), ref.size()));\n     }\n@@ -507,7 +508,7 @@ void TestBadJPEG(Env* env, const string& bad_jpeg_file, int expected_width,\n \n TEST(JpegMemTest, BadJpeg) {\n   Env* env = Env::Default();\n-  const string data_path = kTestData;\n+  const std::string data_path = kTestData;\n \n   // Test corrupt file\n   TestBadJPEG(env, data_path + \"bad_huffman.jpg\", 1024, 768, \"\", false);"
        }
    ],
    "stats": {
        "total": 159,
        "additions": 80,
        "deletions": 79
    }
}