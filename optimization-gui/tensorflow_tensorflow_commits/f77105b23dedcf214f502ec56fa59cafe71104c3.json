{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 848475361",
    "sha": "f77105b23dedcf214f502ec56fa59cafe71104c3",
    "files": [
        {
            "sha": "3d8eabc8361f6bffba6399b24ba8733ca93339f6",
            "filename": "tensorflow/tools/graph_transforms/quantize_nodes.cc",
            "status": "modified",
            "additions": 75,
            "deletions": 69,
            "changes": 144,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f77105b23dedcf214f502ec56fa59cafe71104c3/tensorflow%2Ftools%2Fgraph_transforms%2Fquantize_nodes.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f77105b23dedcf214f502ec56fa59cafe71104c3/tensorflow%2Ftools%2Fgraph_transforms%2Fquantize_nodes.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Ftools%2Fgraph_transforms%2Fquantize_nodes.cc?ref=f77105b23dedcf214f502ec56fa59cafe71104c3",
            "patch": "@@ -32,17 +32,17 @@ namespace graph_transforms {\n // into the quantized equivalent.\n struct QuantizedOpInfo {\n   // The name of the float op.\n-  string float_name;\n+  std::string float_name;\n   // Which attributes to copy directly over.\n-  std::vector<string> attrs_to_copy;\n+  std::vector<std::string> attrs_to_copy;\n   // Extra data type attributes we need to set.\n-  std::vector<std::pair<string, DataType>> dtypes_to_set;\n+  std::vector<std::pair<std::string, DataType>> dtypes_to_set;\n   // What depth of inputs the op can read in.\n   DataType input_bit_depth;\n   // The depth of the op's quantized outputs.\n   DataType output_bit_depth;\n   // Which inputs (e.g. shapes) aren't involved in the quantization process.\n-  std::set<int32> unquantized_inputs;\n+  std::set<int32_t> unquantized_inputs;\n   // How the outputs are arranged, either\n   // [input0, input1, min0, max0, min1, max1] for contiguous, or\n   // [input0, input1, min0, min1, max0, max1] for separate.\n@@ -145,12 +145,12 @@ const std::vector<QuantizedOpInfo>& GetQuantizedOpList() {\n \n namespace {\n // Replaces invalid characters in input names to get a unique node name.\n-string UniqueNodeNameFromInput(const string& input_name) {\n-  string prefix;\n-  string node_name;\n-  string suffix;\n+std::string UniqueNodeNameFromInput(const std::string& input_name) {\n+  std::string prefix;\n+  std::string node_name;\n+  std::string suffix;\n   NodeNamePartsFromInput(input_name, &prefix, &node_name, &suffix);\n-  string result;\n+  std::string result;\n   if (prefix == \"^\") {\n     result += \"__hat__\";\n   }\n@@ -163,9 +163,10 @@ string UniqueNodeNameFromInput(const string& input_name) {\n \n // Pulls two float values from the named parameters, with a lot of checking.\n absl::Status ExtractRangeFromParams(const TransformFuncContext& context,\n-                                    const string& min_name,\n-                                    const string& max_name, float* min_value,\n-                                    float* max_value, bool* has_range) {\n+                                    const std::string& min_name,\n+                                    const std::string& max_name,\n+                                    float* min_value, float* max_value,\n+                                    bool* has_range) {\n   // See if we've been given quantized inputs with a known range.\n   const bool has_min = (context.params.count(min_name) != 0);\n   const bool has_max = (context.params.count(max_name) != 0);\n@@ -193,32 +194,32 @@ absl::Status MergeDuplicateNodes(const GraphDef& input_graph_def,\n                                  const TransformFuncContext& context,\n                                  GraphDef* output_graph_def) {\n   // Make sure we can look up inputs and outputs quickly.\n-  std::set<string> input_names(context.input_names.begin(),\n-                               context.input_names.end());\n-  std::set<string> output_names(context.output_names.begin(),\n-                                context.output_names.end());\n+  std::set<std::string> input_names(context.input_names.begin(),\n+                                    context.input_names.end());\n+  std::set<std::string> output_names(context.output_names.begin(),\n+                                     context.output_names.end());\n   GraphDef current_graph_def = input_graph_def;\n   // Keep running the merging until no more duplicates are found.\n   bool any_duplicates_found;\n   do {\n     any_duplicates_found = false;\n     // First arrange all of the nodes by a hash of their contents.\n-    std::map<uint64, std::vector<const NodeDef*>> hashed_nodes;\n+    std::map<uint64_t, std::vector<const NodeDef*>> hashed_nodes;\n     for (const NodeDef& node : current_graph_def.node()) {\n       NodeDef nameless_node = node;\n       // The name matters if it's being used as an input or output node,\n       // otherwise ignore it when looking for duplicates.\n       if (!input_names.count(node.name()) && !output_names.count(node.name())) {\n         nameless_node.set_name(\"\");\n       }\n-      const uint64 hash = HashNodeDef(nameless_node);\n+      const uint64_t hash = HashNodeDef(nameless_node);\n       hashed_nodes[hash].push_back(&node);\n     }\n     // If we have multiple nodes with the same hash, then we know they're\n     // duplicates and can be removed, unless they're stateful.\n-    std::map<string, string> inputs_to_rename;\n+    std::map<std::string, std::string> inputs_to_rename;\n     GraphDef merged_graph_def;\n-    for (const std::pair<const uint64, std::vector<const NodeDef*>>&\n+    for (const std::pair<const uint64_t, std::vector<const NodeDef*>>&\n              hashed_node_info : hashed_nodes) {\n       const std::vector<const NodeDef*>& hash_node_list =\n           hashed_node_info.second;\n@@ -229,7 +230,7 @@ absl::Status MergeDuplicateNodes(const GraphDef& input_graph_def,\n             OpRegistry::Global()->LookUpOpDef(current_node->op(), &op_def));\n         const bool is_duplicate = ((!op_def->is_stateful()) && (i > 0));\n         if (is_duplicate) {\n-          const string original_name = hash_node_list[0]->name();\n+          const std::string original_name = hash_node_list[0]->name();\n           inputs_to_rename[current_node->name() + \":*\"] = original_name;\n           any_duplicates_found = true;\n         } else {\n@@ -241,7 +242,7 @@ absl::Status MergeDuplicateNodes(const GraphDef& input_graph_def,\n     // Update the graph so that any nodes that referred to removed inputs now\n     // pull from the remaining duplicate.\n     TF_RETURN_IF_ERROR(RenameNodeInputs(merged_graph_def, inputs_to_rename,\n-                                        std::unordered_set<string>(),\n+                                        std::unordered_set<std::string>(),\n                                         &current_graph_def));\n   } while (any_duplicates_found);\n \n@@ -261,11 +262,11 @@ absl::Status MergeDuplicateNodes(const GraphDef& input_graph_def,\n absl::Status RemoveRedundantQuantizations(const GraphDef& input_graph_def,\n                                           const TransformFuncContext& context,\n                                           GraphDef* output_graph_def) {\n-  std::set<string> graph_outputs;\n-  for (const string& output_name : context.output_names) {\n+  std::set<std::string> graph_outputs;\n+  for (const std::string& output_name : context.output_names) {\n     graph_outputs.insert(NodeNameFromInput(output_name));\n   }\n-  std::map<string, string> inputs_to_rename;\n+  std::map<std::string, std::string> inputs_to_rename;\n   GraphDef replaced_graph_def;\n   TF_RETURN_IF_ERROR(ReplaceMatchingOpTypes(\n       input_graph_def,  // clang-format off\n@@ -276,10 +277,10 @@ absl::Status RemoveRedundantQuantizations(const GraphDef& input_graph_def,\n           {\"Max\"},\n         }\n       },  // clang-format on\n-      [&inputs_to_rename, &graph_outputs](const NodeMatch& match,\n-                                          const std::set<string>& input_nodes,\n-                                          const std::set<string>& output_nodes,\n-                                          std::vector<NodeDef>* new_nodes) {\n+      [&inputs_to_rename, &graph_outputs](\n+          const NodeMatch& match, const std::set<std::string>& input_nodes,\n+          const std::set<std::string>& output_nodes,\n+          std::vector<NodeDef>* new_nodes) {\n         const NodeDef& quantize_node = match.node;\n         const NodeDef& dequantize_node = match.inputs[0].node;\n         inputs_to_rename[quantize_node.name() + \":0\"] =\n@@ -302,7 +303,7 @@ absl::Status RemoveRedundantQuantizations(const GraphDef& input_graph_def,\n       {true}, &replaced_graph_def));\n \n   return RenameNodeInputs(replaced_graph_def, inputs_to_rename,\n-                          std::unordered_set<string>(), output_graph_def);\n+                          std::unordered_set<std::string>(), output_graph_def);\n }\n \n // If the user has passed in the input_min and input_max args, then we need to\n@@ -321,15 +322,15 @@ absl::Status QuantizePlaceholders(const GraphDef& input_graph_def,\n     *output_graph_def = input_graph_def;\n     return absl::OkStatus();\n   }\n-  std::map<string, string> inputs_to_rename_first_pass;\n-  std::map<string, string> inputs_to_rename_second_pass;\n+  std::map<std::string, std::string> inputs_to_rename_first_pass;\n+  std::map<std::string, std::string> inputs_to_rename_second_pass;\n   GraphDef placeholder_graph_def;\n   placeholder_graph_def.Clear();\n   for (const NodeDef& node : input_graph_def.node()) {\n     if (node.op() != \"Placeholder\") {\n       *(placeholder_graph_def.mutable_node()->Add()) = node;\n     } else {\n-      string namespace_prefix = node.name() + \"_eightbit\";\n+      std::string namespace_prefix = node.name() + \"_eightbit\";\n \n       NodeDef quantized_placeholder;\n       quantized_placeholder = node;\n@@ -354,7 +355,7 @@ absl::Status QuantizePlaceholders(const GraphDef& input_graph_def,\n       SetNodeTensorAttr<float>(\"value\", max_tensor, &max_node);\n       *(placeholder_graph_def.mutable_node()->Add()) = max_node;\n \n-      const string rename_suffix = \"__RENAMED_PLACEHOLDER__\";\n+      const std::string rename_suffix = \"__RENAMED_PLACEHOLDER__\";\n       NodeDef dequantize_node;\n       dequantize_node.set_op(\"Dequantize\");\n       dequantize_node.set_name(namespace_prefix + \"/dequantize\");\n@@ -375,12 +376,12 @@ absl::Status QuantizePlaceholders(const GraphDef& input_graph_def,\n   }\n \n   GraphDef first_pass_graph_def;\n-  TF_RETURN_IF_ERROR(\n-      RenameNodeInputs(placeholder_graph_def, inputs_to_rename_first_pass,\n-                       std::unordered_set<string>(), &first_pass_graph_def));\n+  TF_RETURN_IF_ERROR(RenameNodeInputs(\n+      placeholder_graph_def, inputs_to_rename_first_pass,\n+      std::unordered_set<std::string>(), &first_pass_graph_def));\n   TF_RETURN_IF_ERROR(\n       RenameNodeInputs(first_pass_graph_def, inputs_to_rename_second_pass,\n-                       std::unordered_set<string>(), output_graph_def));\n+                       std::unordered_set<std::string>(), output_graph_def));\n \n   return absl::OkStatus();\n }\n@@ -400,15 +401,15 @@ absl::Status ConvertFakeQuantsToRequantize(const GraphDef& input_graph_def,\n           {\"Const\"},\n         }\n       },  // clang-format on\n-      [](const NodeMatch& match, const std::set<string>& input_nodes,\n-         const std::set<string>& output_nodes,\n+      [](const NodeMatch& match, const std::set<std::string>& input_nodes,\n+         const std::set<std::string>& output_nodes,\n          std::vector<NodeDef>* new_nodes) {\n         const NodeDef& fake_quant_node = match.node;\n         const NodeDef& original_op_node = match.inputs[0].node;\n         const NodeDef& fake_quant_min_node = match.inputs[1].node;\n         const NodeDef& fake_quant_max_node = match.inputs[2].node;\n \n-        string namespace_prefix = fake_quant_node.name() + \"_eightbit\";\n+        std::string namespace_prefix = fake_quant_node.name() + \"_eightbit\";\n \n         new_nodes->push_back(original_op_node);\n         new_nodes->push_back(fake_quant_min_node);\n@@ -494,8 +495,8 @@ absl::Status MergeAdjacentRequantizes(const GraphDef& input_graph_def,\n           {\"Const\"},\n         }\n       },  // clang-format on\n-      [](const NodeMatch& match, const std::set<string>& input_nodes,\n-         const std::set<string>& output_nodes,\n+      [](const NodeMatch& match, const std::set<std::string>& input_nodes,\n+         const std::set<std::string>& output_nodes,\n          std::vector<NodeDef>* new_nodes) {\n         const NodeDef& fake_requantize_node = match.node;\n         const NodeDef& original_op_node =\n@@ -544,8 +545,9 @@ absl::Status HoistFakeQuants(const GraphDef& input_graph_def,\n     GraphDef hoisted_graph_def;\n     TF_RETURN_IF_ERROR(ReplaceMatchingOpTypes(\n         current_graph_def, pattern,\n-        [depth](const NodeMatch& match, const std::set<string>& input_nodes,\n-                const std::set<string>& output_nodes,\n+        [depth](const NodeMatch& match,\n+                const std::set<std::string>& input_nodes,\n+                const std::set<std::string>& output_nodes,\n                 std::vector<NodeDef>* new_nodes) {\n           const NodeDef& fake_quant_node = match.node;\n           const NodeDef& fake_quant_min_node = match.inputs[1].node;\n@@ -633,17 +635,17 @@ absl::Status QuantizeNodes(const GraphDef& input_graph_def,\n   // between adjacent quantized ops, but a later pass removes these where it\n   // can.\n \n-  std::set<string> ops_to_ignore;\n+  std::set<std::string> ops_to_ignore;\n   if (context.params.count(\"ignore_op\") > 0) {\n-    for (const string& name : context.params.at(\"ignore_op\")) {\n+    for (const std::string& name : context.params.at(\"ignore_op\")) {\n       ops_to_ignore.insert(name);\n     }\n   }\n \n   const std::vector<QuantizedOpInfo>& op_list = GetQuantizedOpList();\n-  string op_pattern;\n+  std::string op_pattern;\n   bool is_first = true;\n-  std::map<string, QuantizedOpInfo> op_map;\n+  std::map<std::string, QuantizedOpInfo> op_map;\n   for (const QuantizedOpInfo& op_info : op_list) {\n     if (ops_to_ignore.count(op_info.float_name) == 0) {\n       absl::StrAppend(&op_pattern, is_first ? \"\" : \"|\", op_info.float_name);\n@@ -692,8 +694,8 @@ absl::Status QuantizeNodes(const GraphDef& input_graph_def,\n   TF_RETURN_IF_ERROR(ReplaceMatchingOpTypes(\n       converted_graph_def, {op_pattern},\n       [&op_map, fallback_min, fallback_max, has_fallback_range](\n-          const NodeMatch& match, const std::set<string>& input_nodes,\n-          const std::set<string>& output_nodes,\n+          const NodeMatch& match, const std::set<std::string>& input_nodes,\n+          const std::set<std::string>& output_nodes,\n           std::vector<NodeDef>* new_nodes) {\n         const NodeDef& float_node = match.node;\n         const QuantizedOpInfo& op_info = op_map[float_node.op()];\n@@ -728,18 +730,18 @@ absl::Status QuantizeNodes(const GraphDef& input_graph_def,\n           return absl::OkStatus();\n         }\n \n-        string namespace_prefix = float_node.name() + \"_eightbit\";\n+        std::string namespace_prefix = float_node.name() + \"_eightbit\";\n \n         // Quantize all of the inputs.\n-        std::vector<string> quantized_input_names;\n+        std::vector<std::string> quantized_input_names;\n         for (int i = 0; i < float_node.input_size(); ++i) {\n           // Skip any non-float inputs.\n           if (op_info.unquantized_inputs.count(i)) {\n             continue;\n           }\n \n-          const string& input_name = float_node.input(i);\n-          string unique_input_name =\n+          const std::string& input_name = float_node.input(i);\n+          std::string unique_input_name =\n               namespace_prefix + \"/\" + UniqueNodeNameFromInput(input_name);\n \n           // Add some common constants we need for reshaping inputs.\n@@ -749,8 +751,9 @@ absl::Status QuantizeNodes(const GraphDef& input_graph_def,\n           AddNodeInput(\"^\" + NodeNameFromInput(input_name), &reshape_dims);\n           SetNodeAttr(\"dtype\", DT_INT32, &reshape_dims);\n           Tensor reshape_dims_tensor(DT_INT32, {1});\n-          reshape_dims_tensor.flat<int32>()(0) = -1;\n-          SetNodeTensorAttr<int32>(\"value\", reshape_dims_tensor, &reshape_dims);\n+          reshape_dims_tensor.flat<int32_t>()(0) = -1;\n+          SetNodeTensorAttr<int32_t>(\"value\", reshape_dims_tensor,\n+                                     &reshape_dims);\n           new_nodes->push_back(reshape_dims);\n \n           NodeDef reduction_dims;\n@@ -759,9 +762,9 @@ absl::Status QuantizeNodes(const GraphDef& input_graph_def,\n           AddNodeInput(\"^\" + NodeNameFromInput(input_name), &reduction_dims);\n           SetNodeAttr(\"dtype\", DT_INT32, &reduction_dims);\n           Tensor reduction_dims_tensor(DT_INT32, {1});\n-          reduction_dims_tensor.flat<int32>()(0) = 0;\n-          SetNodeTensorAttr<int32>(\"value\", reduction_dims_tensor,\n-                                   &reduction_dims);\n+          reduction_dims_tensor.flat<int32_t>()(0) = 0;\n+          SetNodeTensorAttr<int32_t>(\"value\", reduction_dims_tensor,\n+                                     &reduction_dims);\n           new_nodes->push_back(reduction_dims);\n \n           NodeDef reshape_node;\n@@ -806,11 +809,11 @@ absl::Status QuantizeNodes(const GraphDef& input_graph_def,\n         NodeDef quantized_main_node;\n         quantized_main_node.set_op(\"Quantized\" + float_node.op());\n         quantized_main_node.set_name(float_node.name() + \"/eightbit\");\n-        for (const string& attr_to_copy : op_info.attrs_to_copy) {\n+        for (const std::string& attr_to_copy : op_info.attrs_to_copy) {\n           CopyNodeAttr(float_node, attr_to_copy, attr_to_copy,\n                        &quantized_main_node);\n         }\n-        for (const std::pair<string, DataType>& dtype_to_set :\n+        for (const std::pair<std::string, DataType>& dtype_to_set :\n              op_info.dtypes_to_set) {\n           SetNodeAttr(dtype_to_set.first, dtype_to_set.second,\n                       &quantized_main_node);\n@@ -820,32 +823,35 @@ absl::Status QuantizeNodes(const GraphDef& input_graph_def,\n           if (op_info.unquantized_inputs.count(i)) {\n             AddNodeInput(float_node.input(i), &quantized_main_node);\n           } else {\n-            const string& quantized_input_name =\n+            const std::string& quantized_input_name =\n                 quantized_input_names[quantized_input_index];\n             AddNodeInput(quantized_input_name + \":0\", &quantized_main_node);\n             ++quantized_input_index;\n           }\n         }\n         if (op_info.min_max_order == QuantizedOpInfo::CONTIGUOUS_MIN_MAX) {\n-          for (const string& quantized_input_name : quantized_input_names) {\n+          for (const std::string& quantized_input_name :\n+               quantized_input_names) {\n             AddNodeInput(quantized_input_name + \":1\", &quantized_main_node);\n             AddNodeInput(quantized_input_name + \":2\", &quantized_main_node);\n           }\n         } else {\n-          for (const string& quantized_input_name : quantized_input_names) {\n+          for (const std::string& quantized_input_name :\n+               quantized_input_names) {\n             AddNodeInput(quantized_input_name + \":1\", &quantized_main_node);\n           }\n-          for (const string& quantized_input_name : quantized_input_names) {\n+          for (const std::string& quantized_input_name :\n+               quantized_input_names) {\n             AddNodeInput(quantized_input_name + \":2\", &quantized_main_node);\n           }\n         }\n         new_nodes->push_back(quantized_main_node);\n \n-        string eight_bit_node_name;\n+        std::string eight_bit_node_name;\n         if (op_info.output_bit_depth == DT_QINT32) {\n           // Shrink the range of the output down from 32 bits to 8.\n-          string requantize_min_input;\n-          string requantize_max_input;\n+          std::string requantize_min_input;\n+          std::string requantize_max_input;\n           if (has_fallback_range) {\n             // Use constant values for the min/max range if they were given.\n             NodeDef fallback_min_node;"
        },
        {
            "sha": "128672734f7c0bb53f9be2128534c3ae415270a8",
            "filename": "tensorflow/tools/graph_transforms/remove_attribute.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/f77105b23dedcf214f502ec56fa59cafe71104c3/tensorflow%2Ftools%2Fgraph_transforms%2Fremove_attribute.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/f77105b23dedcf214f502ec56fa59cafe71104c3/tensorflow%2Ftools%2Fgraph_transforms%2Fremove_attribute.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Ftools%2Fgraph_transforms%2Fremove_attribute.cc?ref=f77105b23dedcf214f502ec56fa59cafe71104c3",
            "patch": "@@ -36,7 +36,7 @@ absl::Status RemoveAttribute(const GraphDef& input_graph_def,\n         \"argument, e.g. remove_attribute(op_name=Mul, attribute_name=foo)\");\n   }\n \n-  string op_name;\n+  std::string op_name;\n   if (context.params.count(\"op_name\")) {\n     if (context.params.at(\"op_name\").size() != 1) {\n       return errors::InvalidArgument(\n@@ -48,7 +48,7 @@ absl::Status RemoveAttribute(const GraphDef& input_graph_def,\n     op_name = \"*\";\n   }\n \n-  const string attribute_name = context.params.at(\"attribute_name\")[0];\n+  const std::string attribute_name = context.params.at(\"attribute_name\")[0];\n   output_graph_def->Clear();\n   for (const NodeDef& node : input_graph_def.node()) {\n     NodeDef* new_node = output_graph_def->mutable_node()->Add();"
        }
    ],
    "stats": {
        "total": 148,
        "additions": 77,
        "deletions": 71
    }
}