{
    "author": "basioli-k",
    "message": "[XLA:CPU] Implement target machine options as a cpp class that can convert from and to proto\n\nThis should simplify some of the proto usage.\nWill follow up with using this implementation.\n\nPiperOrigin-RevId: 833751163",
    "sha": "5bd410494d5a27b2fa33c9f328f8f5df0630504d",
    "files": [
        {
            "sha": "97f9e847f5eb25d5bdb6ca1ca408f5475ef71530",
            "filename": "third_party/xla/xla/backends/cpu/BUILD",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5bd410494d5a27b2fa33c9f328f8f5df0630504d/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5bd410494d5a27b2fa33c9f328f8f5df0630504d/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2FBUILD?ref=5bd410494d5a27b2fa33c9f328f8f5df0630504d",
            "patch": "@@ -249,6 +249,38 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"target_machine_options\",\n+    srcs = [\"target_machine_options.cc\"],\n+    hdrs = [\"target_machine_options.h\"],\n+    deps = [\n+        \"//xla:util\",\n+        \"//xla:xla_proto_cc\",\n+        \"//xla/backends/cpu/codegen:cpu_features\",\n+        \"//xla/service/cpu:executable_proto_cc\",\n+        \"@com_google_absl//absl/log:check\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//llvm:TargetParser\",\n+    ],\n+)\n+\n+xla_cc_test(\n+    name = \"target_machine_options_test\",\n+    srcs = [\"target_machine_options_test.cc\"],\n+    deps = [\n+        \":target_machine_options\",\n+        \"//xla:xla_proto_cc\",\n+        \"//xla/service/cpu:executable_proto_cc\",\n+        \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n cc_library(\n     name = \"constant_allocation\",\n     srcs = [\"constant_allocation.cc\"],"
        },
        {
            "sha": "d52eb5ad92287da5f130deb23749548dbfb0a3a1",
            "filename": "third_party/xla/xla/backends/cpu/target_machine_options.cc",
            "status": "added",
            "additions": 180,
            "deletions": 0,
            "changes": 180,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5bd410494d5a27b2fa33c9f328f8f5df0630504d/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Ftarget_machine_options.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5bd410494d5a27b2fa33c9f328f8f5df0630504d/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Ftarget_machine_options.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Ftarget_machine_options.cc?ref=5bd410494d5a27b2fa33c9f328f8f5df0630504d",
            "patch": "@@ -0,0 +1,180 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/cpu/target_machine_options.h\"\n+\n+#include <algorithm>\n+#include <string>\n+#include <tuple>\n+#include <utility>\n+#include <vector>\n+\n+#include \"absl/log/check.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/strings/match.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/str_join.h\"\n+#include \"absl/strings/str_split.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"llvm/ADT/StringRef.h\"  // IWYU pragma: keep\n+#include \"llvm/TargetParser/Host.h\"\n+#include \"xla/backends/cpu/codegen/cpu_features.h\"\n+#include \"xla/service/cpu/executable.pb.h\"\n+#include \"xla/util.h\"\n+#include \"xla/xla.pb.h\"\n+\n+namespace xla {\n+namespace cpu {\n+\n+namespace {\n+\n+bool ValidateTargetMachineFeaturesString(absl::string_view features) {\n+  if (features.empty()) {\n+    return true;\n+  }\n+  for (const auto& feature : absl::StrSplit(features, ',')) {\n+    if ((!absl::StartsWith(feature, \"+\") && !absl::StartsWith(feature, \"-\")) ||\n+        feature.size() <= 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+void EnableFeaturesIfAVX512(std::vector<std::string>& features) {\n+  auto avx512_it = std::find_if(features.begin(), features.end(),\n+                                [](const std::string& feature) {\n+                                  return absl::StrContains(feature, \"avx512\");\n+                                });\n+  bool has_avx512 = avx512_it != features.end();\n+  if (!has_avx512) {\n+    return;\n+  }\n+\n+  auto prefer_no_scatter_it = std::find_if(\n+      features.begin(), features.end(), [](const std::string& feature) {\n+        return absl::StrContains(feature, \"prefer-no-scatter\");\n+      });\n+\n+  if (prefer_no_scatter_it == features.end()) {\n+    features.push_back(\"prefer-no-scatter\");\n+  }\n+\n+  auto prefer_no_gather_it = std::find_if(\n+      features.begin(), features.end(), [](const std::string& feature) {\n+        return absl::StrContains(feature, \"prefer-no-gather\");\n+      });\n+\n+  if (prefer_no_gather_it == features.end()) {\n+    features.push_back(\"prefer-no-gather\");\n+  }\n+}\n+\n+std::pair<std::vector<std::string>, std::vector<std::string>>\n+GetEnabledAndDisabledFeatures(const std::vector<std::string>& features) {\n+  std::vector<std::string> enabled_features;\n+  std::vector<std::string> disabled_features;\n+  for (const auto& feature : features) {\n+    if (absl::StartsWith(feature, \"+\")) {\n+      enabled_features.push_back(feature.substr(1));\n+    } else if (absl::StartsWith(feature, \"-\")) {\n+      disabled_features.push_back(feature.substr(1));\n+    }\n+  }\n+  return std::make_pair(enabled_features, disabled_features);\n+}\n+\n+}  // namespace\n+\n+TargetMachineOptions::TargetMachineOptions(const DebugOptions& debug_options) {\n+  triple_ = llvm::sys::getDefaultTargetTriple();\n+  auto xla_cpu_max_isa = CpuFeatureFromString(debug_options.xla_cpu_max_isa());\n+  auto detected_machine_attributes = DetectMachineAttributes(xla_cpu_max_isa);\n+\n+  std::tie(enabled_features_, disabled_features_) =\n+      GetEnabledAndDisabledFeatures(detected_machine_attributes.features);\n+\n+  // If `max_cpu_feature` is newer than the host CPU, we should keep the host\n+  // CPU name, e.g., we don't want to set the target CPU to Skylake when we\n+  // are on a Broadwell host.\n+  cpu_ = detected_machine_attributes.num_filtered_features\n+             ? CpuTargetFromMaxFeature(*xla_cpu_max_isa)\n+             : absl::string_view(llvm::sys::getHostCPUName());\n+\n+  EnableFeaturesIfAVX512(enabled_features_);\n+}\n+\n+TargetMachineOptions::TargetMachineOptions(absl::string_view triple,\n+                                           absl::string_view cpu,\n+                                           absl::string_view features)\n+    : triple_(triple), cpu_(cpu) {\n+  std::vector<std::string> features_vec = absl::StrSplit(features, ',');\n+  std::tie(enabled_features_, disabled_features_) =\n+      GetEnabledAndDisabledFeatures(features_vec);\n+  EnableFeaturesIfAVX512(enabled_features_);\n+}\n+\n+std::vector<std::string> TargetMachineOptions::GetTargetMachineFeaturesVector()\n+    const {\n+  std::vector<std::string> all_features;\n+  all_features.reserve(enabled_features_.size() + disabled_features_.size());\n+  for (const auto& feature : enabled_features_) {\n+    all_features.push_back(absl::StrCat(\"+\", feature));\n+  }\n+  for (const auto& feature : disabled_features_) {\n+    all_features.push_back(absl::StrCat(\"-\", feature));\n+  }\n+\n+  return all_features;\n+}\n+\n+std::string TargetMachineOptions::GetTargetMachineFeatures() const {\n+  return absl::StrJoin(GetTargetMachineFeaturesVector(), \",\");\n+}\n+\n+TargetMachineOptionsProto TargetMachineOptions::ToProto() const {\n+  TargetMachineOptionsProto proto;\n+  proto.set_triple(triple_);\n+  proto.set_cpu(cpu_);\n+  proto.set_features(GetTargetMachineFeatures());\n+  return proto;\n+}\n+\n+/*static*/\n+absl::StatusOr<TargetMachineOptions> TargetMachineOptions::FromProto(\n+    const TargetMachineOptionsProto& proto) {\n+  if (!ValidateTargetMachineFeaturesString(proto.features())) {\n+    return Internal(\"Invalid target machine features: %s\",\n+                    std::string(proto.features()));\n+  }\n+  return TargetMachineOptions(proto.triple(), proto.cpu(), proto.features());\n+}\n+\n+absl::Status TargetMachineOptions::SetFeatures(absl::string_view features) {\n+  if (!ValidateTargetMachineFeaturesString(features)) {\n+    return Internal(\"Trying to set invalid target machine features: %s\",\n+                    std::string(features));\n+  }\n+\n+  std::vector<std::string> features_vec = absl::StrSplit(features, ',');\n+  std::tie(enabled_features_, disabled_features_) =\n+      GetEnabledAndDisabledFeatures(features_vec);\n+  EnableFeaturesIfAVX512(enabled_features_);\n+\n+  return absl::OkStatus();\n+}\n+\n+}  // namespace cpu\n+}  // namespace xla"
        },
        {
            "sha": "e503039bb2e90df9ceef1fbb553a09f1096685cf",
            "filename": "third_party/xla/xla/backends/cpu/target_machine_options.h",
            "status": "added",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5bd410494d5a27b2fa33c9f328f8f5df0630504d/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Ftarget_machine_options.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5bd410494d5a27b2fa33c9f328f8f5df0630504d/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Ftarget_machine_options.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Ftarget_machine_options.h?ref=5bd410494d5a27b2fa33c9f328f8f5df0630504d",
            "patch": "@@ -0,0 +1,78 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_BACKENDS_CPU_TARGET_MACHINE_OPTIONS_H_\n+#define XLA_BACKENDS_CPU_TARGET_MACHINE_OPTIONS_H_\n+\n+#include <string>\n+#include <vector>\n+\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"xla/service/cpu/executable.pb.h\"\n+#include \"xla/xla.pb.h\"\n+\n+namespace xla {\n+namespace cpu {\n+\n+// Helper class to manage the target machine options for CPU compilation.\n+class TargetMachineOptions {\n+ public:\n+  // Creates a TargetMachineOptions object from the given DebugOptions. This\n+  // will create a TargetMachineOptions object for the host machine.\n+  explicit TargetMachineOptions(const DebugOptions& debug_options);\n+\n+  // Creates a TargetMachineOptions object from the given triple, cpu, and\n+  // features.\n+  TargetMachineOptions(absl::string_view triple, absl::string_view cpu,\n+                       absl::string_view features);\n+\n+  TargetMachineOptionsProto ToProto() const;\n+  static absl::StatusOr<TargetMachineOptions> FromProto(\n+      const TargetMachineOptionsProto& proto);\n+\n+  const std::string& triple() const { return triple_; }\n+  const std::string& cpu() const { return cpu_; }\n+  const std::vector<std::string>& enabled_features() const {\n+    return enabled_features_;\n+  }\n+  const std::vector<std::string>& disabled_features() const {\n+    return disabled_features_;\n+  }\n+\n+  absl::Status SetFeatures(absl::string_view features);\n+\n+  // Returns the target machine features in the format that LLVM understands\n+  // (e.x. \"+avx2,-avx512\")).\n+  std::string GetTargetMachineFeatures() const;\n+\n+  // Returns the target machine features in the format that LLVM understands -\n+  // features prefixed with \"+\" or \"-\". E.x. {\"+avx2\", \"-avx512\"}.\n+  std::vector<std::string> GetTargetMachineFeaturesVector() const;\n+\n+ private:\n+  TargetMachineOptions() = default;\n+\n+  std::string triple_;\n+  std::string cpu_;\n+  std::vector<std::string> enabled_features_;\n+  std::vector<std::string> disabled_features_;\n+};\n+\n+}  // namespace cpu\n+}  // namespace xla\n+\n+#endif  // XLA_BACKENDS_CPU_TARGET_MACHINE_OPTIONS_H_"
        },
        {
            "sha": "fec5439e0bb31ded97fdc6422389a61d150ffbee",
            "filename": "third_party/xla/xla/backends/cpu/target_machine_options_test.cc",
            "status": "added",
            "additions": 146,
            "deletions": 0,
            "changes": 146,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/5bd410494d5a27b2fa33c9f328f8f5df0630504d/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Ftarget_machine_options_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/5bd410494d5a27b2fa33c9f328f8f5df0630504d/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Ftarget_machine_options_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Ftarget_machine_options_test.cc?ref=5bd410494d5a27b2fa33c9f328f8f5df0630504d",
            "patch": "@@ -0,0 +1,146 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/backends/cpu/target_machine_options.h\"\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/status/status.h\"\n+#include \"xla/service/cpu/executable.pb.h\"\n+#include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/xla.pb.h\"\n+\n+namespace xla {\n+namespace cpu {\n+namespace {\n+\n+TEST(TargetMachineOptionsTest, ToProto) {\n+  DebugOptions debug_options;\n+  TargetMachineOptions options(debug_options);\n+  TargetMachineOptionsProto proto = options.ToProto();\n+\n+  EXPECT_EQ(proto.triple(), options.triple());\n+  EXPECT_EQ(proto.cpu(), options.cpu());\n+  EXPECT_EQ(proto.features(), options.GetTargetMachineFeatures());\n+}\n+\n+TEST(TargetMachineOptionsTest, FromProto) {\n+  TargetMachineOptionsProto proto;\n+  proto.set_triple(\"test_triple\");\n+  proto.set_cpu(\"test_cpu\");\n+  proto.set_features(\"+enabled_feature,-disabled_feature\");\n+\n+  TF_ASSERT_OK_AND_ASSIGN(TargetMachineOptions options,\n+                          TargetMachineOptions::FromProto(proto));\n+\n+  EXPECT_EQ(options.triple(), \"test_triple\");\n+  EXPECT_EQ(options.cpu(), \"test_cpu\");\n+  EXPECT_THAT(options.enabled_features(),\n+              testing::ElementsAre(\"enabled_feature\"));\n+  EXPECT_THAT(options.disabled_features(),\n+              testing::ElementsAre(\"disabled_feature\"));\n+  EXPECT_EQ(options.GetTargetMachineFeatures(),\n+            \"+enabled_feature,-disabled_feature\");\n+}\n+\n+TEST(TargetMachineOptionsTest, ProtoRoundTrip) {\n+  DebugOptions debug_options;\n+  TargetMachineOptions options(debug_options);\n+  TargetMachineOptionsProto proto = options.ToProto();\n+  TF_ASSERT_OK_AND_ASSIGN(TargetMachineOptions new_options,\n+                          TargetMachineOptions::FromProto(proto));\n+\n+  EXPECT_EQ(new_options.triple(), options.triple());\n+  EXPECT_EQ(new_options.cpu(), options.cpu());\n+  EXPECT_EQ(new_options.GetTargetMachineFeatures(),\n+\n+            options.GetTargetMachineFeatures());\n+}\n+\n+TEST(TargetMachineOptionsTest, ConstructorWithFeatures) {\n+  TargetMachineOptions options(\"test_triple\", \"test_cpu\", \"+avx2,-avx512\");\n+\n+  EXPECT_EQ(options.triple(), \"test_triple\");\n+  EXPECT_EQ(options.cpu(), \"test_cpu\");\n+  EXPECT_THAT(options.enabled_features(), testing::ElementsAre(\"avx2\"));\n+  EXPECT_THAT(options.disabled_features(), testing::ElementsAre(\"avx512\"));\n+  EXPECT_EQ(options.GetTargetMachineFeatures(), \"+avx2,-avx512\");\n+}\n+\n+TEST(TargetMachineOptionsTest, GetTargetMachineFeaturesFormat) {\n+  TargetMachineOptions options1(\"t\", \"c\", \"+f1,-f2\");\n+  EXPECT_EQ(options1.GetTargetMachineFeatures(), \"+f1,-f2\");\n+\n+  TargetMachineOptions options2(\"t\", \"c\", \"-f2,+f1\");\n+  EXPECT_EQ(options2.GetTargetMachineFeatures(), \"+f1,-f2\");\n+\n+  TargetMachineOptions options3(\"t\", \"c\", \"+f1\");\n+  EXPECT_EQ(options3.GetTargetMachineFeatures(), \"+f1\");\n+\n+  TargetMachineOptions options4(\"t\", \"c\", \"-f2\");\n+  EXPECT_EQ(options4.GetTargetMachineFeatures(), \"-f2\");\n+\n+  TargetMachineOptions options5(\"t\", \"c\", \"\");\n+  EXPECT_EQ(options5.GetTargetMachineFeatures(), \"\");\n+\n+  TargetMachineOptions options6(\"t\", \"c\", \"+f1,-f2,+f3,-f4\");\n+  EXPECT_EQ(options6.GetTargetMachineFeatures(), \"+f1,+f3,-f2,-f4\");\n+}\n+\n+TEST(TargetMachineOptionsTest, FromProtoWithMalformedFeatures) {\n+  TargetMachineOptionsProto proto;\n+  proto.set_triple(\"test_triple\");\n+  proto.set_cpu(\"test_cpu\");\n+  proto.set_features(\"malformed\");\n+\n+  auto options = TargetMachineOptions::FromProto(proto);\n+\n+  EXPECT_EQ(options.status().code(), absl::StatusCode::kInternal);\n+}\n+\n+TEST(TargetMachineOptionsTest, FromProtoWithEmptyFeatureAfterPlus) {\n+  TargetMachineOptionsProto proto;\n+  proto.set_triple(\"test_triple\");\n+  proto.set_cpu(\"test_cpu\");\n+  proto.set_features(\"+\");\n+\n+  auto options = TargetMachineOptions::FromProto(proto);\n+\n+  EXPECT_EQ(options.status().code(), absl::StatusCode::kInternal);\n+}\n+\n+TEST(TargetMachineOptionsTest, SetFeatures) {\n+  TargetMachineOptions options(\"test_triple\", \"test_cpu\", \"\");\n+  TF_ASSERT_OK(options.SetFeatures(\"+avx2,-avx512\"));\n+\n+  EXPECT_EQ(options.GetTargetMachineFeatures(), \"+avx2,-avx512\");\n+}\n+\n+TEST(TargetMachineOptionsTest, AVX512ImpliesNoScatterAndNoGather) {\n+  TargetMachineOptions options(\"test_triple\", \"test_cpu\", \"+avx512\");\n+  EXPECT_EQ(options.GetTargetMachineFeatures(),\n+            \"+avx512,+prefer-no-scatter,+prefer-no-gather\");\n+}\n+\n+TEST(TargetMachineOptionsTest, GetTargetMachineFeaturesVector) {\n+  TargetMachineOptions options(\"test_triple\", \"test_cpu\", \"+avx2,-avx512\");\n+  EXPECT_THAT(options.GetTargetMachineFeaturesVector(),\n+              testing::ElementsAre(\"+avx2\", \"-avx512\"));\n+}\n+\n+}  // namespace\n+}  // namespace cpu\n+}  // namespace xla"
        }
    ],
    "stats": {
        "total": 436,
        "additions": 436,
        "deletions": 0
    }
}