{
    "author": "krishnaharidasan",
    "message": "Add tests for serializing and deserializing `LoadedExecutable`.\n\nThis change parameterizes the `LoadedExecutableImplTest` suite to run all tests with and without serializing/deserializing the compiled executable. This ensures that the properties and execution behavior are consistent after a round trip through serialization.\n\nPiperOrigin-RevId: 804705123",
    "sha": "1dcc11d64a080d69bce9e5039daa16eb925f4357",
    "files": [
        {
            "sha": "19e275a410c24f23600c89fdea1ad7c65737083b",
            "filename": "third_party/xla/xla/backends/cpu/nanort/ifrt_client_test.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1dcc11d64a080d69bce9e5039daa16eb925f4357/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1dcc11d64a080d69bce9e5039daa16eb925f4357/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fnanort%2Fifrt_client_test.cc?ref=1dcc11d64a080d69bce9e5039daa16eb925f4357",
            "patch": "@@ -328,11 +328,13 @@ int main(int argc, char** argv) {\n       // NanoRT does not handle zero-sized buffers correctly.\n       \"ArrayImplTest.MakeAndCopyZeroSizedBuffers:\"\n       // Executable returns a wrong number of devices.\n-      \"LoadedExecutableImplTest.Properties:\"\n+      \"*LoadedExecutableImplTest.Properties*:\"\n       // Incorrect deleted state of donated inputs.\n-      \"LoadedExecutableImplTest.Donation:\"\n+      \"*LoadedExecutableImplTest.Donation*:\"\n       // Analysis methods are not implemented.\n-      \"LoadedExecutableImplTest.Analysis\";\n+      \"*LoadedExecutableImplTest.Analysis*:\"\n+      // Serialization is not implemented.\n+      \"*SerializeAndLoad*\";\n   xla::ifrt::test_util::SetTestFilterIfNotUserSpecified(kFilter);\n \n   for (int i = 1; i < argc; i++) {"
        },
        {
            "sha": "9a1507c750627effd1da86a49bb44d909b3872ef",
            "filename": "third_party/xla/xla/python/ifrt_proxy/integration_tests/executable_impl_test_tfrt_cpu.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1dcc11d64a080d69bce9e5039daa16eb925f4357/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2Fexecutable_impl_test_tfrt_cpu.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1dcc11d64a080d69bce9e5039daa16eb925f4357/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2Fexecutable_impl_test_tfrt_cpu.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fintegration_tests%2Fexecutable_impl_test_tfrt_cpu.cc?ref=1dcc11d64a080d69bce9e5039daa16eb925f4357",
            "patch": "@@ -22,10 +22,10 @@\n \n int main(int argc, char** argv) {\n   const std::string disabled[] = {\n-      // Executable::IsDeleted always returns false with TFRT CPU backend.\n-      \"LoadedExecutableImplTest.IsDeleted\",\n       // IFRT Proxy does not support `GetHloModules`.\n-      \"LoadedExecutableImplTest.Analysis\",\n+      \"*LoadedExecutableImplTest.Analysis*\",\n+      // CPU backend does not support serialization.\n+      \"*SerializeAndLoad*\",\n   };\n \n   const std::string filter = absl::StrCat(\"-\", absl::StrJoin(disabled, \":\"));"
        },
        {
            "sha": "64531db252755f129695cac8abdfa6f1614fc646",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1dcc11d64a080d69bce9e5039daa16eb925f4357/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1dcc11d64a080d69bce9e5039daa16eb925f4357/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD?ref=1dcc11d64a080d69bce9e5039daa16eb925f4357",
            "patch": "@@ -154,9 +154,11 @@ cc_library(\n         \"//xla/python/ifrt:user_context\",\n         \"//xla/python/ifrt/hlo:hlo_program\",\n         \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n         \"//xla/tsl/util/proto:proto_matchers\",\n+        \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/status:statusor\","
        },
        {
            "sha": "69ef2dddc9fefdf88b5183aef20e5de6e6ab20eb",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/xla_executable_impl_test_lib.cc",
            "status": "modified",
            "additions": 83,
            "deletions": 25,
            "changes": 108,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1dcc11d64a080d69bce9e5039daa16eb925f4357/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_impl_test_lib.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1dcc11d64a080d69bce9e5039daa16eb925f4357/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_impl_test_lib.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fxla_executable_impl_test_lib.cc?ref=1dcc11d64a080d69bce9e5039daa16eb925f4357",
            "patch": "@@ -17,9 +17,11 @@ limitations under the License.\n #include <memory>\n #include <numeric>\n #include <optional>\n+#include <string>\n #include <utility>\n #include <vector>\n \n+#include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/status_matchers.h\"\n #include \"absl/status/statusor.h\"\n@@ -47,6 +49,7 @@ limitations under the License.\n #include \"xla/python/ifrt/user_context.h\"\n #include \"xla/python/pjrt_ifrt/xla_compiler.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/util/proto/proto_matchers.h\"\n@@ -81,9 +84,12 @@ static const char* const module_add_one =\n \n // Compiles an MLIR module on specified devices. If devices is empty, compiles\n // it as a portable executable.\n+// If `serialize` is true, serializes the compiled executable, deserializes it,\n+// and returns the deserialized executable. This is to test correctness of\n+// serialization round-trip of the executable.\n absl::StatusOr<LoadedExecutableRef> CompileOnDevices(\n     Client* client, Compiler* compiler, absl::string_view mlir_module_str,\n-    absl::Span<Device* const> devices, bool replicated) {\n+    absl::Span<Device* const> devices, bool replicated, bool serialize) {\n   mlir::MLIRContext context;\n   TF_ASSIGN_OR_RETURN(mlir::OwningOpRef<mlir::ModuleOp> module,\n                       xla::ParseMlirModuleString(mlir_module_str, context));\n@@ -125,13 +131,37 @@ absl::StatusOr<LoadedExecutableRef> CompileOnDevices(\n     }\n     TF_ASSIGN_OR_RETURN(device_list, client->MakeDeviceList(devices));\n   }\n-  auto xla_compile_options = std::make_unique<XlaCompileOptions>(\n-      compile_options, std::move(device_list));\n-  return compiler->CompileAndLoad(std::make_unique<HloProgram>(*module),\n-                                  std::move(xla_compile_options));\n+  auto xla_compile_options =\n+      std::make_unique<XlaCompileOptions>(compile_options, device_list);\n+  TF_ASSIGN_OR_RETURN(\n+      auto loaded_executable,\n+      compiler->CompileAndLoad(std::make_unique<HloProgram>(*module),\n+                               std::move(xla_compile_options)));\n+  if (!serialize) {\n+    return loaded_executable;\n+  }\n+  auto serialized_executable = loaded_executable->Serialize();\n+  // If serialization is not supported, fall back to using the original\n+  // executable.\n+  if (absl::IsUnimplemented(serialized_executable.status())) {\n+    LOG(INFO) << \"Serialize() returned error: \"\n+              << serialized_executable.status()\n+              << \". Falling back to using the original executable.\";\n+    return loaded_executable;\n+  }\n+  TF_RETURN_IF_ERROR(serialized_executable.status());\n+  auto options = std::make_unique<XlaDeserializeExecutableOptions>();\n+  options->devices = std::move(device_list);\n+  return compiler->DeserializeLoadedExecutable(\n+      *std::move(serialized_executable), std::move(options));\n }\n \n-TEST(LoadedExecutableImplTest, Properties) {\n+class LoadedExecutableImplTest\n+    : public testing::TestWithParam</*serialize=*/bool> {};\n+\n+TEST_P(LoadedExecutableImplTest, Properties) {\n+  bool serialize = GetParam();\n+\n   static constexpr absl::string_view kModule = R\"(\n module @add_sub attributes {\n   mhlo.num_replicas = 1 : i32,\n@@ -157,7 +187,7 @@ module @add_sub attributes {\n   TF_ASSERT_OK_AND_ASSIGN(\n       const LoadedExecutableRef executable,\n       CompileOnDevices(client.get(), compiler, kModule, devices,\n-                       /*replicated=*/false));\n+                       /*replicated=*/false, serialize));\n \n   EXPECT_EQ(executable->name(), \"add_sub\");\n   EXPECT_EQ(executable->num_devices(), devices.size());\n@@ -187,7 +217,13 @@ module @add_sub attributes {\n                     StatusIs(absl::StatusCode::kUnimplemented)));\n }\n \n-TEST(LoadedExecutableImplTest, Analysis) {\n+TEST_P(LoadedExecutableImplTest, Analysis) {\n+  bool serialize = GetParam();\n+\n+  if (serialize) {\n+    GTEST_SKIP() << \"Analysis is not supported for serialized executables.\";\n+  }\n+\n   static constexpr absl::string_view kModule = R\"(\n module @add attributes {\n   mhlo.num_replicas = 1 : i32,\n@@ -207,7 +243,7 @@ module @add attributes {\n       const LoadedExecutableRef executable,\n       CompileOnDevices(client.get(), compiler, kModule,\n                        {client->addressable_devices().front()},\n-                       /*replicated=*/false));\n+                       /*replicated=*/false, serialize));\n \n   TF_ASSERT_OK_AND_ASSIGN(const xla::CompiledMemoryStats compiled_memory_stats,\n                           executable->GetCompiledMemoryStats());\n@@ -224,7 +260,9 @@ module @add attributes {\n   EXPECT_THAT(cost_analysis.map(), Not(IsEmpty()));\n }\n \n-TEST(LoadedExecutableImplTest, GetDonatableInputIndices) {\n+TEST_P(LoadedExecutableImplTest, GetDonatableInputIndices) {\n+  bool serialize = GetParam();\n+\n   static const char* const multi_arg_add_all = R\"(module {\n     func.func @main(\n         %arg0: tensor<2x3xf32> {jax.buffer_donor = true},\n@@ -245,7 +283,7 @@ TEST(LoadedExecutableImplTest, GetDonatableInputIndices) {\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto loaded_executable,\n       CompileOnDevices(client.get(), compiler, multi_arg_add_all, devices,\n-                       /*replicated=*/false));\n+                       /*replicated=*/false, serialize));\n \n   absl::StatusOr<absl::Span<const int>> donatable_input_indices =\n       loaded_executable->GetDonatableInputIndices();\n@@ -259,7 +297,9 @@ TEST(LoadedExecutableImplTest, GetDonatableInputIndices) {\n               IsOkAndHolds(UnorderedElementsAre(0, 2)));\n }\n \n-TEST(LoadedExecutableImplTest, CompileAndExecute) {\n+TEST_P(LoadedExecutableImplTest, CompileAndExecute) {\n+  bool serialize = GetParam();\n+\n   TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n   Compiler* compiler = client->GetDefaultCompiler();\n \n@@ -270,7 +310,7 @@ TEST(LoadedExecutableImplTest, CompileAndExecute) {\n     TF_ASSERT_OK_AND_ASSIGN(\n         loaded_executable,\n         CompileOnDevices(client.get(), compiler, module_add_one, devices,\n-                         /*replicated=*/false));\n+                         /*replicated=*/false, serialize));\n   }\n   EXPECT_EQ(loaded_executable->user_context()->Fingerprint(), 20);\n \n@@ -313,7 +353,9 @@ TEST(LoadedExecutableImplTest, CompileAndExecute) {\n   EXPECT_THAT(out_data, ElementsAreArray(expected_out_data));\n }\n \n-TEST(LoadedExecutableImplTest, CompileAndExecutePortable) {\n+TEST_P(LoadedExecutableImplTest, CompileAndExecutePortable) {\n+  bool serialize = GetParam();\n+\n   TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n   Compiler* compiler = client->GetDefaultCompiler();\n \n@@ -324,7 +366,7 @@ TEST(LoadedExecutableImplTest, CompileAndExecutePortable) {\n     TF_ASSERT_OK_AND_ASSIGN(\n         loaded_executable,\n         CompileOnDevices(client.get(), compiler, module_add_one, devices,\n-                         /*replicated=*/false));\n+                         /*replicated=*/false, serialize));\n   }\n   EXPECT_EQ(loaded_executable->user_context()->Fingerprint(), 20);\n \n@@ -369,15 +411,17 @@ TEST(LoadedExecutableImplTest, CompileAndExecutePortable) {\n   EXPECT_THAT(out_data, ElementsAreArray(expected_out_data));\n }\n \n-TEST(LoadedExecutableImplTest, DoNotFillStatus) {\n+TEST_P(LoadedExecutableImplTest, DoNotFillStatus) {\n+  bool serialize = GetParam();\n+\n   TF_ASSERT_OK_AND_ASSIGN(auto client, test_util::GetClient());\n   Compiler* compiler = client->GetDefaultCompiler();\n \n   std::vector<Device*> devices = {client->addressable_devices().at(0)};\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto loaded_executable,\n       CompileOnDevices(client.get(), compiler, module_add_one, devices,\n-                       /*replicated=*/false));\n+                       /*replicated=*/false, serialize));\n \n   DType dtype(DType::kF32);\n   Shape shape({2, 3});\n@@ -415,7 +459,9 @@ TEST(LoadedExecutableImplTest, DoNotFillStatus) {\n   EXPECT_THAT(out_data, ElementsAreArray(expected_out_data));\n }\n \n-TEST(LoadedExecutableImplTest, NoInputOutput) {\n+TEST_P(LoadedExecutableImplTest, NoInputOutput) {\n+  bool serialize = GetParam();\n+\n   static constexpr absl::string_view kModule = R\"(\n module @nop attributes {\n   mhlo.num_replicas = 1 : i32,\n@@ -429,9 +475,10 @@ module @nop attributes {\n   Compiler* compiler = client->GetDefaultCompiler();\n \n   Device* const device = client->addressable_devices().front();\n-  TF_ASSERT_OK_AND_ASSIGN(const LoadedExecutableRef executable,\n-                          CompileOnDevices(client.get(), compiler, kModule,\n-                                           {device}, /*replicated=*/false));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      const LoadedExecutableRef executable,\n+      CompileOnDevices(client.get(), compiler, kModule, {device},\n+                       /*replicated=*/false, serialize));\n \n   ExecuteOptions options;\n   options.fill_status = true;\n@@ -442,7 +489,9 @@ module @nop attributes {\n   TF_ASSERT_OK(result.status.Await());\n }\n \n-TEST(LoadedExecutableImplTest, Donation) {\n+TEST_P(LoadedExecutableImplTest, Donation) {\n+  bool serialize = GetParam();\n+\n   static constexpr absl::string_view kModule = R\"(\n module @add_sub {\n   func.func @main(\n@@ -458,9 +507,10 @@ module @add_sub {\n   Compiler* compiler = client->GetDefaultCompiler();\n \n   Device* const device = client->addressable_devices().front();\n-  TF_ASSERT_OK_AND_ASSIGN(const LoadedExecutableRef executable,\n-                          CompileOnDevices(client.get(), compiler, kModule,\n-                                           {device}, /*replicated=*/false));\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      const LoadedExecutableRef executable,\n+      CompileOnDevices(client.get(), compiler, kModule, {device},\n+                       /*replicated=*/false, serialize));\n \n   // Create an input array.\n   std::vector<ArrayRef> arrays;\n@@ -531,6 +581,14 @@ module @add_sub {\n   }\n }\n \n+INSTANTIATE_TEST_SUITE_P(\n+    LoadedExecutableImplTest, LoadedExecutableImplTest,\n+    /*serialize=*/testing::Bool(),\n+    [](const ::testing::TestParamInfo<LoadedExecutableImplTest::ParamType>&\n+           info) {\n+      return std::string(info.param ? \"SerializeAndLoad\" : \"DirectLoad\");\n+    });\n+\n }  // namespace\n }  // namespace ifrt\n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 124,
        "additions": 93,
        "deletions": 31
    }
}