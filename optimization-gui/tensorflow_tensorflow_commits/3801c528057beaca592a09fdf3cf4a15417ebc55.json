{
    "author": "jcai19",
    "message": "[XLA][Numerics][Tools] Add a verification tool for HLO original values in MLIR modules\n\nPiperOrigin-RevId: 840139087",
    "sha": "3801c528057beaca592a09fdf3cf4a15417ebc55",
    "files": [
        {
            "sha": "ee81dd497492de7697e2f486057e2ce5eccc8f92",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/BUILD",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3801c528057beaca592a09fdf3cf4a15417ebc55/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3801c528057beaca592a09fdf3cf4a15417ebc55/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2FBUILD?ref=3801c528057beaca592a09fdf3cf4a15417ebc55",
            "patch": "@@ -19,6 +19,7 @@ cc_library(\n     srcs = [\"attribute_exporter.cc\"],\n     hdrs = [\"attribute_exporter.h\"],\n     deps = [\n+        \":type_to_shape\",\n         \"//xla:shape_util\",\n         \"//xla:types\",\n         \"//xla:util\",\n@@ -27,6 +28,7 @@ cc_library(\n         \"//xla/hlo/parser:hlo_parser\",\n         \"//xla/hlo/translate/hlo_to_mhlo:hlo_utils\",\n         \"//xla/mlir_hlo\",\n+        \"//xla/mlir_hlo:unregistered_attributes\",\n         \"//xla/service:hlo_proto_cc\",\n         \"//xla/service/spmd/shardy:constants\",\n         \"//xla/service/spmd/shardy:utils\","
        },
        {
            "sha": "326ec30ba20572661d8b86db1d2892078988e6ac",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/attribute_exporter.cc",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3801c528057beaca592a09fdf3cf4a15417ebc55/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fattribute_exporter.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3801c528057beaca592a09fdf3cf4a15417ebc55/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fattribute_exporter.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fattribute_exporter.cc?ref=3801c528057beaca592a09fdf3cf4a15417ebc55",
            "patch": "@@ -40,7 +40,9 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_sharding.h\"\n #include \"xla/hlo/parser/hlo_parser.h\"\n #include \"xla/hlo/translate/hlo_to_mhlo/hlo_utils.h\"\n+#include \"xla/hlo/translate/mhlo_to_hlo/type_to_shape.h\"\n #include \"xla/mlir_hlo/mhlo/IR/hlo_ops.h\"\n+#include \"xla/mlir_hlo/utils/unregistered_attributes.h\"\n #include \"xla/service/hlo.pb.h\"\n #include \"xla/service/spmd/shardy/constants.h\"\n #include \"xla/service/spmd/shardy/stablehlo_round_trip/export_shardings.h\"\n@@ -512,4 +514,22 @@ std::optional<xla::OpSharding> ExtractShardyResultShardingFromFrontendAttrs(\n                                          sdy_meshes, op_frontend_attrs);\n }\n \n+mlir::FailureOr<xla::Shape> ExtractXlaShape(mlir::Operation* op) {\n+  if (auto attr = op->getAttrOfType<mlir::StringAttr>(xla::kXlaShape)) {\n+    return *xla::ParseShape(\n+        absl::string_view(attr.getValue().data(), attr.getValue().size()));\n+  }\n+  std::vector<xla::Shape> subshapes;\n+  for (auto [index, result] : llvm::enumerate(op->getResults())) {\n+    subshapes.push_back(xla::TypeToShape(result.getType()));\n+    if (subshapes.back().element_type() == xla::PRIMITIVE_TYPE_INVALID) {\n+      return op->emitError() << \"result #\" << index << \" type is not supported\";\n+    }\n+  }\n+  if (subshapes.size() > 1) {\n+    return xla::ShapeUtil::MakeTupleShape(subshapes);\n+  }\n+  return subshapes[0];\n+}\n+\n }  // namespace xla"
        },
        {
            "sha": "2b8dc55dd861f9323bdec6e44e5b9d75c2483970",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/attribute_exporter.h",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3801c528057beaca592a09fdf3cf4a15417ebc55/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fattribute_exporter.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3801c528057beaca592a09fdf3cf4a15417ebc55/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fattribute_exporter.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fattribute_exporter.h?ref=3801c528057beaca592a09fdf3cf4a15417ebc55",
            "patch": "@@ -31,6 +31,7 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_input_output_alias_config.h\"\n #include \"xla/mlir_hlo/mhlo/IR/hlo_ops.h\"\n #include \"xla/service/hlo.pb.h\"\n+#include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/stream_executor/dnn.h\"\n #include \"xla/types.h\"\n@@ -96,6 +97,10 @@ std::optional<xla::OpSharding> ExtractShardyResultShardingFromFrontendAttrs(\n     mlir::func::FuncOp function, int64_t res_num,\n     std::optional<mlir::DictionaryAttr> sdy_meshes);\n \n+// Returns a failure or a valid XLA shape corresponding to the given op's\n+// results.\n+mlir::FailureOr<xla::Shape> ExtractXlaShape(mlir::Operation* op);\n+\n // Returns an OriginalValueProto that represents a value in the unoptimized HLO\n // graph.\n std::optional<xla::OriginalValueProto> ConvertOriginalValue("
        },
        {
            "sha": "a33d5fb6872457dfa79723904c116e75418db088",
            "filename": "third_party/xla/xla/hlo/translate/mhlo_to_hlo/mlir_hlo_to_hlo.cc",
            "status": "modified",
            "additions": 14,
            "deletions": 30,
            "changes": 44,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3801c528057beaca592a09fdf3cf4a15417ebc55/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fmlir_hlo_to_hlo.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3801c528057beaca592a09fdf3cf4a15417ebc55/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fmlir_hlo_to_hlo.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftranslate%2Fmhlo_to_hlo%2Fmlir_hlo_to_hlo.cc?ref=3801c528057beaca592a09fdf3cf4a15417ebc55",
            "patch": "@@ -379,28 +379,6 @@ static xla::Layout ExtractLayout(mlir::Operation* op, int rank,\n   return xla::LayoutUtil::MakeDescendingLayout(rank);\n }\n \n-// Returns a failure or a valid XLA shape corresponding to the given op's\n-// results.\n-static mlir::FailureOr<xla::Shape> ExtractXlaShape(mlir::Operation* op) {\n-  if (auto attr = op->getAttrOfType<mlir::StringAttr>(xla::kXlaShape)) {\n-    return *xla::ParseShape(\n-        absl::string_view(attr.getValue().data(), attr.getValue().size()));\n-  } else {\n-    std::vector<xla::Shape> subshapes;\n-    for (auto [index, result] : llvm::enumerate(op->getResults())) {\n-      subshapes.push_back(xla::TypeToShape(result.getType()));\n-      if (subshapes.back().element_type() == xla::PRIMITIVE_TYPE_INVALID) {\n-        return op->emitError()\n-               << \"result #\" << index << \" type is not supported\";\n-      }\n-    }\n-    if (subshapes.size() > 1) {\n-      return xla::ShapeUtil::MakeTupleShape(subshapes);\n-    }\n-    return subshapes[0];\n-  }\n-}\n-\n #define I64_ELEMENTS_ATTR_TO_VECTOR(attribute)               \\\n   static std::vector<int64_t> Convert_##attribute(           \\\n       std::optional<mlir::DenseIntElementsAttr> attribute) { \\\n@@ -1488,7 +1466,8 @@ LogicalResult ExportXlaOp(AllGatherOp op, OpLoweringContext ctx) {\n   if (failed(GetTuple(op.getOperation(), op.getOperands(), ctx, operands)))\n     return op.emitOpError(\"failed to get tuple\");\n \n-  mlir::FailureOr<xla::Shape> shape_or = ExtractXlaShape(op.getOperation());\n+  mlir::FailureOr<xla::Shape> shape_or =\n+      xla::ExtractXlaShape(op.getOperation());\n   if (failed(shape_or)) return op.emitOpError(\"failed to extract XLA shape\");\n \n   auto all_gather_dim = op.getAllGatherDim();\n@@ -2051,7 +2030,8 @@ LogicalResult ExportXlaOp(AllReduceOp op, OpLoweringContext ctx) {\n   if (failed(GetTuple(op.getOperation(), op.getOperands(), ctx, operands)))\n     return failure();\n \n-  mlir::FailureOr<xla::Shape> shape_or = ExtractXlaShape(op.getOperation());\n+  mlir::FailureOr<xla::Shape> shape_or =\n+      xla::ExtractXlaShape(op.getOperation());\n   if (failed(shape_or)) return failure();\n   if (shape_or->IsTuple()) {\n     std::optional<xla::Shape> shape_with_layout = std::nullopt;\n@@ -2121,7 +2101,8 @@ LogicalResult ExportXlaOp(AllToAllOp op, OpLoweringContext ctx) {\n     return failure();\n   }\n \n-  mlir::FailureOr<xla::Shape> shape_or = ExtractXlaShape(op.getOperation());\n+  mlir::FailureOr<xla::Shape> shape_or =\n+      xla::ExtractXlaShape(op.getOperation());\n   if (failed(shape_or)) return failure();\n   if (shape_or->IsTuple()) {\n     std::optional<xla::Layout> layout = std::nullopt;\n@@ -3224,7 +3205,8 @@ LogicalResult ExportXlaOp(AllGatherOp op, OpLoweringContext ctx) {\n     return failure();\n   }\n \n-  mlir::FailureOr<xla::Shape> shape_or = ExtractXlaShape(op.getOperation());\n+  mlir::FailureOr<xla::Shape> shape_or =\n+      xla::ExtractXlaShape(op.getOperation());\n   if (failed(shape_or)) return failure();\n \n   auto all_gather_dim = op.getAllGatherDim();\n@@ -3275,7 +3257,8 @@ LogicalResult ExportXlaOp(AllReduceOp op, OpLoweringContext ctx) {\n   if (failed(GetTuple(op.getOperation(), op.getOperands(), ctx, operands)))\n     return failure();\n \n-  mlir::FailureOr<xla::Shape> shape_or = ExtractXlaShape(op.getOperation());\n+  mlir::FailureOr<xla::Shape> shape_or =\n+      xla::ExtractXlaShape(op.getOperation());\n   if (failed(shape_or)) return failure();\n   if (shape_or->IsTuple()) {\n     std::optional<xla::Shape> shape_with_layout = std::nullopt;\n@@ -3303,7 +3286,8 @@ LogicalResult ExportXlaOp(AllToAllOp op, OpLoweringContext ctx) {\n     return failure();\n   }\n \n-  mlir::FailureOr<xla::Shape> shape_or = ExtractXlaShape(op.getOperation());\n+  mlir::FailureOr<xla::Shape> shape_or =\n+      xla::ExtractXlaShape(op.getOperation());\n   if (failed(shape_or)) return failure();\n   if (shape_or->IsTuple()) {\n     std::optional<xla::Layout> layout = std::nullopt;\n@@ -5492,7 +5476,7 @@ LogicalResult ConvertToHloModule::PropagateLayouts(\n     auto* shape = xla::internal::XlaBuilderFriend::GetInstruction(xla_op)\n                       ->mutable_shape();\n     // TODO(kramm): merge this with ConvertLayout.\n-    mlir::FailureOr<xla::Shape> mlir_shape_or = ExtractXlaShape(inst);\n+    mlir::FailureOr<xla::Shape> mlir_shape_or = xla::ExtractXlaShape(inst);\n     if (failed(mlir_shape_or)) return failure();\n     *shape = mlir_shape_or->ToProto();\n   }\n@@ -5653,7 +5637,7 @@ LogicalResult ConvertToHloModule::LowerConstant(\n         \"expected shaped type during constant mhlo -> hlo translation\");\n   }\n \n-  mlir::FailureOr<xla::Shape> shape_or = ExtractXlaShape(inst);\n+  mlir::FailureOr<xla::Shape> shape_or = xla::ExtractXlaShape(inst);\n   if (failed(shape_or)) return failure();\n \n   auto literal_or ="
        }
    ],
    "stats": {
        "total": 71,
        "additions": 41,
        "deletions": 30
    }
}