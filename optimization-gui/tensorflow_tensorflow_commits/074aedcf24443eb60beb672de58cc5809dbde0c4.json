{
    "author": "junwhanahn",
    "message": "Use a proper error code for bad user inputs\n\n`RET_CHECK` uses `INTERNAL` as an error code and should be used only for cases where `CHECK` is appropriate, e.g., violation of an internal invariant. We should use a more informative error code for cases that can be caused by bad user inputs such as wrong shapes or signature names.\n\nPiperOrigin-RevId: 800112459",
    "sha": "074aedcf24443eb60beb672de58cc5809dbde0c4",
    "files": [
        {
            "sha": "35e1d22295f26193bde085e9133a439a822a7953",
            "filename": "tensorflow/core/tfrt/saved_model/saved_model.cc",
            "status": "modified",
            "additions": 59,
            "deletions": 36,
            "changes": 95,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/074aedcf24443eb60beb672de58cc5809dbde0c4/tensorflow%2Fcore%2Ftfrt%2Fsaved_model%2Fsaved_model.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/074aedcf24443eb60beb672de58cc5809dbde0c4/tensorflow%2Fcore%2Ftfrt%2Fsaved_model%2Fsaved_model.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Ftfrt%2Fsaved_model%2Fsaved_model.cc?ref=074aedcf24443eb60beb672de58cc5809dbde0c4",
            "patch": "@@ -287,20 +287,24 @@ absl::Status RunBefInitializers(\n absl::Status IsInputSpecsCorrect(absl::string_view name,\n                                  const internal::Signature& signature,\n                                  absl::Span<const tensorflow::Tensor> inputs) {\n-  TF_RET_CHECK(signature.input_specs.size() == inputs.size())\n-      << \"signature \" << name\n-      << \" input size is wrong, expected: \" << signature.input_specs.size()\n-      << \", actual: \" << inputs.size();\n+  if (signature.input_specs.size() != inputs.size()) {\n+    return absl::InvalidArgumentError(absl::StrCat(\n+        \"signature \", name, \" input size is wrong, expected: \",\n+        signature.input_specs.size(), \", actual: \", inputs.size()));\n+  }\n   for (size_t i = 0; i < inputs.size(); ++i) {\n     const auto& expected_input_spec = signature.input_specs[i];\n-    TF_RET_CHECK(expected_input_spec.dtype == inputs[i].dtype())\n-        << \"signature \" << name\n-        << \" input dtype is wrong, expected: \" << expected_input_spec.dtype\n-        << \", actual: \" << inputs[i].dtype();\n-    TF_RET_CHECK(expected_input_spec.shape.IsCompatibleWith(inputs[i].shape()))\n-        << \"signature \" << name\n-        << \" input shape is wrong, expected : \" << expected_input_spec.shape\n-        << \", actual: \" << inputs[i].shape();\n+    if (expected_input_spec.dtype != inputs[i].dtype()) {\n+      return absl::InvalidArgumentError(absl::StrCat(\n+          \"signature \", name, \" input dtype is wrong, expected: \",\n+          expected_input_spec.dtype, \", actual: \", inputs[i].dtype()));\n+    }\n+    if (!expected_input_spec.shape.IsCompatibleWith(inputs[i].shape())) {\n+      return absl::InvalidArgumentError(\n+          absl::StrCat(\"signature \", name, \" input shape is wrong, expected : \",\n+                       expected_input_spec.shape.DebugString(),\n+                       \", actual: \", inputs[i].shape().DebugString()));\n+    }\n   }\n   return absl::OkStatus();\n }\n@@ -348,10 +352,11 @@ absl::Status PreprocessSignature(\n   TF_RETURN_IF_ERROR(CheckInputSpecs(model_metadata, run_options,\n                                      signature_name, signature, input_tensors));\n \n-  TF_RET_CHECK(input_tensors.size() == signature_def.inputs().size())\n-      << \"Incorrect input size for signature: \" << signature_name\n-      << \": expected \" << signature_def.inputs().size() << \", but got \"\n-      << input_tensors.size();\n+  if (input_tensors.size() != signature_def.inputs().size()) {\n+    return absl::InvalidArgumentError(absl::StrCat(\n+        \"Incorrect input size for signature: \", signature_name, \": expected \",\n+        signature_def.inputs().size(), \", but got \", input_tensors.size()));\n+  }\n   DCHECK_EQ(input_names.size(), signature_def.inputs().size());\n \n   // Then we find out the corresponding tensor names (ie.\n@@ -365,9 +370,11 @@ absl::Status PreprocessSignature(\n     // TODO(b/184675681): Support other encoding cases.\n     //\n     // TODO(b/184679394): Add unit test for this check.\n-    TF_RET_CHECK(tensor_info.encoding_case() == tensorflow::TensorInfo::kName)\n-        << \"Only dense tensor is supported, but got encoding case \"\n-        << tensor_info.encoding_case();\n+    if (tensor_info.encoding_case() != tensorflow::TensorInfo::kName) {\n+      return absl::UnimplementedError(\n+          absl::StrCat(\"Only dense tensor is supported, but got encoding case \",\n+                       tensor_info.encoding_case()));\n+    }\n \n     const auto& tensor_name = tensor_info.name();\n \n@@ -387,9 +394,11 @@ absl::Status PreprocessSignature(\n     VLOG(1) << \"Importing Signature Output: output_key = \" << output_key\n             << \", tensor_info = \" << tensor_info.DebugString();\n \n-    TF_RET_CHECK(tensor_info.encoding_case() == tensorflow::TensorInfo::kName)\n-        << \"Only dense tensor is supported, but got encoding case \"\n-        << tensor_info.encoding_case();\n+    if (tensor_info.encoding_case() != tensorflow::TensorInfo::kName) {\n+      return absl::UnimplementedError(\n+          absl::StrCat(\"Only dense tensor is supported, but got encoding case \",\n+                       tensor_info.encoding_case()));\n+    }\n \n     output_tensor_names.push_back(tensor_info.name());\n   }\n@@ -927,12 +936,16 @@ absl::Status SavedModelImpl::Run(const RunOptions& run_options,\n                                  absl::string_view name,\n                                  absl::Span<const tensorflow::Tensor> inputs,\n                                  std::vector<tensorflow::Tensor>* outputs) {\n-  TF_RET_CHECK(outputs) << \"outputs must be provided\";\n+  if (!outputs) {\n+    return absl::InvalidArgumentError(\"outputs must be provided\");\n+  }\n   outputs->clear();\n \n   auto sig_iter = signatures_.find(name);\n-  TF_RET_CHECK(sig_iter != signatures_.end())\n-      << \"failed to find signature \" << name << \" in the graph\";\n+  if (sig_iter == signatures_.end()) {\n+    return absl::NotFoundError(\n+        absl::StrCat(\"failed to find signature \", name, \" in the graph\"));\n+  }\n   const auto& signature = sig_iter->second;\n   const auto& signature_def = meta_graph_def_.signature_def().at(name);\n   const tensorflow::SessionMetadata& model_metadata =\n@@ -1035,9 +1048,13 @@ absl::Status SavedModelImpl::RunMultipleSignatures(\n     const RunOptions& run_options, absl::Span<const std::string> names,\n     absl::Span<const std::vector<tensorflow::Tensor>> multi_inputs,\n     std::vector<std::vector<tensorflow::Tensor>>* multi_outputs) {\n-  TF_RET_CHECK(names.size() == multi_inputs.size())\n-      << \"the sizes of names and inputs should be the same\";\n-  TF_RET_CHECK(multi_outputs) << \"outputs must be provided\";\n+  if (names.size() != multi_inputs.size()) {\n+    return absl::InvalidArgumentError(\n+        \"the sizes of names and inputs should be the same\");\n+  }\n+  if (!multi_outputs) {\n+    return absl::InvalidArgumentError(\"outputs must be provided\");\n+  }\n   multi_outputs->clear();\n \n   // Due to possible overlapping of feed nodes among user-specified inputs, We\n@@ -1059,8 +1076,10 @@ absl::Status SavedModelImpl::RunMultipleSignatures(\n     auto sig_iter = signature_defs.find(signature_name);\n \n     // Early out if any signature can't be found.\n-    TF_RET_CHECK(sig_iter != signature_defs.end())\n-        << \"failed to find signature in the graph\";\n+    if (sig_iter == signature_defs.end()) {\n+      return absl::NotFoundError(absl::StrCat(\"failed to find signature \",\n+                                              signature_name, \" in the graph\"));\n+    }\n     const auto& signature_def = sig_iter->second;\n \n     // `signatures_` keeps the user-specified input names that is in the same\n@@ -1173,9 +1192,11 @@ absl::StatusOr<JoinedSignature> JoinSignatures(\n       // TODO(b/184675681): Support other encoding cases.\n       //\n       // TODO(b/184679394): Add unit test for this check.\n-      TF_RET_CHECK(tensor_info.encoding_case() == tensorflow::TensorInfo::kName)\n-          << \"Only dense tensor is supported, but got encoding case \"\n-          << tensor_info.encoding_case();\n+      if (tensor_info.encoding_case() != tensorflow::TensorInfo::kName) {\n+        return absl::UnimplementedError(absl::StrCat(\n+            \"Only dense tensor is supported, but got encoding case \",\n+            tensor_info.encoding_case()));\n+      }\n \n       VLOG(1) << \"Importing Signature Input: input_key = \" << iter.first\n               << \", tensor_info = \" << tensor_info.DebugString();\n@@ -1205,9 +1226,11 @@ absl::StatusOr<JoinedSignature> JoinSignatures(\n       VLOG(1) << \"Importing Signature Output: output_key = \" << output_key\n               << \", tensor_info = \" << tensor_info.DebugString();\n \n-      TF_RET_CHECK(tensor_info.encoding_case() == tensorflow::TensorInfo::kName)\n-          << \"Only dense tensor is supported, but got encoding case \"\n-          << tensor_info.encoding_case();\n+      if (tensor_info.encoding_case() != tensorflow::TensorInfo::kName) {\n+        return absl::UnimplementedError(absl::StrCat(\n+            \"Only dense tensor is supported, but got encoding case \",\n+            tensor_info.encoding_case()));\n+      }\n \n       joined_signature.output_nodes.push_back(tensor_info.name());\n     }"
        }
    ],
    "stats": {
        "total": 95,
        "additions": 59,
        "deletions": 36
    }
}