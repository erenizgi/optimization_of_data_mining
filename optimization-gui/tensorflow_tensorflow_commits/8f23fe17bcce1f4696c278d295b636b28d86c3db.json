{
    "author": "ezhulenev",
    "message": "[xla] Migrate to PjRtFuture<>::MakePromise() API\n\nSome of the Schedule() APIs require copyable std::function parameter, in such cases wrap move-only promise into std::shared_ptr\n\nPiperOrigin-RevId: 805900653",
    "sha": "8f23fe17bcce1f4696c278d295b636b28d86c3db",
    "files": [
        {
            "sha": "d5fb10ea1b919d6e3d6c9abd65fc3473c6287bb5",
            "filename": "third_party/xla/xla/python/ifrt/ir/transforms/multi_threaded_atom_program_compiler.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8f23fe17bcce1f4696c278d295b636b28d86c3db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8f23fe17bcce1f4696c278d295b636b28d86c3db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fir%2Ftransforms%2Fmulti_threaded_atom_program_compiler.cc?ref=8f23fe17bcce1f4696c278d295b636b28d86c3db",
            "patch": "@@ -202,15 +202,14 @@ absl::StatusOr<CompileFuture> MultiThreadedAtomProgramCompiler::CompileXla(\n   auto hlo_program = std::make_unique<HloProgram>(\n       /*context=*/nullptr,  // Shares the same long-living context.\n       mlir::OwningOpRef<mlir::ModuleOp>(module_op.clone()));\n-  Promise<AtomProgramCompileResult> promise = CompileFuture::CreatePromise();\n-  CompileFuture future(promise);\n+  auto [promise, future] = CompileFuture::MakePromise();\n   ScheduleWork(thread_pool, [this, hlo_program = std::move(hlo_program),\n                              compile_options = std::move(compile_options),\n                              promise = std::move(promise)]() mutable {\n     promise.Set(compiler_->CompileXla(std::move(hlo_program),\n                                       std::move(compile_options)));\n   });\n-  return future;\n+  return std::move(future);\n }\n \n absl::StatusOr<CompileFuture>\n@@ -243,8 +242,7 @@ MultiThreadedAtomProgramCompiler::CompileMpmdReshard(mlir::ModuleOp module_op) {\n         << \"Unsupported return type `\" << mlir::debugString(result_type) << \"`\";\n     out_arrays_types.push_back(array_type);\n   }\n-  auto promise = CompileFuture::CreatePromise();\n-  CompileFuture future(promise);\n+  auto [promise, future] = CompileFuture::MakePromise();\n   // No need to dispatch from a different thread because MpmdReshard uses its\n   // own thread pool already.\n   auto compile_result = compiler_->CompileMpmdReshard("
        },
        {
            "sha": "cd85ece09c4d9f8ffaabf81a969919b3fd4394dc",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/host_buffer_test.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8f23fe17bcce1f4696c278d295b636b28d86c3db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_buffer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8f23fe17bcce1f4696c278d295b636b28d86c3db/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_buffer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fhost_buffer_test.cc?ref=8f23fe17bcce1f4696c278d295b636b28d86c3db",
            "patch": "@@ -17,6 +17,7 @@\n #include <cstdint>\n #include <memory>\n #include <string>\n+#include <utility>\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n@@ -57,15 +58,15 @@ TEST(HostBufferStoreTest, WriteAfterReadStarted) {\n   HostBufferStore store;\n   const uint64_t kHandle = 1;\n \n-  auto lookup_promise =\n-      Future<std::shared_ptr<const std::string>>::CreatePromise();\n-  Future<std::shared_ptr<const std::string>> lookup_fut(lookup_promise);\n+  auto [lookup_promise, lookup_fut] =\n+      Future<std::shared_ptr<const std::string>>::MakePromise();\n \n   absl::Notification closure_started;\n-  tsl::Env::Default()->SchedClosure([&]() {\n-    closure_started.Notify();\n-    lookup_promise.Set(store.Lookup(kHandle, /*timeout=*/absl::Seconds(10)));\n-  });\n+  tsl::Env::Default()->SchedClosure(\n+      [&, promise = std::move(lookup_promise)]() mutable {\n+        closure_started.Notify();\n+        promise.Set(store.Lookup(kHandle, /*timeout=*/absl::Seconds(10)));\n+      });\n \n   closure_started.WaitForNotification();\n   absl::SleepFor(absl::Seconds(1));\n@@ -79,15 +80,14 @@ TEST(HostBufferStoreTest, ShutdownAfterReadStarted) {\n   HostBufferStore store;\n   const uint64_t kHandle = 1;\n \n-  auto lookup_promise =\n-      Future<std::shared_ptr<const std::string>>::CreatePromise();\n-  Future<std::shared_ptr<const std::string>> lookup_fut(lookup_promise);\n+  auto [lookup_promise, lookup_fut] =\n+      Future<std::shared_ptr<const std::string>>::MakePromise();\n \n   absl::Notification closure_started;\n-  tsl::Env::Default()->SchedClosure([&]() {\n+  tsl::Env::Default()->SchedClosure([&, promise = std::move(\n+                                            lookup_promise)]() mutable {\n     closure_started.Notify();\n-    lookup_promise.Set(\n-        store.Lookup(kHandle, /*timeout=*/absl::InfiniteDuration()));\n+    promise.Set(store.Lookup(kHandle, /*timeout=*/absl::InfiniteDuration()));\n   });\n \n   closure_started.WaitForNotification();"
        },
        {
            "sha": "3e2c487f8b7fd0191df1b57bb9077fe6eef89f51",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/basic_string_array.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8f23fe17bcce1f4696c278d295b636b28d86c3db/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8f23fe17bcce1f4696c278d295b636b28d86c3db/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fbasic_string_array.cc?ref=8f23fe17bcce1f4696c278d295b636b28d86c3db",
            "patch": "@@ -19,6 +19,7 @@ limitations under the License.\n #include <memory>\n #include <optional>\n #include <string>\n+#include <tuple>\n #include <utility>\n #include <vector>\n \n@@ -211,8 +212,8 @@ BasicStringArray::DisassembleIntoSingleDeviceArrays(\n   on_done_with_buffer_callbacks.reserve(num_shards);\n \n   for (int i = 0; i < num_shards; ++i) {\n-    buffer_promises.push_back(Future<Buffers>::CreatePromise());\n-    buffer_futures.push_back(Future<Buffers>(buffer_promises.back()));\n+    std::tie(buffer_promises.emplace_back(), buffer_futures.emplace_back()) =\n+        Future<Buffers>::MakePromise();\n \n     auto current_shard_strings = std::make_shared<PerShardStringStore>();\n     per_shard_strings.push_back(current_shard_strings);\n@@ -328,8 +329,7 @@ absl::StatusOr<ArrayRef> BasicStringArray::Copy(\n \n   auto string_store = std::make_shared<StringStore>();\n   auto on_done_with_buffer = [string_store]() {};\n-  auto buffers_promise = Future<Buffers>::CreatePromise();\n-  auto buffers_future = Future<Buffers>(buffers_promise);\n+  auto [buffers_promise, buffers_future] = Future<Buffers>::MakePromise();\n \n   auto copier = [string_store = std::move(string_store),\n                  buffers_promise = std::move(buffers_promise)](\n@@ -378,8 +378,7 @@ absl::StatusOr<ArrayRef> BasicStringArray::FullyReplicatedShard(\n \n   auto string_store = std::make_shared<StringStore>();\n   auto on_done_with_buffer = [string_store]() {};\n-  auto buffers_promise = Future<Buffers>::CreatePromise();\n-  auto buffers_future = Future<Buffers>(buffers_promise);\n+  auto [buffers_promise, buffers_future] = Future<Buffers>::MakePromise();\n \n   auto copier = [string_store = std::move(string_store),\n                  buffers_promise = std::move(buffers_promise)]("
        },
        {
            "sha": "e425388754be64b136a57afc187eec57477c3fff",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_client.cc",
            "status": "modified",
            "additions": 13,
            "deletions": 11,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8f23fe17bcce1f4696c278d295b636b28d86c3db/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8f23fe17bcce1f4696c278d295b636b28d86c3db/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_client.cc?ref=8f23fe17bcce1f4696c278d295b636b28d86c3db",
            "patch": "@@ -656,11 +656,12 @@ absl::StatusOr<ArrayRef> AssembleStringArrayFromSingleDeviceStringArrays(\n   auto buffer_copying_state = std::make_shared<BufferCopyingState>(\n       arrays.size(), std::move(buffer_backing_store));\n \n-  auto buffers_promise = Future<BasicStringArray::Buffers>::CreatePromise();\n-  auto buffers_future = Future<BasicStringArray::Buffers>(buffers_promise);\n+  auto [buffers_promise, buffers_future] =\n+      Future<BasicStringArray::Buffers>::MakePromise();\n \n   auto buffer_copier = [state = buffer_copying_state,\n-                        promise = buffers_promise](\n+                        promise = std::make_shared<decltype(buffers_promise)>(\n+                            std::move(buffers_promise))](\n                            absl::StatusOr<BasicStringArray::Buffers> strbuf,\n                            int shard_index) mutable {\n     absl::MutexLock lock(&state->mu);\n@@ -670,7 +671,7 @@ absl::StatusOr<ArrayRef> AssembleStringArrayFromSingleDeviceStringArrays(\n       return;\n     }\n     if (!strbuf.ok()) {\n-      promise.Set(strbuf.status());\n+      promise->Set(strbuf.status());\n       state->num_buffers_to_copy = 0;  // Don't copy any more buffers.\n \n       // Release the partially copied buffers and reclaim the memory.\n@@ -688,7 +689,7 @@ absl::StatusOr<ArrayRef> AssembleStringArrayFromSingleDeviceStringArrays(\n       return;  // We have more single device arrays we need to wait for.\n     }\n     // We have all the buffers. Set the promise.\n-    promise.Set(std::move(state->buffers));\n+    promise->Set(std::move(state->buffers));\n   };\n \n   for (int i = 0; i < arrays.size(); ++i) {\n@@ -706,7 +707,7 @@ absl::StatusOr<ArrayRef> AssembleStringArrayFromSingleDeviceStringArrays(\n     }\n \n     basic_string_array->buffers().OnReady(\n-        [shard_index = i, buffer_copier = buffer_copier](\n+        [shard_index = i, buffer_copier](\n             absl::StatusOr<BasicStringArray::Buffers> strbuf) mutable {\n           buffer_copier(std::move(strbuf), shard_index);\n         });\n@@ -1506,22 +1507,23 @@ absl::Status PjRtClient::CrossHostSendBuffers(\n   // TODO(emilyaf): Use an async version of KeyValueStore::Get or query batched\n   // keys together to reduce the number of threads used.\n   for (int i = 0; i < keys.size(); ++i) {\n-    auto promise = PjRtFuture<std::string>::CreatePromise();\n-    PjRtFuture<std::string> descriptor_future(promise);\n-    work_queue_->Schedule([this, &promise, k = keys[i]] {\n+    auto [promise, descriptor_future] = PjRtFuture<std::string>::MakePromise();\n+    work_queue_->Schedule([this, k = keys[i],\n+                           promise = std::make_shared<decltype(promise)>(\n+                               std::move(promise))]() mutable {\n       std::string key = absl::StrCat(kKeyPrefix, k);\n       absl::StatusOr<std::string> descriptor =\n           kv_store_->Get(key, cross_host_transfer_timeout_);\n       if (!descriptor.ok()) {\n         LOG(FATAL) << \"Failed to get descriptor for key \" << key << \": \"\n                    << descriptor.status();\n       }\n-      promise.Set(std::move(*descriptor));\n+      promise->Set(std::move(*descriptor));\n     });\n     auto on_done = [](absl::Status status, bool sends_were_enqueued) {\n       CHECK_OK(status);\n     };\n-    buffers[i]->CopyToRemoteDevice(descriptor_future, on_done);\n+    buffers[i]->CopyToRemoteDevice(std::move(descriptor_future), on_done);\n   }\n   return absl::OkStatus();\n }"
        }
    ],
    "stats": {
        "total": 69,
        "additions": 34,
        "deletions": 35
    }
}