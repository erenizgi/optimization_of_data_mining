{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 808396991",
    "sha": "1541b8da01335bdb87821bf5bcd8baf4cee19512",
    "files": [
        {
            "sha": "714ea57e47c43c776c402e6df8f1987b93c2bf3b",
            "filename": "third_party/xla/xla/python/ifrt_proxy/common/test_utils.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1541b8da01335bdb87821bf5bcd8baf4cee19512/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Ftest_utils.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1541b8da01335bdb87821bf5bcd8baf4cee19512/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Ftest_utils.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Ftest_utils.cc?ref=1541b8da01335bdb87821bf5bcd8baf4cee19512",
            "patch": "@@ -32,17 +32,17 @@ namespace {\n class Overrides {\n  public:\n   void Set(TestHookName h, std::function<void(bool*)> fn) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     overrides_[h] = std::move(fn);\n   }\n \n   void Clear(TestHookName h) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     overrides_.erase(h);\n   }\n \n   void Call(TestHookName h, bool* param1) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     const auto it = overrides_.find(h);\n     if (it != overrides_.end()) {\n       it->second(param1);"
        },
        {
            "sha": "37ce4c3cdff90ee6c9f3ad530162f93174d0aaf5",
            "filename": "third_party/xla/xla/python/ifrt_proxy/common/test_utils.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1541b8da01335bdb87821bf5bcd8baf4cee19512/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Ftest_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1541b8da01335bdb87821bf5bcd8baf4cee19512/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Ftest_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fcommon%2Ftest_utils.h?ref=1541b8da01335bdb87821bf5bcd8baf4cee19512",
            "patch": "@@ -39,15 +39,15 @@ class TestQueue {\n \n   // Pushes `t` into the queue.\n   void Push(T t) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     queue_.push_back(std::move(t));\n   }\n \n   // Pops the first element in the queue if a element is already available or\n   // appears within `pop_timeout` (because `Push` is called). Otherwise returns\n   // std::nullopt.\n   std::optional<T> PopOrTimeout() {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     auto cond = [this]() ABSL_SHARED_LOCKS_REQUIRED(mu_) -> bool {\n       return !queue_.empty();\n     };\n@@ -71,14 +71,14 @@ class TestQueue {\n   // Sets whether the queue is allowed to be destructed while it contains\n   // unpopped elements.\n   void AllowNonEmptyDestruction(bool allow) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     allow_non_empty_destruction_ = allow;\n   }\n \n   // Checks that the queue is either empty, or `AllowNonEmptyDestruction(true)`\n   // has been called.\n   ~TestQueue() {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     if (!allow_non_empty_destruction_) CHECK(queue_.empty()) << \" \" << this;\n   }\n "
        }
    ],
    "stats": {
        "total": 14,
        "additions": 7,
        "deletions": 7
    }
}