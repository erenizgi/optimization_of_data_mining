{
    "author": "basioli-k",
    "message": "[XLA:CPU] Remove CpuExecutableAotCompilationResult.\n\nPiperOrigin-RevId: 810407755",
    "sha": "cf4ea00a06f04952628db9420872932e1729180c",
    "files": [
        {
            "sha": "c2b9cc26d5d461e2b014c460a5ae6acc67466817",
            "filename": "tensorflow/compiler/tf2xla/xla_compiled_cpu_function_thunks.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf4ea00a06f04952628db9420872932e1729180c/tensorflow%2Fcompiler%2Ftf2xla%2Fxla_compiled_cpu_function_thunks.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf4ea00a06f04952628db9420872932e1729180c/tensorflow%2Fcompiler%2Ftf2xla%2Fxla_compiled_cpu_function_thunks.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Ftf2xla%2Fxla_compiled_cpu_function_thunks.cc?ref=cf4ea00a06f04952628db9420872932e1729180c",
            "patch": "@@ -44,7 +44,7 @@ XlaCompiledCpuFunctionThunks::XlaCompiledCpuFunctionThunks(\n \n   auto aot_compilation_result = xla::cpu::CpuAotCompilationResult::FromString(\n       static_data.compilation_result_proto_->SerializeAsString(),\n-      function_library.release());\n+      std::move(function_library));\n \n   // To load a CPU executable we don't need a compiler or a stream executor.\n   TF_CHECK_OK(aot_compilation_result.status());"
        },
        {
            "sha": "1ce0f7a582addc896f93fd197d2435534d8c50ee",
            "filename": "third_party/xla/xla/service/cpu/cpu_aot_compilation_result.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 33,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf4ea00a06f04952628db9420872932e1729180c/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_compilation_result.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf4ea00a06f04952628db9420872932e1729180c/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_compilation_result.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_compilation_result.cc?ref=cf4ea00a06f04952628db9420872932e1729180c",
            "patch": "@@ -74,12 +74,12 @@ se::Platform::Id CpuAotCompilationOptions::PlatformId() const {\n   return se::host::kHostPlatformId;\n }\n \n-/*static*/ absl::StatusOr<std::unique_ptr<CpuAotCompilationResult>>\n+absl::StatusOr<std::unique_ptr<CpuAotCompilationResult>>\n CpuAotCompilationResult::Create(\n     const HloModule* hlo_module, const BufferAssignment* buffer_assignment,\n     absl::string_view function_name, std::vector<ObjFileProto> obj_files,\n     std::vector<SymbolProto> symbols, const ThunkSequence& thunks,\n-    FunctionLibrary* function_library,\n+    std::unique_ptr<FunctionLibrary> function_library,\n     std::unique_ptr<HloProfilePrinterData> hlo_profile_printer_data) {\n   ThunkSequenceSerDesProtobuf thunk_sequence_serdes(\n       &buffer_assignment->Allocations());\n@@ -118,7 +118,7 @@ CpuAotCompilationResult::CpuAotCompilationResult(\n     std::vector<SymbolProto> symbols, const ThunkSequenceProto& thunks,\n     std::optional<size_t> temp_allocation_index,\n     std::vector<cpu_function_runtime::BufferInfo> buffer_infos,\n-    FunctionLibrary* function_library,\n+    std::unique_ptr<FunctionLibrary> function_library,\n     std::unique_ptr<HloProfilePrinterData> hlo_profile_printer_data)\n     : temp_allocation_index_(temp_allocation_index),\n       buffer_infos_(std::move(buffer_infos)),\n@@ -149,9 +149,6 @@ absl::StatusOr<std::unique_ptr<Executable>>\n CpuAotCompilationResult::LoadExecutable(\n     [[maybe_unused]] Compiler* compiler,\n     const se::StreamExecutor* stream_exec) && {\n-  // Compiler would be used only to get the BufferSizeBytesFunction. Doing this\n-  // we ensure the user doesn't expect a different function to be used.\n-  CHECK(compiler == nullptr);\n   TF_ASSIGN_OR_RETURN(\n       std::unique_ptr<HloModule> module,\n       HloModule::CreateFromProtoWithConfig(proto_.hlo_module()));\n@@ -160,7 +157,7 @@ CpuAotCompilationResult::LoadExecutable(\n \n   // Copied from cpu_compiler.cc in order to avoid dependency on cpu_compiler.\n   std::function<int64_t(const BufferValue&)> buffer_size_bytes_function_getter =\n-      []() {\n+      compiler ? compiler->BufferSizeBytesFunction() : []() {\n         HloCostAnalysis::ShapeSizeFunction shape_size =\n             CpuExecutable::ShapeSizeBytes;\n         return [shape_size](const BufferValue& buffer) {\n@@ -188,38 +185,13 @@ CpuAotCompilationResult::LoadExecutable(\n \n   VLOG(3) << \"Loaded \" << thunks->size() << \" thunks.\";\n \n-  std::vector<FunctionLibrary::Symbol> compiled_symbols;\n-\n-  for (const auto& symbol_proto : proto_.compiled_symbols()) {\n-    switch (symbol_proto.function_type_id()) {\n-      case SymbolProto::KERNEL:\n-        compiled_symbols.push_back(\n-            FunctionLibrary::Sym<FunctionLibrary::Kernel>(symbol_proto.name()));\n-        break;\n-      case SymbolProto::COMPARATOR:\n-        compiled_symbols.push_back(\n-            FunctionLibrary::Sym<FunctionLibrary::Comparator>(\n-                symbol_proto.name()));\n-        break;\n-      default:\n-        return Internal(\n-            \"Unknown function type id %s\",\n-            SymbolProto_FunctionTypeId_Name(symbol_proto.function_type_id()));\n-    }\n-  }\n-\n-  VLOG(3) << \"Collected \" << compiled_symbols.size() << \" compiled symbols\";\n-  for (const auto& symbol : compiled_symbols) {\n-    VLOG(3) << \" Symbol: \" << symbol.name;\n-  }\n-\n   // Create constant allocations from the buffer assignment.\n   TF_ASSIGN_OR_RETURN(std::vector<ConstantAllocation> constants,\n                       CreateConstantAllocations(*buffer_assignment));\n \n   TF_ASSIGN_OR_RETURN(\n       cpu_executable,\n-      CpuExecutable::Create(absl::WrapUnique(function_library_),\n+      CpuExecutable::Create(std::move(function_library_),\n                             std::move(buffer_assignment), std::move(module),\n                             std::move(*thunks), std::move(constants), nullptr,\n                             nullptr));"
        },
        {
            "sha": "9d477c255fe6df223bcac8867caa36b54d0ab5e3",
            "filename": "third_party/xla/xla/service/cpu/cpu_aot_compilation_result.h",
            "status": "modified",
            "additions": 31,
            "deletions": 15,
            "changes": 46,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf4ea00a06f04952628db9420872932e1729180c/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_compilation_result.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf4ea00a06f04952628db9420872932e1729180c/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_compilation_result.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_aot_compilation_result.h?ref=cf4ea00a06f04952628db9420872932e1729180c",
            "patch": "@@ -106,7 +106,7 @@ class CpuAotCompilationResult : public AotCompilationResult {\n       const HloModule* hlo_module, const BufferAssignment* buffer_assignment,\n       absl::string_view function_name, std::vector<ObjFileProto> obj_files,\n       std::vector<SymbolProto> symbols, const ThunkSequence& thunks,\n-      FunctionLibrary* function_library,\n+      std::unique_ptr<FunctionLibrary> function_library,\n       std::unique_ptr<HloProfilePrinterData> hlo_profile_printer_data);\n \n   ~CpuAotCompilationResult() override = default;\n@@ -156,19 +156,38 @@ class CpuAotCompilationResult : public AotCompilationResult {\n     return hlo_profile_printer_data_.get();\n   }\n \n+  static absl::StatusOr<std::unique_ptr<CpuAotCompilationResult>> FromProto(\n+      CompilationResultProto proto,\n+      std::unique_ptr<FunctionLibrary> function_library) {\n+    TF_ASSIGN_OR_RETURN(\n+        std::unique_ptr<HloModule> module,\n+        HloModule::CreateFromProtoWithConfig(proto.hlo_module()));\n+\n+    return std::unique_ptr<CpuAotCompilationResult>(new CpuAotCompilationResult(\n+        proto, std::move(module), std::move(function_library)));\n+  }\n+\n   static absl::StatusOr<std::unique_ptr<CpuAotCompilationResult>> FromString(\n-      const std::string& serialized, FunctionLibrary* function_library) {\n+      const std::string& serialized,\n+      std::unique_ptr<FunctionLibrary> function_library) {\n     CompilationResultProto proto;\n     if (!proto.ParseFromString(serialized)) {\n       return Internal(\"Failed to parse serialized CpuAotCompilationResult.\");\n     }\n \n-    TF_ASSIGN_OR_RETURN(\n-        std::unique_ptr<HloModule> module,\n-        HloModule::CreateFromProtoWithConfig(proto.hlo_module()));\n+    return FromProto(std::move(proto), std::move(function_library));\n+  }\n \n-    return std::unique_ptr<CpuAotCompilationResult>(new CpuAotCompilationResult(\n-        proto, std::move(module), std::move(function_library)));\n+  // TODO(basioli): legacy API so that tensorflow CI passes, remove in followup\n+  // CL.\n+  static absl::StatusOr<std::unique_ptr<CpuAotCompilationResult>> FromString(\n+      const std::string& serialized, FunctionLibrary* function_library) {\n+    CompilationResultProto proto;\n+    if (!proto.ParseFromString(serialized)) {\n+      return Internal(\"Failed to parse serialized CpuAotCompilationResult.\");\n+    }\n+\n+    return FromProto(std::move(proto), absl::WrapUnique(function_library));\n   }\n \n  private:\n@@ -178,12 +197,12 @@ class CpuAotCompilationResult : public AotCompilationResult {\n       std::vector<SymbolProto> symbols, const ThunkSequenceProto& thunks,\n       std::optional<size_t> temp_allocation_index,\n       std::vector<cpu_function_runtime::BufferInfo> buffer_infos,\n-      FunctionLibrary* function_library,\n+      std::unique_ptr<FunctionLibrary> function_library,\n       std::unique_ptr<HloProfilePrinterData> hlo_profile_printer_data);\n \n-  explicit CpuAotCompilationResult(CompilationResultProto proto,\n-                                   std::unique_ptr<HloModule> module,\n-                                   FunctionLibrary* function_library)\n+  explicit CpuAotCompilationResult(\n+      CompilationResultProto proto, std::unique_ptr<HloModule> module,\n+      std::unique_ptr<FunctionLibrary> function_library)\n       : proto_(std::move(proto)),\n         module_(std::move(module)),\n         function_library_(std::move(function_library)) {}\n@@ -193,10 +212,7 @@ class CpuAotCompilationResult : public AotCompilationResult {\n   std::optional<size_t> temp_allocation_index_;\n   std::vector<cpu_function_runtime::BufferInfo> buffer_infos_;\n \n-  // Exists only to be moved to the executable on loading, has to be a raw\n-  // pointer because the executable takes ownership of the library, and\n-  // LoadExecutable() is const.\n-  FunctionLibrary* function_library_;\n+  std::unique_ptr<FunctionLibrary> function_library_;\n \n   // Contains an instance of HloProfilePrinterData if HLO profiling is enabled,\n   // otherwise is nullptr."
        },
        {
            "sha": "3074868fb6e29d3e3b5acbd64338f76401a09732",
            "filename": "third_party/xla/xla/service/cpu/cpu_compiler.cc",
            "status": "modified",
            "additions": 83,
            "deletions": 205,
            "changes": 288,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/cf4ea00a06f04952628db9420872932e1729180c/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/cf4ea00a06f04952628db9420872932e1729180c/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc?ref=cf4ea00a06f04952628db9420872932e1729180c",
            "patch": "@@ -2299,7 +2299,7 @@ CpuCompiler::CompileAheadOfTimeThunks(\n       &cpu_executable->module(), &cpu_executable->buffer_assignment(),\n       cpu_executable->module_name(), std::move(obj_files),\n       cpu_executable->get_compiled_symbols_proto(), thunk_sequence,\n-      std::move(*cpu_executable).consume_function_library().release(),\n+      std::move(*cpu_executable).consume_function_library(),\n       std::move(executable_hlo_profile_printer_data));\n }\n \n@@ -2313,130 +2313,45 @@ HloCostAnalysis::ShapeSizeFunction CpuCompiler::ShapeSizeBytesFunction() const {\n \n namespace {\n \n-// TODO(basioli): This should be removed once new runtime is implemented, and\n-// CpuAotCompilationResult will be the only implementation of\n-// AotCompilationResult. This is still used as it allows us to `Export` and\n-// subsequently load both runtimes.\n-\n-// This is a result of exporting JIT compiled\n-// CpuExecutable to AOT compilation result that can be saved on disk and shipped\n-// over the wire.\n-class CpuExecutableAotCompilationResult : public AotCompilationResult {\n- public:\n-  static absl::StatusOr<std::unique_ptr<CpuExecutableAotCompilationResult>>\n-  Create(const HloModule* hlo_module, const BufferAssignment* buffer_assignment,\n-         absl::string_view function_name, std::vector<ObjFileProto> obj_files,\n-         std::vector<SymbolProto> symbols, const ThunkSequence* thunks,\n-         CompilationResultProto::ObjFileKind obj_file_kind) {\n-    std::optional<ThunkSequenceProto> thunk_proto;\n-\n-    if (thunks != nullptr) {\n-      ThunkSequenceSerDesProtobuf thunk_sequence_serdes(\n-          &buffer_assignment->Allocations());\n-      TF_ASSIGN_OR_RETURN(thunk_proto, thunk_sequence_serdes.ToProto(*thunks));\n+absl::StatusOr<std::vector<FunctionLibrary::Symbol>>\n+GetCompiledSymbolsFromProto(\n+    absl::Span<const SymbolProto> compiled_symbols_proto) {\n+  std::vector<FunctionLibrary::Symbol> compiled_symbols;\n+  for (const auto& symbol_proto : compiled_symbols_proto) {\n+    switch (symbol_proto.function_type_id()) {\n+      case SymbolProto::KERNEL:\n+        compiled_symbols.push_back(\n+            FunctionLibrary::Sym<FunctionLibrary::Kernel>(symbol_proto.name()));\n+        break;\n+      case SymbolProto::COMPARATOR:\n+        compiled_symbols.push_back(\n+            FunctionLibrary::Sym<FunctionLibrary::Comparator>(\n+                symbol_proto.name()));\n+        break;\n+      default:\n+        return Internal(\n+            \"Unknown function type id %s\",\n+            SymbolProto_FunctionTypeId_Name(symbol_proto.function_type_id()));\n     }\n-\n-    return absl::WrapUnique(new CpuExecutableAotCompilationResult(\n-        hlo_module, buffer_assignment, function_name, std::move(obj_files),\n-        std::move(symbols), thunk_proto, obj_file_kind));\n   }\n-\n-  absl::StatusOr<std::string> SerializeAsString() const override {\n-    return proto_.SerializeAsString();\n-  }\n-\n-  static absl::StatusOr<std::unique_ptr<CpuExecutableAotCompilationResult>>\n-  FromString(const std::string& serialized) {\n-    CompilationResultProto proto;\n-    if (!proto.ParseFromString(serialized)) {\n-      return Internal(\n-          \"Failed to parse serialized CpuExecutableAotCompilationResult.\");\n-    }\n-\n-    TF_ASSIGN_OR_RETURN(\n-        std::unique_ptr<HloModule> module,\n-        HloModule::CreateFromProtoWithConfig(proto.hlo_module()));\n-\n-    return std::unique_ptr<CpuExecutableAotCompilationResult>(\n-        new CpuExecutableAotCompilationResult(proto, std::move(module)));\n-  }\n-\n-  absl::StatusOr<std::unique_ptr<Executable>> LoadExecutable(\n-      Compiler* compiler, const se::StreamExecutor* stream_exec) &&\n-      override;\n-\n-  const HloModule* optimized_module() const override { return module_.get(); }\n-\n-  std::unique_ptr<HloModule> consume_optimized_module() override {\n-    return std::move(module_);\n-  }\n-\n- private:\n-  CpuExecutableAotCompilationResult(\n-      const HloModule* hlo_module, const BufferAssignment* buffer_assignment,\n-      absl::string_view function_name, std::vector<ObjFileProto> obj_files,\n-      std::vector<SymbolProto> symbols,\n-      const std::optional<ThunkSequenceProto>& thunks,\n-      CompilationResultProto::ObjFileKind obj_file_kind) {\n-    *proto_.mutable_hlo_module()->mutable_hlo_module() = hlo_module->ToProto();\n-    *proto_.mutable_hlo_module()->mutable_config() =\n-        hlo_module->config().ToProto();\n-    *proto_.mutable_buffer_assignment() = buffer_assignment->ToProto();\n-    proto_.set_entry_function_name(std::string(function_name));\n-    for (auto& obj_file : obj_files) {\n-      *proto_.add_object_files() = std::move(obj_file);\n-    }\n-\n-    for (const auto& symbol : symbols) {\n-      auto* symbol_proto = proto_.add_compiled_symbols();\n-      *symbol_proto = symbol;\n-    }\n-    proto_.set_obj_files_kind(obj_file_kind);\n-    module_ = hlo_module->Clone();\n-\n-    if (thunks.has_value()) {\n-      ThunkSequenceSerDesProtobuf thunk_sequence_serdes(\n-          &buffer_assignment->Allocations());\n-      *proto_.mutable_thunk_sequence() = *thunks;\n-    }\n+  VLOG(3) << \"Collected \" << compiled_symbols.size() << \" compiled symbols\";\n+  for (const auto& symbol : compiled_symbols) {\n+    VLOG(3) << \" Symbol: \" << symbol.name;\n   }\n \n-  explicit CpuExecutableAotCompilationResult(CompilationResultProto proto,\n-                                             std::unique_ptr<HloModule> module)\n-      : proto_(std::move(proto)), module_(std::move(module)) {}\n-\n-  CompilationResultProto proto_;\n-  std::unique_ptr<HloModule> module_;\n-};\n-\n-}  // namespace\n-\n-absl::StatusOr<std::unique_ptr<Executable>>\n-CpuExecutableAotCompilationResult::LoadExecutable(\n-    Compiler* compiler, const se::StreamExecutor* stream_exec) && {\n-  // Recreate HloModule from proto.\n-  TF_ASSIGN_OR_RETURN(\n-      std::unique_ptr<HloModule> module,\n-      HloModule::CreateFromProtoWithConfig(proto_.hlo_module()));\n-\n-  VLOG(2) << \"Load XLA:CPU executable for module: \" << module->name();\n-\n-  // Recreate BufferAssignment from proto.\n-  AliasInfo alias_info;\n-  TF_ASSIGN_OR_RETURN(std::unique_ptr<BufferAssignment> buffer_assignment,\n-                      BufferAssignment::FromProto(\n-                          proto_.buffer_assignment(), module.get(),\n-                          compiler->BufferSizeBytesFunction(), &alias_info));\n+  return compiled_symbols;\n+}\n \n-  const DebugOptions& debug_options = module->config().debug_options();\n-  VlogMaxIsa(debug_options.xla_cpu_max_isa());\n-  const HloModuleConfig& config = module->config();\n+absl::StatusOr<std::unique_ptr<FunctionLibrary>> LoadFunctionLibrary(\n+    const std::vector<FunctionLibrary::Symbol>& compiled_symbols,\n+    absl::Span<const ObjFileProto> obj_files, const HloModule* hlo_module) {\n+  const HloModuleConfig& config = hlo_module->config();\n+  const DebugOptions& debug_options = config.debug_options();\n \n-  // Infer target machine from the current host CPU.\n   TF_ASSIGN_OR_RETURN(\n       std::unique_ptr<llvm::TargetMachine> target_machine,\n       IrCompiler::InferTargetMachine(\n-          std::move(CompilerTargetOptions(module->config())),\n+          std::move(CompilerTargetOptions(hlo_module->config())),\n           IrCompiler::GetCodeGenOptLevel(config),\n           CpuFeatureFromString(debug_options.xla_cpu_max_isa())));\n \n@@ -2456,95 +2371,18 @@ CpuExecutableAotCompilationResult::LoadExecutable(\n             target_machine->createDataLayout()));\n   }\n \n-  // We might have an XLA:CPU executable that has only runtime thunks and\n-  // doesn't have any corresponding object files, and it's absolutely fine.\n-  VLOG(2) << \"Load XLA:CPU executable from \" << proto_.object_files_size()\n-          << \" object files; entry_function_name=\"\n-          << proto_.entry_function_name();\n-\n-  for (auto& obj_file : proto_.object_files()) {\n+  for (auto& obj_file : obj_files) {\n     llvm::StringRef data(obj_file.contents().data(),\n                          obj_file.contents().size());\n     TF_RETURN_IF_ERROR(object_loader.AddObjFile(\n         llvm::MemoryBuffer::getMemBuffer(data, obj_file.name())));\n   }\n \n-  std::unique_ptr<CpuExecutable> cpu_executable;\n-\n-  if (proto_.obj_files_kind() == CompilationResultProto::KERNELS) {\n-    ThunkSequenceSerDesProtobuf thunk_sequence_serdes(\n-        &buffer_assignment->Allocations());\n-    TF_ASSIGN_OR_RETURN(\n-        std::unique_ptr<ThunkSequence> thunks,\n-        thunk_sequence_serdes.FromProto(proto_.thunk_sequence()));\n-\n-    VLOG(3) << \"Loaded \" << thunks->size() << \" thunks.\";\n-\n-    std::vector<FunctionLibrary::Symbol> compiled_symbols;\n-\n-    for (const auto& symbol_proto : proto_.compiled_symbols()) {\n-      switch (symbol_proto.function_type_id()) {\n-        case SymbolProto::KERNEL:\n-          compiled_symbols.push_back(\n-              FunctionLibrary::Sym<FunctionLibrary::Kernel>(\n-                  symbol_proto.name()));\n-          break;\n-        case SymbolProto::COMPARATOR:\n-          compiled_symbols.push_back(\n-              FunctionLibrary::Sym<FunctionLibrary::Comparator>(\n-                  symbol_proto.name()));\n-          break;\n-        default:\n-          return Internal(\n-              \"Unknown function type id %s\",\n-              SymbolProto_FunctionTypeId_Name(symbol_proto.function_type_id()));\n-      }\n-    }\n-\n-    VLOG(3) << \"Collected \" << compiled_symbols.size() << \" compiled symbols\";\n-    TF_ASSIGN_OR_RETURN(std::unique_ptr<FunctionLibrary> function_library,\n-                        std::move(object_loader).Load(compiled_symbols));\n-\n-    // Create constant allocations from the buffer assignment.\n-    TF_ASSIGN_OR_RETURN(std::vector<ConstantAllocation> constants,\n-                        CreateConstantAllocations(*buffer_assignment));\n-\n-    TF_ASSIGN_OR_RETURN(\n-        cpu_executable,\n-        CpuExecutable::Create(std::move(function_library),\n-                              std::move(buffer_assignment), std::move(module),\n-                              std::move(*thunks), std::move(constants), nullptr,\n-                              nullptr));\n-\n-  } else if (proto_.obj_files_kind() == CompilationResultProto::CLASSIC) {\n-    // Create a \"classic\" CPU executable.\n-    using ComputeFn = std::remove_pointer_t<CpuExecutable::ComputeFunctionType>;\n-    TF_ASSIGN_OR_RETURN(std::unique_ptr<FunctionLibrary> function_library,\n-                        std::move(object_loader)\n-                            .Load({FunctionLibrary::Sym<ComputeFn>(\n-                                proto_.entry_function_name())}));\n-\n-    TF_ASSIGN_OR_RETURN(\n-        cpu_executable,\n-        CpuExecutable::Create(std::move(function_library),\n-                              std::move(buffer_assignment), std::move(module),\n-                              proto_.entry_function_name(), nullptr, nullptr));\n-\n-  } else {\n-    return Internal(\"Unknown obj file kind\");\n-  }\n-\n-  // Dump computation proto state and buffer assignment for\n-  // GetCompiledMemoryStats results.\n-  auto hlo_proto = std::make_unique<HloProto>();\n-  *hlo_proto->mutable_hlo_module() = cpu_executable->module().ToProto();\n-  *hlo_proto->mutable_buffer_assignment() =\n-      cpu_executable->buffer_assignment().ToProto();\n-  cpu_executable->set_hlo_proto(std::move(hlo_proto));\n-\n-  return cpu_executable;\n+  return std::move(object_loader).Load(compiled_symbols);\n }\n \n+}  // namespace\n+\n absl::StatusOr<std::unique_ptr<AotCompilationResult>> CpuCompiler::Export(\n     Executable* executable) const {\n   auto* cpu_executable = tensorflow::down_cast<CpuExecutable*>(executable);\n@@ -2557,25 +2395,65 @@ absl::StatusOr<std::unique_ptr<AotCompilationResult>> CpuCompiler::Export(\n     obj_files.push_back(obj_file);\n   }\n \n-  auto kind = cpu_executable->has_thunks() ? CompilationResultProto::KERNELS\n-                                           : CompilationResultProto::CLASSIC;\n+  if (!cpu_executable->has_thunks()) {\n+    return xla::Internal(\"CpuExecutable should have thunks.\");\n+  }\n   const ThunkSequence* thunk_sequence =\n-      cpu_executable->has_thunks() ? &cpu_executable->thunks().thunk_sequence()\n-                                   : nullptr;\n+      &cpu_executable->thunks().thunk_sequence();\n \n-  std::vector<SymbolProto> compiled_symbols =\n+  std::vector<SymbolProto> compiled_symbols_proto =\n       cpu_executable->get_compiled_symbols_proto();\n \n-  return CpuExecutableAotCompilationResult::Create(\n+  std::unique_ptr<HloProfilePrinterData> executable_hlo_profile_printer_data =\n+      cpu_executable->module().config().hlo_profiling_enabled()\n+          ? std::make_unique<HloProfilePrinterData>(\n+                cpu_executable->hlo_profile_printer_data())\n+          : nullptr;\n+\n+  TF_ASSIGN_OR_RETURN(auto compiled_symbols,\n+                      GetCompiledSymbolsFromProto(compiled_symbols_proto));\n+\n+  TF_ASSIGN_OR_RETURN(auto function_library,\n+                      LoadFunctionLibrary(compiled_symbols, obj_files,\n+                                          &cpu_executable->module()));\n+\n+  return CpuAotCompilationResult::Create(\n       &cpu_executable->module(), &cpu_executable->buffer_assignment(),\n       cpu_executable->module_name(), std::move(obj_files),\n-      std::move(compiled_symbols), thunk_sequence, kind);\n+      std::move(compiled_symbols_proto), *thunk_sequence,\n+      std::move(function_library),\n+      std::move(executable_hlo_profile_printer_data));\n }\n \n absl::StatusOr<std::unique_ptr<AotCompilationResult>>\n CpuCompiler::LoadAotCompilationResult(\n     const std::string& serialized_aot_result) {\n-  return CpuExecutableAotCompilationResult::FromString(serialized_aot_result);\n+  CompilationResultProto proto;\n+  if (!proto.ParseFromString(serialized_aot_result)) {\n+    return Internal(\"Failed to parse serialized CpuAotCompilationResult.\");\n+  }\n+\n+  TF_ASSIGN_OR_RETURN(std::unique_ptr<HloModule> hlo_module,\n+                      HloModule::CreateFromProtoWithConfig(proto.hlo_module()));\n+  std::vector<SymbolProto> compiled_symbols_proto;\n+  for (const auto& symbol_proto : proto.compiled_symbols()) {\n+    compiled_symbols_proto.push_back(symbol_proto);\n+  }\n+\n+  TF_ASSIGN_OR_RETURN(auto compiled_symbols,\n+                      GetCompiledSymbolsFromProto(compiled_symbols_proto));\n+\n+  std::vector<ObjFileProto> obj_files;\n+  for (const auto& obj_file : proto.object_files()) {\n+    obj_files.push_back(obj_file);\n+  }\n+\n+  TF_ASSIGN_OR_RETURN(\n+      auto function_library,\n+      LoadFunctionLibrary(compiled_symbols, obj_files, hlo_module.get()));\n+\n+  return CpuAotCompilationResult::FromProto(std::move(proto),\n+                                            std::move(function_library));\n }\n \n absl::StatusOr<HloSchedule> CpuCompiler::CreateHloSchedule("
        }
    ],
    "stats": {
        "total": 374,
        "additions": 120,
        "deletions": 254
    }
}