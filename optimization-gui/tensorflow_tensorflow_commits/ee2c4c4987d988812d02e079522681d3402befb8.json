{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 848173489",
    "sha": "ee2c4c4987d988812d02e079522681d3402befb8",
    "files": [
        {
            "sha": "b457f602b4a5b06ce5a838096ced023ac73b1605",
            "filename": "tensorflow/cc/framework/scope.cc",
            "status": "modified",
            "additions": 39,
            "deletions": 37,
            "changes": 76,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/ee2c4c4987d988812d02e079522681d3402befb8/tensorflow%2Fcc%2Fframework%2Fscope.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/ee2c4c4987d988812d02e079522681d3402befb8/tensorflow%2Fcc%2Fframework%2Fscope.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcc%2Fframework%2Fscope.cc?ref=ee2c4c4987d988812d02e079522681d3402befb8",
            "patch": "@@ -79,7 +79,7 @@ Scope Scope::DisabledShapeInferenceScope() {\n                         /* disable_shape_inference */ true));\n }\n \n-Scope::Impl::Impl(const Scope& other, Tags::ScopeName, const string& name,\n+Scope::Impl::Impl(const Scope& other, Tags::ScopeName, const std::string& name,\n                   bool copy_names)\n     : graph_(other.impl()->graph_),\n       status_(other.impl()->status_),\n@@ -98,8 +98,8 @@ Scope::Impl::Impl(const Scope& other, Tags::ScopeName, const string& name,\n       colocation_constraints_(other.impl()->colocation_constraints_),\n       disable_shape_inference_(other.impl()->disable_shape_inference_) {}\n \n-Scope::Impl::Impl(const Scope& other, Tags::OpName, const string& name,\n-                  const string& op_name)\n+Scope::Impl::Impl(const Scope& other, Tags::OpName, const std::string& name,\n+                  const std::string& op_name)\n     : graph_(other.impl()->graph_),\n       status_(other.impl()->status_),\n       name_map_(other.impl()->name_map_),\n@@ -140,7 +140,7 @@ Scope::Impl::Impl(const Scope& other, Tags::ControlDeps,\n       colocation_constraints_(other.impl()->colocation_constraints_),\n       disable_shape_inference_(other.impl()->disable_shape_inference_) {}\n \n-Scope::Impl::Impl(const Scope& other, Tags::Device, const string& device)\n+Scope::Impl::Impl(const Scope& other, Tags::Device, const std::string& device)\n     : graph_(other.impl()->graph_),\n       status_(other.impl()->status_),\n       name_map_(other.impl()->name_map_),\n@@ -158,7 +158,7 @@ Scope::Impl::Impl(const Scope& other, Tags::Device, const string& device)\n       disable_shape_inference_(other.impl()->disable_shape_inference_) {}\n \n Scope::Impl::Impl(const Scope& other, Tags::SingleUseScope,\n-                  const string& op_name)\n+                  const std::string& op_name)\n     : graph_(other.impl()->graph_),\n       status_(other.impl()->status_),\n       name_map_(other.impl()->name_map_),\n@@ -193,7 +193,7 @@ Scope::Impl::Impl(const Scope& other, Tags::ExitOnError)\n       disable_shape_inference_(other.impl()->disable_shape_inference_) {}\n \n Scope::Impl::Impl(const Scope& other, Tags::KernelLabel,\n-                  const string& kernel_label)\n+                  const std::string& kernel_label)\n     : graph_(other.impl()->graph_),\n       status_(other.impl()->status_),\n       name_map_(other.impl()->name_map_),\n@@ -227,12 +227,12 @@ Scope::Impl::Impl(const Scope& other, Tags::Colocate,\n       xla_cluster_(other.impl()->xla_cluster_),\n       colocation_constraints_(\n           clear_colocations\n-              ? std::unordered_set<string>()\n+              ? std::unordered_set<std::string>()\n               : other.impl()->GetColocationConstraints(colocate_with_op)),\n       disable_shape_inference_(other.impl()->disable_shape_inference_) {}\n \n Scope::Impl::Impl(const Scope& other, Tags::AssignedDevice,\n-                  const string& assigned_device)\n+                  const std::string& assigned_device)\n     : graph_(other.impl()->graph_),\n       status_(other.impl()->status_),\n       name_map_(other.impl()->name_map_),\n@@ -250,7 +250,7 @@ Scope::Impl::Impl(const Scope& other, Tags::AssignedDevice,\n       disable_shape_inference_(other.impl()->disable_shape_inference_) {}\n \n Scope::Impl::Impl(const Scope& other, Tags::XlaCluster,\n-                  const string& xla_cluster)\n+                  const std::string& xla_cluster)\n     : graph_(other.impl()->graph_),\n       status_(other.impl()->status_),\n       name_map_(other.impl()->name_map_),\n@@ -267,13 +267,13 @@ Scope::Impl::Impl(const Scope& other, Tags::XlaCluster,\n       colocation_constraints_(other.impl()->colocation_constraints_),\n       disable_shape_inference_(other.impl()->disable_shape_inference_) {}\n \n-std::unordered_set<string> Scope::Impl::GetColocationConstraints(\n+std::unordered_set<std::string> Scope::Impl::GetColocationConstraints(\n     const Operation& colocate_with_op) const {\n-  std::unordered_set<string> current_constraints(colocation_constraints_);\n+  std::unordered_set<std::string> current_constraints(colocation_constraints_);\n   const AttrSlice attrs = colocate_with_op.node()->attrs();\n-  std::vector<string> node_constraints;\n+  std::vector<std::string> node_constraints;\n   if (TryGetNodeAttr(attrs, kColocationAttrName, &node_constraints)) {\n-    for (const string& entry : node_constraints) {\n+    for (const std::string& entry : node_constraints) {\n       absl::string_view s(entry);\n       if (absl::ConsumePrefix(&s, kColocationGroupPrefix)) {\n         current_constraints.emplace(s);\n@@ -335,13 +335,14 @@ void Scope::UpdateBuilder(NodeBuilder* builder) const {\n   }\n \n   if (!impl()->colocation_constraints_.empty()) {\n-    std::vector<string> constraints(impl()->colocation_constraints_.begin(),\n-                                    impl()->colocation_constraints_.end());\n+    std::vector<std::string> constraints(\n+        impl()->colocation_constraints_.begin(),\n+        impl()->colocation_constraints_.end());\n     // Sort the set.\n     std::sort(constraints.begin(), constraints.end());\n     // Add loc:@ prefix\n     std::transform(constraints.begin(), constraints.end(), constraints.begin(),\n-                   [](const string& s) {\n+                   [](const std::string& s) {\n                      return absl::StrCat(kColocationGroupPrefix, s);\n                    });\n     builder->Attr(kColocationAttrName, constraints);\n@@ -357,8 +358,8 @@ void Scope::UpdateBuilder(NodeBuilder* builder) const {\n   }\n }\n \n-string Scope::Impl::GetUniqueName(const string& prefix,\n-                                  bool check_single_use) const {\n+std::string Scope::Impl::GetUniqueName(const std::string& prefix,\n+                                       bool check_single_use) const {\n   if (check_single_use && single_use_scope()) {\n     if (*scope_used_) {\n       *status_ =\n@@ -373,23 +374,23 @@ string Scope::Impl::GetUniqueName(const string& prefix,\n     name_map_->insert({prefix, 0});\n     return prefix;\n   }\n-  string unique_name;\n+  std::string unique_name;\n   do {\n     unique_name = absl::StrCat(prefix, kSuffixSeparator, ++entry->second);\n   } while (name_map_->find(unique_name) != name_map_->end());\n   name_map_->insert({unique_name, 0});\n   return unique_name;\n }\n \n-string Scope::Impl::GetNameForOp(const string& default_name) const {\n-  const string unique_name =\n+std::string Scope::Impl::GetNameForOp(const std::string& default_name) const {\n+  const std::string unique_name =\n       GetUniqueName(default_name, true /* check_single_use */);\n-  const string sep =\n+  const std::string sep =\n       name_.empty() || unique_name.empty() ? \"\" : kScopeSeparator;\n   return absl::StrCat(name_, sep, unique_name);\n }\n \n-string Scope::GetUniqueNameForOp(const string& default_name) const {\n+std::string Scope::GetUniqueNameForOp(const std::string& default_name) const {\n   if (impl()->single_use_scope()) {\n     if (impl()->op_name_.empty() || *impl()->scope_used_) {\n       *impl()->status_ =\n@@ -403,21 +404,21 @@ string Scope::GetUniqueNameForOp(const string& default_name) const {\n                                   : impl()->GetNameForOp(impl()->op_name_);\n }\n \n-Scope Scope::NewSubScope(const string& child_scope_name) const {\n+Scope Scope::NewSubScope(const std::string& child_scope_name) const {\n   if (child_scope_name.empty()) {\n     return Scope(new Impl(*this, Impl::Tags::ScopeName(), impl()->name_,\n                           true /* copy_names */));\n   }\n-  const string unique_name =\n+  const std::string unique_name =\n       impl()->GetUniqueName(child_scope_name, false /* check_single_use */);\n-  const string sep =\n+  const std::string sep =\n       impl()->name_.empty() || unique_name.empty() ? \"\" : kScopeSeparator;\n   return Scope(new Impl(*this, Impl::Tags::ScopeName(),\n                         absl::StrCat(impl()->name_, sep, unique_name),\n                         false /* copy_names */));\n }\n \n-Scope Scope::WithOpNameImpl(const string& op_name) const {\n+Scope Scope::WithOpNameImpl(const std::string& op_name) const {\n   if (impl()->single_use_scope()) {\n     UpdateStatus(errors::InvalidArgument(\"Cannot set op name \", op_name,\n                                          \" on this scope\"));\n@@ -446,15 +447,15 @@ Scope Scope::WithNoControlDependencies() const {\n                         /* clear_control_deps */ true));\n }\n \n-Scope Scope::WithDevice(const string& device) const {\n+Scope Scope::WithDevice(const std::string& device) const {\n   return Scope(new Impl(*this, Impl::Tags::Device(), device));\n }\n \n-Scope Scope::WithAssignedDevice(const string& assigned_device) const {\n+Scope Scope::WithAssignedDevice(const std::string& assigned_device) const {\n   return Scope(new Impl(*this, Impl::Tags::AssignedDevice(), assigned_device));\n }\n \n-Scope Scope::WithXlaCluster(const string& xla_cluster) const {\n+Scope Scope::WithXlaCluster(const std::string& xla_cluster) const {\n   return Scope(new Impl(*this, Impl::Tags::XlaCluster(), xla_cluster));\n }\n \n@@ -472,12 +473,12 @@ Scope Scope::ExitOnError() const {\n   return Scope(new Impl(*this, Impl::Tags::ExitOnError()));\n }\n \n-Scope Scope::WithKernelLabel(const string& kernel_label) const {\n+Scope Scope::WithKernelLabel(const std::string& kernel_label) const {\n   return Scope(new Impl(*this, Impl::Tags::KernelLabel(), kernel_label));\n }\n \n CompositeOpScopes Scope::GetCompositeOpScopes(\n-    const string& composite_op_name) const {\n+    const std::string& composite_op_name) const {\n   if (impl()->op_name_.empty() && composite_op_name.empty()) {\n     UpdateStatus(errors::InvalidArgument(\n         \"Cannot create composite op scopes with empty name\"));\n@@ -486,8 +487,9 @@ CompositeOpScopes Scope::GetCompositeOpScopes(\n   if (!impl()->single_use_scope()) {\n     Scope child = NewSubScope(impl()->op_name_.empty() ? composite_op_name\n                                                        : impl()->op_name_);\n-    const string child_op_sep = impl()->name_.empty() ? \"\" : kSuffixSeparator;\n-    const string child_name =\n+    const std::string child_op_sep =\n+        impl()->name_.empty() ? \"\" : kSuffixSeparator;\n+    const std::string child_name =\n         absl::StrCat(impl()->name_, child_op_sep, child.impl()->name_);\n     return {child,\n             Scope(new Impl(child, Impl::Tags::SingleUseScope(), child_name))};\n@@ -510,11 +512,11 @@ class InternalScope {\n                         ShapeRefiner* refiner) {\n     Scope::Impl::NameMap* name_map = new Scope::Impl::NameMap;\n     for (const Node* node : graph->nodes()) {\n-      const string& name = node->name();\n+      const std::string& name = node->name();\n       (*name_map)[name] = 0;\n       // Add all name prefixes ('/' separated).\n       size_t idx = -1;\n-      while ((idx = name.find(kScopeSeparator, idx + 1)) != string::npos) {\n+      while ((idx = name.find(kScopeSeparator, idx + 1)) != std::string::npos) {\n         (*name_map)[name.substr(0, idx)] = 0;\n       }\n     }\n@@ -533,7 +535,7 @@ Scope NewInternalScope(Graph* graph, absl::Status* status,\n   return InternalScope::NewScope(graph, status, refiner);\n }\n \n-absl::Status CreateOutputWithScope(string op_name,\n+absl::Status CreateOutputWithScope(std::string op_name,\n                                    absl::Span<const ::tensorflow::Input> inputs,\n                                    const Scope& scope, Output* output) {\n   TF_RETURN_IF_ERROR(scope.status());"
        }
    ],
    "stats": {
        "total": 76,
        "additions": 39,
        "deletions": 37
    }
}