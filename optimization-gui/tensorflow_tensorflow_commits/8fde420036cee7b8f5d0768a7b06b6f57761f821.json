{
    "author": "tensorflower-gardener",
    "message": "Explore max/min resource usage for scheduling groups.\n\nPiperOrigin-RevId: 807433427",
    "sha": "8fde420036cee7b8f5d0768a7b06b6f57761f821",
    "files": [
        {
            "sha": "6ef3c16dffa9dfc45d042b4935d812d2221e71ec",
            "filename": "third_party/xla/xla/service/latency_hiding_scheduler.cc",
            "status": "modified",
            "additions": 77,
            "deletions": 31,
            "changes": 108,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8fde420036cee7b8f5d0768a7b06b6f57761f821/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8fde420036cee7b8f5d0768a7b06b6f57761f821/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.cc?ref=8fde420036cee7b8f5d0768a7b06b6f57761f821",
            "patch": "@@ -2937,7 +2937,8 @@ absl::Status DefaultSchedulerCore::SchedulingStep(\n \n absl::flat_hash_map<int64_t, int64_t>\n DefaultSchedulerCore::GetNumResourcesNeededForAnnotation(\n-    const SchedulingState& sched_state, int64_t annotation) {\n+    const SchedulingState& sched_state, int64_t annotation,\n+    bool get_max_resources) {\n   absl::flat_hash_map<int64_t, int64_t> num_resources_needed;\n   const HloComputation* comp =\n       sched_state.sched_graph.GetOriginalInstrList()[0]->parent();\n@@ -2952,11 +2953,17 @@ DefaultSchedulerCore::GetNumResourcesNeededForAnnotation(\n         sched_state.async_tracker->GetNumResourcesPerInstruction(*instr);\n     for (const auto& [resource, usage] : num_resources_needed_per_instr) {\n       if (instr->opcode() == HloOpcode::kAsyncDone) {\n-        // Special case: if a async-done op's matching start op is not in the\n+        // There are two cases where the resources used by the async-done op\n+        // need to be accumulated:\n+        // 1. if a async-done op's matching start op is not in the\n         // same annotation group, then the live range of the resources used\n         // by this async-done op extends beyond this annotation group.\n+        // 2. if get_max_resources is true, then we compute the resource usage\n+        // assuming maximum overlapping, where the resources used by the\n+        // async-done ops need to be accumulated.\n         const HloInstruction* start = instr->operand(0);\n-        if (std::find(instrs.begin(), instrs.end(), start) == instrs.end()) {\n+        if (std::find(instrs.begin(), instrs.end(), start) == instrs.end() ||\n+            get_max_resources) {\n           num_resources_needed[resource] += usage;\n           continue;\n         }\n@@ -2994,9 +3001,11 @@ int64_t DefaultSchedulerCore::GetNumSuccessorsForAnnotation(\n }\n \n bool DefaultSchedulerCore::SchedulingAnnotationCrossesOverlapLimit(\n-    const SchedulingState& sched_state, int64_t annotation) {\n+    const SchedulingState& sched_state, int64_t annotation,\n+    bool use_max_resources) {\n   absl::flat_hash_map<int64_t, int64_t> num_resources_needed =\n-      GetNumResourcesNeededForAnnotation(sched_state, annotation);\n+      GetNumResourcesNeededForAnnotation(sched_state, annotation,\n+                                         use_max_resources);\n   for (const auto& [resource, num_needed] : num_resources_needed) {\n     int64_t limit = sched_state.max_concurrent_resource.at(resource);\n     if (num_needed > limit) {\n@@ -3005,6 +3014,43 @@ bool DefaultSchedulerCore::SchedulingAnnotationCrossesOverlapLimit(\n   }\n   return false;\n }\n+\n+absl::StatusOr<bool> DefaultSchedulerCore::TryScheduleOneAnnotationGroup(\n+    DefaultSchedulerCore::SchedulingState* sched_state,\n+    const HloComputation* computation, bool use_max_resources) {\n+  if (sched_state->ready_annotations.empty() ||\n+      !sched_state->nodes_holding_annotations.empty()) {\n+    return false;\n+  }\n+  // Pick the first ready annotation whose scheduling will not cross the\n+  // overlap limit. If there is no such annotation, continue with\n+  // scheduling non-annotated ops.\n+  int64_t annotation_index = -1;\n+  for (int64_t i = 0; i < sched_state->ready_annotations.size(); ++i) {\n+    if (SchedulingAnnotationCrossesOverlapLimit(\n+            *sched_state, sched_state->ready_annotations[i],\n+            /*use_max_resources=*/use_max_resources)) {\n+      continue;\n+    }\n+    annotation_index = i;\n+    break;\n+  }\n+  if (annotation_index != -1) {\n+    std::swap(sched_state->ready_annotations[annotation_index],\n+              sched_state->ready_annotations.back());\n+    int64_t annotation = sched_state->ready_annotations.back();\n+    sched_state->ready_annotations.pop_back();\n+    VLOG(2) << \"------- BEGIN ANNOTATION: \" << annotation << \" -------\";\n+    sched_state->ongoing_annotation = annotation;\n+    TF_RETURN_IF_ERROR(\n+        ScheduleAnnotation(computation, annotation, sched_state));\n+    VLOG(2) << \"-------  END ANNOTATION: \" << annotation << \" --------\";\n+    sched_state->ongoing_annotation = -1;\n+    return true;\n+  }\n+  return false;\n+}\n+\n absl::StatusOr<std::shared_ptr<SchedulerCore::SchedulingState>>\n DefaultSchedulerCore::MakeSchedulingState(const HloComputation* computation) {\n   const HloSchedule& module_schedule = computation->parent()->schedule();\n@@ -3024,11 +3070,13 @@ DefaultSchedulerCore::MakeSchedulingState(const HloComputation* computation) {\n   sched_state->sched_graph.InitializeGraphAnalysis();\n   return sched_state;\n }\n+\n absl::StatusOr<std::vector<HloInstruction*>>\n DefaultSchedulerCore::ScheduleComputation(const HloComputation* computation) {\n   TF_ASSIGN_OR_RETURN(auto sched_state, MakeSchedulingState(computation));\n   return ScheduleComputation(computation, sched_state);\n }\n+\n absl::StatusOr<std::vector<HloInstruction*>>\n DefaultSchedulerCore::ScheduleComputation(\n     const HloComputation* computation,\n@@ -3104,36 +3152,34 @@ DefaultSchedulerCore::ScheduleComputation(\n       };\n       return absl::StrJoin(sched_state->ready_set, \"\\n\", LogFormatter());\n     }());\n-    if (!sched_state->ready_annotations.empty() &&\n-        sched_state->nodes_holding_annotations.empty()) {\n-      // Pick the first ready annotation whose scheduling will not cross the\n-      // overlap limit. If there is no such annotation, continue with\n-      // scheduling non-annotated ops.\n-      int64_t annotation_index = -1;\n-      for (int64_t i = 0; i < sched_state->ready_annotations.size(); ++i) {\n-        if (SchedulingAnnotationCrossesOverlapLimit(\n-                *sched_state, sched_state->ready_annotations[i])) {\n-          continue;\n-        }\n-        annotation_index = i;\n-        break;\n-      }\n-      if (annotation_index != -1) {\n-        std::swap(sched_state->ready_annotations[annotation_index],\n-                  sched_state->ready_annotations.back());\n-        int64_t annotation = sched_state->ready_annotations.back();\n-        sched_state->ready_annotations.pop_back();\n-        VLOG(2) << \"------- BEGIN ANNOTATION: \" << annotation << \" -------\";\n-        sched_state->ongoing_annotation = annotation;\n-        TF_RETURN_IF_ERROR(\n-            ScheduleAnnotation(computation, annotation, sched_state.get()));\n-        VLOG(2) << \"-------  END ANNOTATION: \" << annotation << \" --------\";\n-        sched_state->ongoing_annotation = -1;\n+    auto scheduled_with_max_resources = TryScheduleOneAnnotationGroup(\n+        sched_state.get(), computation, /*use_max_resource*/ true);\n+    if (!scheduled_with_max_resources.ok()) {\n+      return scheduled_with_max_resources.status();\n+    }\n+    if (*scheduled_with_max_resources) {\n+      continue;\n+    }\n+    auto scheduling_step_status = SchedulingStep(sched_state.get());\n+    // If we cannot schedule any non-annotated ops, try scheduling any of the\n+    // ready annotation groups again using minimum resources.\n+    if (!scheduling_step_status.ok()) {\n+      VLOG(3) << \"Failed to schedule any non-annotated ops, trying again with \"\n+                 \"minimum resources for annotation groups\";\n+      auto scheduled_with_min_resources = TryScheduleOneAnnotationGroup(\n+          sched_state.get(), computation, /*use_max_resource*/ false);\n+      if (!scheduled_with_min_resources.ok()) {\n+        return scheduled_with_min_resources.status();\n+      }\n+      if (*scheduled_with_min_resources) {\n         continue;\n       }\n+      VLOG(3)\n+          << \"Failed to schedule any annotation groups with minimum resources\";\n+      return scheduling_step_status;\n     }\n-    TF_RETURN_IF_ERROR(SchedulingStep(sched_state.get()));\n   }\n+\n   if (VLOG_IS_ON(5)) {\n     VLOG(5) << \"New order\";\n     for (auto r_it = sched_state->new_sequence_reversed.rbegin(),"
        },
        {
            "sha": "d26e4e1453cb27e821401d5418d31d89bd687f41",
            "filename": "third_party/xla/xla/service/latency_hiding_scheduler.h",
            "status": "modified",
            "additions": 25,
            "deletions": 3,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/8fde420036cee7b8f5d0768a7b06b6f57761f821/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/8fde420036cee7b8f5d0768a7b06b6f57761f821/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Flatency_hiding_scheduler.h?ref=8fde420036cee7b8f5d0768a7b06b6f57761f821",
            "patch": "@@ -1697,13 +1697,35 @@ class DefaultSchedulerCore : public SchedulerCore {\n     this->config_.memory_limit = new_limit;\n   }\n   int64_t GetRerunTimes() override { return config_.rerun; }\n-  bool SchedulingAnnotationCrossesOverlapLimit(\n-      const SchedulingState& sched_state, int64_t annotation);\n+\n+  // Returns the amount of resources an annotation group needs. The amount of\n+  // resources needed is schedule-order dependent. This function returns the\n+  // minimum or the maximum amount of resources needed for the given annotation\n+  // group based on the value of get_max_resources.\n   absl::flat_hash_map<int64_t, int64_t> GetNumResourcesNeededForAnnotation(\n-      const SchedulingState& sched_state, int64_t annotation);\n+      const SchedulingState& sched_state, int64_t annotation,\n+      bool get_max_resources = false);\n+\n+  // Returns true if the given annotation group crosses the overlap limit.\n+  // If use_max_resources is true, the maximum amount of resources needed for\n+  // the annotation group is used to compare against the overlap limit.\n+  // Otherwise, the minimum amount of resources needed for the annotation group\n+  // is used.\n+  bool SchedulingAnnotationCrossesOverlapLimit(\n+      const SchedulingState& sched_state, int64_t annotation,\n+      bool use_max_resources = false);\n+\n   int64_t GetNumSuccessorsForAnnotation(const SchedulingState& sched_state,\n                                         int64_t annotation) const;\n \n+  // Tries to schedule any of the ready annotation groups using either the\n+  // maximum or minimum amount of resources needed for the annotation group\n+  // based on value of use_max_resources. Returns true if any annotation group\n+  // is scheduled, false otherwise.\n+  absl::StatusOr<bool> TryScheduleOneAnnotationGroup(\n+      DefaultSchedulerCore::SchedulingState* sched_state,\n+      const HloComputation* computation, bool use_max_resources);\n+\n   ScheduleProto::ComputationScheduleProto ComputationScheduleToProto(\n       const HloComputation* computation, const SchedulingState& sched_state,\n       const LatencyEstimator& estimator,"
        }
    ],
    "stats": {
        "total": 136,
        "additions": 102,
        "deletions": 34
    }
}