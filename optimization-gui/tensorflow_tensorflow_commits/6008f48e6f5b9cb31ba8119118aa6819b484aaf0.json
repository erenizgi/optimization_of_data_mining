{
    "author": "ezhulenev",
    "message": "[xla:ffi] Remove unused UserData ownership forwarding to ffi::ExecutionContext\n\nExternal types should be always manipulated through the TypeInfo registered with XLA runtime and we should not be passing arbitrary function pointers around.\n\nPiperOrigin-RevId: 827010125",
    "sha": "6008f48e6f5b9cb31ba8119118aa6819b484aaf0",
    "files": [
        {
            "sha": "14b8979db941fe99051cb435221808ed5c365d3d",
            "filename": "third_party/xla/xla/ffi/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2FBUILD?ref=6008f48e6f5b9cb31ba8119118aa6819b484aaf0",
            "patch": "@@ -70,7 +70,7 @@ cc_library(\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:logging\",\n         \"//xla/tsl/platform:statusor\",\n-        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/container:node_hash_map\",\n         \"@com_google_absl//absl/functional:function_ref\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\","
        },
        {
            "sha": "c7879b549b25ae863081048fe84e98c227153320",
            "filename": "third_party/xla/xla/ffi/execution_context.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 22,
            "changes": 30,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context.cc?ref=6008f48e6f5b9cb31ba8119118aa6819b484aaf0",
            "patch": "@@ -15,10 +15,8 @@ limitations under the License.\n \n #include \"xla/ffi/execution_context.h\"\n \n-#include <memory>\n #include <utility>\n \n-#include \"absl/container/flat_hash_map.h\"\n #include \"absl/functional/function_ref.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n@@ -27,23 +25,11 @@ limitations under the License.\n \n namespace xla::ffi {\n \n-ExecutionContext::UserData::UserData(void* data, Deleter<void> deleter)\n-    : data_(data), deleter_(std::move(deleter)) {}\n-\n-ExecutionContext::UserData::~UserData() {\n-  if (deleter_) deleter_(data_);\n-}\n-\n-absl::Status ExecutionContext::Insert(TypeId type_id, void* data,\n-                                      Deleter<void> deleter) {\n-  return InsertUserData(type_id,\n-                        std::make_unique<UserData>(data, std::move(deleter)));\n+absl::Status ExecutionContext::Insert(TypeId type_id, void* data) {\n+  return InsertUserData(type_id, UserData(data, /*deleter=*/[](void*) {}));\n }\n \n-absl::Status ExecutionContext::InsertUserData(TypeId type_id,\n-                                              std::unique_ptr<UserData> data) {\n-  if (!data) return absl::InvalidArgumentError(\"User data must be not null\");\n-\n+absl::Status ExecutionContext::InsertUserData(TypeId type_id, UserData data) {\n   auto emplaced = user_data_.emplace(type_id, std::move(data));\n   if (!emplaced.second) {\n     return Internal(\n@@ -53,27 +39,27 @@ absl::Status ExecutionContext::InsertUserData(TypeId type_id,\n   return absl::OkStatus();\n }\n \n-absl::StatusOr<ExecutionContext::UserData*> ExecutionContext::LookupUserData(\n-    TypeId type_id) const {\n+absl::StatusOr<const ExecutionContext::UserData*>\n+ExecutionContext::LookupUserData(TypeId type_id) const {\n   auto it = user_data_.find(type_id);\n   if (it == user_data_.end()) {\n     return NotFound(\"User data with type id %d not found in execution context\",\n                     type_id.value());\n   }\n-  return it->second.get();\n+  return &it->second;\n }\n \n void ExecutionContext::ForEach(\n     absl::FunctionRef<void(TypeId type_id, void* data)> fn) const {\n   for (auto& [type_id, user_data] : user_data_) {\n-    fn(type_id, user_data->data());\n+    fn(type_id, user_data.get());\n   }\n }\n \n absl::Status ExecutionContext::ForEachWithStatus(\n     absl::FunctionRef<absl::Status(TypeId type_id, void* data)> fn) const {\n   for (auto& [type_id, user_data] : user_data_) {\n-    TF_RETURN_IF_ERROR(fn(type_id, user_data->data()));\n+    TF_RETURN_IF_ERROR(fn(type_id, user_data.get()));\n   }\n   return absl::OkStatus();\n }"
        },
        {
            "sha": "9bee8ef33b63f2eb8f00cfee783767d4a44a6365",
            "filename": "third_party/xla/xla/ffi/execution_context.h",
            "status": "modified",
            "additions": 46,
            "deletions": 50,
            "changes": 96,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context.h?ref=6008f48e6f5b9cb31ba8119118aa6819b484aaf0",
            "patch": "@@ -16,12 +16,11 @@ limitations under the License.\n #ifndef XLA_FFI_EXECUTION_CONTEXT_H_\n #define XLA_FFI_EXECUTION_CONTEXT_H_\n \n-#include <algorithm>\n #include <functional>\n #include <memory>\n #include <utility>\n \n-#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/container/node_hash_map.h\"\n #include \"absl/functional/function_ref.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n@@ -40,23 +39,40 @@ namespace xla::ffi {\n // to the FFI handler. We rely on type id to guarantee that we forward user data\n // of correct type.\n //\n+// We have two kinds of TypeIds:\n+//\n+// 1. Internal type id. When FFI handler defined in the same binary we rely\n+//    on a global static registry to automatically assign type ids.\n+//\n+// 2. External type id. When FFI handlers defined in a dynamically loaded\n+//    library, they must register types used in the execution context ahead\n+//    of time and explicitly get a unique type id for them.\n+//\n+// See `TypeRegistry` documentation for more details about different type ids.\n+//\n // Examples: FFI handler can register a per-execution cache in the execution\n // context and get access to it in the FFI handler, with a guarantee that it is\n // unique between separate calls to XLA execute.\n class ExecutionContext {\n  public:\n   using TypeId = TypeRegistry::TypeId;\n \n-  template <typename T>\n-  using Deleter = std::function<void(T*)>;\n+  // Inserts user data with a given type id. Caller is responsible for making\n+  // sure that the pointer stays valid during the XLA execution and correctly\n+  // destroyed afterwards.\n+  absl::Status Insert(TypeId type_id, void* data);\n \n-  // Inserts opaque user data with a given type id and optional deleter.\n-  absl::Status Insert(TypeId type_id, void* data,\n-                      Deleter<void> deleter = nullptr);\n+  // Looks up opaque execution context data with given `type_id`.\n+  absl::StatusOr<void*> Lookup(TypeId type_id) const {\n+    TF_ASSIGN_OR_RETURN(auto user_data, LookupUserData(type_id));\n+    return user_data->get();\n+  }\n \n-  // Inserts typed user data of type `T` and optional deleter.\n+  // Inserts typed user data of type `T`. Caller is responsible for making sure\n+  // that the pointer stays valid during the XLA execution and correctly\n+  // destroyed afterwards.\n   template <typename T>\n-  absl::Status Insert(T* data, Deleter<T> deleter = nullptr);\n+  absl::Status Insert(T* data);\n \n   // Emplaces typed user data constructed from `args`. Execution context\n   // becomes the owner of the constructed object.\n@@ -65,64 +81,44 @@ class ExecutionContext {\n \n   // Looks up typed execution context data of type `T`.\n   template <typename T>\n-  absl::StatusOr<T*> Lookup() const {\n-    TF_ASSIGN_OR_RETURN(auto user_data,\n-                        LookupUserData(TypeRegistry::GetTypeId<T>()));\n-    return static_cast<T*>(user_data->data());\n-  }\n-\n-  // Looks up opaque execution context data with given `type_id`.\n-  absl::StatusOr<void*> Lookup(TypeId type_id) const {\n-    TF_ASSIGN_OR_RETURN(auto user_data, LookupUserData(type_id));\n-    return user_data->data();\n-  }\n+  absl::StatusOr<T*> Lookup() const;\n \n   // Visit all user data in the execution context.\n   void ForEach(absl::FunctionRef<void(TypeId type_id, void* data)> fn) const;\n   absl::Status ForEachWithStatus(\n       absl::FunctionRef<absl::Status(TypeId type_id, void* data)> fn) const;\n \n  private:\n-  // An RAII wrapper for opaque user data. Optional deleter will be called when\n-  // UserData is destroyed together with the execution context. If deleter is\n-  // nullptr then the caller is responsible for making sure that the pointer\n-  // stays valid during the XLA execution and correctly destroyed afterwards.\n-  class UserData {\n-   public:\n-    UserData(void* data, Deleter<void> deleter);\n-    ~UserData();\n-\n-    UserData(UserData&) = delete;\n-    UserData& operator=(const UserData&) = delete;\n-\n-    void* data() const { return data_; }\n+  // An RAII wrapper for opaque user data. If deleter is no-op then the caller\n+  // is responsible for making sure that the pointer stays valid during the XLA\n+  // execution and correctly destroyed afterwards\n+  using UserData = std::unique_ptr<void, std::function<void(void*)>>;\n \n-   private:\n-    void* data_;\n-    Deleter<void> deleter_;\n-  };\n+  absl::Status InsertUserData(TypeId type_id, UserData data);\n+  absl::StatusOr<const UserData*> LookupUserData(TypeId type_id) const;\n \n-  absl::Status InsertUserData(TypeId type_id, std::unique_ptr<UserData> data);\n-  absl::StatusOr<UserData*> LookupUserData(TypeId type_id) const;\n-\n-  absl::flat_hash_map<TypeId, std::unique_ptr<UserData>> user_data_;\n+  absl::node_hash_map<TypeId, UserData> user_data_;\n };\n \n template <typename T>\n-absl::Status ExecutionContext::Insert(T* data, Deleter<T> deleter) {\n+absl::StatusOr<T*> ExecutionContext::Lookup() const {\n+  TF_ASSIGN_OR_RETURN(auto user_data,\n+                      LookupUserData(TypeRegistry::GetTypeId<T>()));\n+  return static_cast<T*>(user_data->get());\n+}\n+\n+template <typename T>\n+absl::Status ExecutionContext::Insert(T* data) {\n   return InsertUserData(TypeRegistry::GetTypeId<T>(),\n-                        std::make_unique<UserData>(\n-                            data, [deleter = std::move(deleter)](void* data) {\n-                              if (deleter) deleter(static_cast<T*>(data));\n-                            }));\n+                        UserData(data, /*deleter=*/[](void*) {}));\n }\n \n template <typename T, typename... Args>\n absl::Status ExecutionContext::Emplace(Args&&... args) {\n-  return InsertUserData(TypeRegistry::GetTypeId<T>(),\n-                        std::make_unique<UserData>(\n-                            new T(std::forward<Args>(args)...),\n-                            [](void* data) { delete static_cast<T*>(data); }));\n+  auto type_info = TypeRegistry::GetTypeInfo<T>();\n+  return InsertUserData(\n+      TypeRegistry::GetTypeId<T>(),\n+      UserData(new T(std::forward<Args>(args)...), type_info.deleter));\n }\n \n }  // namespace xla::ffi"
        },
        {
            "sha": "623f05274f0e34e24e215be62a2763757d3b9d12",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_ffi_extension.h",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_extension.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_extension.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_extension.h?ref=6008f48e6f5b9cb31ba8119118aa6819b484aaf0",
            "patch": "@@ -55,12 +55,10 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_FFI_Type_Register_Args, type_info);\n // id for the given type name.\n typedef PJRT_Error* PJRT_FFI_Type_Register(PJRT_FFI_Type_Register_Args* args);\n \n-// User-data that will be forwarded to the FFI handlers. Deleter is optional,\n-// and can be nullptr. Deleter will be called when the context is destroyed.\n+// User-data that will be forwarded to the FFI handlers.\n typedef struct PJRT_FFI_UserData {\n   int64_t type_id;\n   void* data;\n-  void (*deleter)(void* data);\n } PJRT_FFI_UserData;\n \n struct PJRT_FFI_UserData_Add_Args {"
        },
        {
            "sha": "9249fab66d316d87a447639f91cb36f29161c68d",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_ffi_internal.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_internal.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_internal.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_internal.cc?ref=6008f48e6f5b9cb31ba8119118aa6819b484aaf0",
            "patch": "@@ -69,7 +69,7 @@ static PJRT_Error* PJRT_FFI_UserData_Add(PJRT_FFI_UserData_Add_Args* args) {\n \n   xla::ffi::TypeRegistry::TypeId type_id(args->user_data.type_id);\n   PJRT_RETURN_IF_ERROR(args->context->execute_context->ffi_context().Insert(\n-      type_id, args->user_data.data, args->user_data.deleter));\n+      type_id, args->user_data.data));\n   return nullptr;\n }\n "
        },
        {
            "sha": "d6adabefbc6edd65a34b43c822a2412ce735b426",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_gpu_test.cc",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc?ref=6008f48e6f5b9cb31ba8119118aa6819b484aaf0",
            "patch": "@@ -359,7 +359,6 @@ TEST_F(PjrtCApiGpuTest, CreateAndDestroyExecuteContext) {\n   add_args.extension_start = nullptr;\n   add_args.user_data.type_id = 42;\n   add_args.user_data.data = &string_data;\n-  add_args.user_data.deleter = nullptr;\n   add_args.context = create_arg.context;\n   EXPECT_EQ(ffi_extension->user_data_add(&add_args), nullptr);\n "
        },
        {
            "sha": "ecc0e956fc80437058e6d67527686e4b9abe2f5d",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/6008f48e6f5b9cb31ba8119118aa6819b484aaf0/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc?ref=6008f48e6f5b9cb31ba8119118aa6819b484aaf0",
            "patch": "@@ -2344,7 +2344,7 @@ static absl::StatusOr<PJRT_ExecuteContext*> ForwardExecuteContext(\n         PJRT_FFI_UserData_Add_Args_STRUCT_SIZE,\n         nullptr,\n         create_args.context,\n-        PJRT_FFI_UserData{type_id.value(), data, /*deleter=*/nullptr},\n+        PJRT_FFI_UserData{type_id.value(), data},\n     };\n     RETURN_STATUS_IF_PJRT_ERROR(ffi_extension->user_data_add(&add_args), c_api);\n     return absl::OkStatus();"
        }
    ],
    "stats": {
        "total": 137,
        "additions": 58,
        "deletions": 79
    }
}