{
    "author": "ezhulenev",
    "message": "[tsl:concurrency] Add Future::map overrides that can take Executor to run the map functor\n\nPiperOrigin-RevId: 817835460",
    "sha": "81512054586ecacfb85ebfff92550a2a42cf7da7",
    "files": [
        {
            "sha": "00f972a9692553c8aeed10a86845e9262e77edbe",
            "filename": "third_party/xla/xla/tsl/concurrency/future.h",
            "status": "modified",
            "additions": 134,
            "deletions": 99,
            "changes": 233,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/81512054586ecacfb85ebfff92550a2a42cf7da7/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/81512054586ecacfb85ebfff92550a2a42cf7da7/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture.h?ref=81512054586ecacfb85ebfff92550a2a42cf7da7",
            "patch": "@@ -418,6 +418,24 @@ struct IsMappable<R, absl::StatusOr<U>> : public std::is_constructible<R, U> {};\n template <typename R, typename U>\n using Mappable = std::enable_if_t<IsMappable<R, U>::value>;\n \n+// Automatic type inference for the result type of `Future<T>::Map(...)` is\n+// based on the result type of `f` functor:\n+//\n+// - `void`              to `Future<>`\n+// - `absl::Status`      to `Future<>`\n+// - `absl::StatusOr<T>` to `Future<T>`\n+// - `R`                 to `Future<R>` (default)\n+//\n+// clang-format off\n+template <typename R> struct MapResult                    { using T = R; };\n+template <>           struct MapResult<void>              { using T = void; };\n+template <>           struct MapResult<absl::Status>      { using T = void; };\n+template <typename R> struct MapResult<absl::StatusOr<R>> { using T = R; };\n+// clang-format on\n+\n+template <typename R>\n+using map_result_t = typename MapResult<R>::T;  // NOLINT\n+\n }  // namespace internal\n \n // Future<T> is a simple future that is returned by  APIs that enqueue\n@@ -573,29 +591,17 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n     // If `*this` is not ready yet, we need to create a new promise and fulfill\n     // it with a result of `f` when `*this` becomes ready.\n     auto [promise, future] = Future<R>::MakePromise();\n+    OnReady(SetPromise<R, U>(std::move(promise), std::forward<F>(f)));\n+    return std::move(future);\n+  }\n \n-    OnReady([promise = std::move(promise),\n-             f = std::forward<F>(f)](const absl::StatusOr<T>& value) mutable {\n-      // Do not compute `f` if the result is unused.\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-        return;\n-      }\n-\n-      // Short-circuit and forward existing error to the mapped future.\n-      if (ABSL_PREDICT_FALSE(!value.ok())) {\n-        promise.Set(value.status());\n-        return;\n-      }\n-\n-      // Set the result future available with a result of invoking `f`.\n-      if constexpr (std::is_void_v<U>) {\n-        promise.Set((f(*value), absl::OkStatus()));\n-      } else {\n-        promise.Set(f(*value));\n-      }\n-    });\n-\n+  // A `Map` overload that invokes `f` on the given `executor`.\n+  template <typename R, typename F,\n+            typename U = std::invoke_result_t<F, const T&>,\n+            internal::Mappable<R, U>* = nullptr>\n+  [[nodiscard]] Future<R> Map(Executor& executor, F&& f) const& {\n+    auto [promise, future] = Future<R>::MakePromise();\n+    OnReady(executor, SetPromise<R, U>(std::move(promise), std::forward<F>(f)));\n     return std::move(future);\n   }\n \n@@ -652,34 +658,21 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n     // If `*this` is not ready yet, we need to create a new promise and fulfill\n     // it with a result of `f` when `*this` becomes ready.\n     auto [promise, future] = Future<R>::MakePromise();\n+    std::move(*this).OnReady(SetPromise<R, U, /*rvalue=*/true>(\n+        std::move(promise), std::forward<F>(f)));\n+    return std::move(future);\n+  }\n \n-    // For copyable types bind to const reference, so that we don't\n-    // accidentally move the value from the underlying async value storage.\n-    // Move-only types are passed by value into the `OnReady` callback.\n-    using Value = std::conditional_t<is_move_only, absl::StatusOr<T>,\n-                                     const absl::StatusOr<T>&>;\n-    std::move(*this).OnReady([promise = std::move(promise),\n-                              f = std::forward<F>(f)](Value value) mutable {\n-      // Do not compute `f` if the result is unused.\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-        return;\n-      }\n-\n-      // Short-circuit and forward existing error to the mapped future.\n-      if (ABSL_PREDICT_FALSE(!value.ok())) {\n-        promise.Set(value.status());\n-        return;\n-      }\n-\n-      // Set the result future available with a result of invoking `f`.\n-      if constexpr (std::is_void_v<U>) {\n-        promise.Set((f(std::move(*value)), absl::OkStatus()));\n-      } else {\n-        promise.Set(f(std::move(*value)));\n-      }\n-    });\n-\n+  // A `Map` overload that invokes `f` on the given `executor`.\n+  template <typename R, typename F,\n+            typename U = std::invoke_result_t<\n+                F, std::conditional_t<is_move_only, T, const T&>>,\n+            internal::Mappable<R, U>* = nullptr>\n+  [[nodiscard]] Future<R> Map(Executor& executor, F&& f) && {\n+    auto [promise, future] = Future<R>::MakePromise();\n+    std::move(*this).OnReady(\n+        executor, SetPromise<R, U, /*rvalue=*/true>(std::move(promise),\n+                                                    std::forward<F>(f)));\n     return std::move(future);\n   }\n \n@@ -691,15 +684,13 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   //\n   template <typename F, typename R = std::invoke_result_t<F, const T&>>\n   [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto Map(F&& f) const& {\n-    if constexpr (std::is_void_v<R>) {\n-      return Map<void>(std::forward<F>(f));\n-    } else if constexpr (internal::is_status_v<R>) {\n-      return Map<void>(std::forward<F>(f));\n-    } else if constexpr (internal::is_status_or_v<R>) {\n-      return Map<typename R::value_type>(std::forward<F>(f));\n-    } else {\n-      return Map<R>(std::forward<F>(f));\n-    }\n+    return Map<internal::map_result_t<R>>(std::forward<F>(f));\n+  }\n+\n+  // A `Map` overload that invokes `f` on the given `executor`.\n+  template <typename F, typename R = std::invoke_result_t<F, const T&>>\n+  [[nodiscard]] auto Map(Executor& executor, F&& f) const& {\n+    return Map<internal::map_result_t<R>>(executor, std::forward<F>(f));\n   }\n \n   // A `Map` overload that automatically infers the type of result from `f`.\n@@ -711,21 +702,52 @@ class Future : public internal::FutureBase<absl::StatusOr<T>> {\n   template <typename F, typename R = std::invoke_result_t<\n                             F, std::conditional_t<is_move_only, T, const T&>>>\n   [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto Map(F&& f) && {\n-    if constexpr (std::is_void_v<R>) {\n-      return std::move(*this).template Map<void>(std::forward<F>(f));\n-    } else if constexpr (internal::is_status_v<R>) {\n-      return std::move(*this).template Map<void>(std::forward<F>(f));\n-    } else if constexpr (internal::is_status_or_v<R>) {\n-      return std::move(*this).template Map<typename R::value_type>(\n-          std::forward<F>(f));\n-    } else {\n-      return std::move(*this).template Map<R>(std::forward<F>(f));\n-    }\n+    return std::move(*this).template Map<internal::map_result_t<R>>(\n+        std::forward<F>(f));\n+  }\n+\n+  // A `Map` overload that invokes `f` on the given `executor`.\n+  template <typename F, typename R = std::invoke_result_t<\n+                            F, std::conditional_t<is_move_only, T, const T&>>>\n+  [[nodiscard]] auto Map(Executor& executor, F&& f) && {\n+    return std::move(*this).template Map<internal::map_result_t<R>>(\n+        executor, std::forward<F>(f));\n   }\n \n  private:\n   friend class FutureHelpers;\n \n+  // Wraps a map functor into a callback compatible with Future<>::OnReady.\n+  template <typename R, typename U, bool rvalue = false, typename F>\n+  static auto SetPromise(typename Future<R>::Promise promise, F&& f) {\n+    // For copyable types bind to const reference, so that we don't\n+    // accidentally move the value from the underlying async value storage.\n+    // Move-only types are passed by value into the `OnReady` callback.\n+    using Value = std::conditional_t<rvalue && is_move_only, absl::StatusOr<T>,\n+                                     const absl::StatusOr<T>&>;\n+    return [promise = std::move(promise),\n+            f = std::forward<F>(f)](Value value) mutable {\n+      // Do not compute `f` if the result is unused.\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+        return;\n+      }\n+\n+      // Short-circuit and forward existing error to the mapped future.\n+      if (ABSL_PREDICT_FALSE(!value.ok())) {\n+        promise.Set(value.status());\n+        return;\n+      }\n+\n+      // Set the result future available with a result of invoking `f`.\n+      if constexpr (std::is_void_v<U>) {\n+        promise.Set((f(std::move(*value)), absl::OkStatus()));\n+      } else {\n+        promise.Set(f(std::move(*value)));\n+      }\n+    };\n+  }\n+\n   // Bring FutureBase constructors in scope.\n   using Base::Base;\n \n@@ -870,29 +892,16 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n     // If `*this` is not ready yet, we need to create a new promise and fulfill\n     // it with a result of `f` when `*this` becomes ready.\n     auto [promise, future] = Future<R>::MakePromise();\n+    OnReady(SetPromise<R, U>(std::move(promise), std::forward<F>(f)));\n+    return std::move(future);\n+  }\n \n-    OnReady([promise = std::move(promise),\n-             f = std::forward<F>(f)](absl::Status status) mutable {\n-      // Do not compute `f` if the result is unused.\n-      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n-        promise.Set(Base::AbortedError());\n-        return;\n-      }\n-\n-      // Short-circuit and forward existing error to the mapped future.\n-      if (ABSL_PREDICT_FALSE(!status.ok())) {\n-        promise.Set(std::move(status));\n-        return;\n-      }\n-\n-      // Set the result future available with a result of invoking `f`.\n-      if constexpr (std::is_void_v<U>) {\n-        promise.Set((f(), absl::OkStatus()));\n-      } else {\n-        promise.Set(f());\n-      }\n-    });\n-\n+  // A `Map` overload that invokes `f` on the given `executor`.\n+  template <typename R, typename F, typename U = std::invoke_result_t<F>,\n+            internal::Mappable<R, U>* = nullptr>\n+  [[nodiscard]] Future<R> Map(Executor& executor, F&& f) const {\n+    auto [promise, future] = Future<R>::MakePromise();\n+    OnReady(executor, SetPromise<R, U>(std::move(promise), std::forward<F>(f)));\n     return std::move(future);\n   }\n \n@@ -902,17 +911,17 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n   // - `R` is `absl::StatusOr<T>` -> Future<T>\n   // - `R` is any other type      -> Future<R>\n   //\n+  // Functor `f` will be invoked on a thread that sets the promise value,\n+  // or in the caller thread if the future is already available.\n   template <typename F, typename R = std::invoke_result_t<F>>\n   [[nodiscard]] ABSL_ATTRIBUTE_ALWAYS_INLINE auto Map(F&& f) const {\n-    if constexpr (std::is_void_v<R>) {\n-      return Map<void>(std::forward<F>(f));\n-    } else if constexpr (internal::is_status_v<R>) {\n-      return Map<void>(std::forward<F>(f));\n-    } else if constexpr (internal::is_status_or_v<R>) {\n-      return Map<typename R::value_type>(std::forward<F>(f));\n-    } else {\n-      return Map<R>(std::forward<F>(f));\n-    }\n+    return Map<internal::map_result_t<R>>(std::forward<F>(f));\n+  }\n+\n+  // A `Map` overload that invokes `f` on the given `executor`.\n+  template <typename F, typename R = std::invoke_result_t<F>>\n+  [[nodiscard]] auto Map(Executor& executor, F&& f) const {\n+    return Map<internal::map_result_t<R>>(executor, std::forward<F>(f));\n   }\n \n   // Returns an Future<R> that is constructed from the given value. If *this\n@@ -935,6 +944,32 @@ class Future<void> : public internal::FutureBase<absl::Status> {\n  private:\n   friend class FutureHelpers;\n \n+  // Wraps a map functor into a callback compatible with Future<>::OnReady.\n+  template <typename R, typename U, typename F>\n+  static auto SetPromise(typename Future<R>::Promise promise, F&& f) {\n+    return [promise = std::move(promise),\n+            f = std::forward<F>(f)](absl::Status status) mutable {\n+      // Do not compute `f` if the result is unused.\n+      if (ABSL_PREDICT_FALSE(promise.IsUniqueReference())) {\n+        promise.Set(Base::AbortedError());\n+        return;\n+      }\n+\n+      // Short-circuit and forward existing error to the mapped future.\n+      if (ABSL_PREDICT_FALSE(!status.ok())) {\n+        promise.Set(std::move(status));\n+        return;\n+      }\n+\n+      // Set the result future available with a result of invoking `f`.\n+      if constexpr (std::is_void_v<U>) {\n+        promise.Set((f(), absl::OkStatus()));\n+      } else {\n+        promise.Set(f());\n+      }\n+    };\n+  }\n+\n   // A promise that is immediately ready with OK status. Async value allocated\n   // in the static storage and is not reference-counted.\n   static absl::NoDestructor<tsl::AsyncValueOwningRef<absl::Status>>"
        },
        {
            "sha": "b1e38a6268c9ca20a6e88135b01c972e6aab71a9",
            "filename": "third_party/xla/xla/tsl/concurrency/future_test.cc",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/81512054586ecacfb85ebfff92550a2a42cf7da7/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/81512054586ecacfb85ebfff92550a2a42cf7da7/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fconcurrency%2Ffuture_test.cc?ref=81512054586ecacfb85ebfff92550a2a42cf7da7",
            "patch": "@@ -835,6 +835,24 @@ TEST(FutureTest, OnReadyOnExecutor) {\n       [](absl::StatusOr<std::unique_ptr<int32_t>> x) { ASSERT_EQ(**x, 42); });\n }\n \n+TEST(FutureTest, MapOnExecutor) {\n+  Future<> future0(absl::OkStatus());\n+  Future<int32_t> mapped0 =\n+      future0.Map(InlineExecutor::Instance(), [] { return 42; });\n+  EXPECT_EQ(*mapped0.Await(), 42);\n+\n+  Future<int32_t> future1(42);\n+  Future<int32_t> mapped1 =\n+      future1.Map(InlineExecutor::Instance(), [](int32_t x) { return x + 1; });\n+  EXPECT_EQ(*mapped1.Await(), 43);\n+\n+  Future<std::unique_ptr<int32_t>> future2(std::make_unique<int32_t>(42));\n+  Future<int32_t> mapped2 =\n+      std::move(future2).Map(InlineExecutor::Instance(),\n+                             [](std::unique_ptr<int32_t> x) { return *x + 1; });\n+  EXPECT_EQ(*mapped2.Await(), 43);\n+}\n+\n //===----------------------------------------------------------------------===//\n // Performance benchmarks.\n //===----------------------------------------------------------------------===//"
        }
    ],
    "stats": {
        "total": 251,
        "additions": 152,
        "deletions": 99
    }
}