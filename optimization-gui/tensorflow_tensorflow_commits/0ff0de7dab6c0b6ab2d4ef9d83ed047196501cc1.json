{
    "author": "tensorflower-gardener",
    "message": "Add a CounterGauge metric implementation.\n\nThis change introduces `counter_gauge.h`, providing a `Counter` class that registers as a `MetricKind::kGauge`. It allows tracking gauge-like counter values and does not require a mutex on the user side.\n\nPiperOrigin-RevId: 828183128",
    "sha": "0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1",
    "files": [
        {
            "sha": "f9e0eba2b0a115f1b6055efdabbb839ecb293bc0",
            "filename": "third_party/xla/xla/tsl/lib/monitoring/BUILD",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2FBUILD?ref=0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1",
            "patch": "@@ -74,6 +74,29 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"counter_gauge\",\n+    hdrs = [\"counter_gauge.h\"],\n+    deps = [\n+        \":collection_registry\",\n+        \":metric_def\",\n+        \"//xla/tsl/platform:logging\",\n+        \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/synchronization\",\n+    ],\n+)\n+\n+tsl_cc_test(\n+    name = \"counter_gauge_test\",\n+    srcs = [\"counter_gauge_test.cc\"],\n+    deps = [\n+        \":counter_gauge\",\n+        \"@com_google_googletest//:gtest_main\",\n+    ],\n+)\n+\n cc_library(\n     name = \"sampler\",\n     srcs = [\"sampler.cc\"],\n@@ -191,6 +214,7 @@ tsl_cc_test(\n     deps = [\n         \":cell_reader\",\n         \":counter\",\n+        \":counter_gauge\",\n         \":gauge\",\n         \":percentile_sampler\",\n         \":sampler\","
        },
        {
            "sha": "4c6bcb86d1227988502baf6e7b9f63401594d770",
            "filename": "third_party/xla/xla/tsl/lib/monitoring/cell_reader_test.cc",
            "status": "modified",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2Fcell_reader_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2Fcell_reader_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2Fcell_reader_test.cc?ref=0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1",
            "patch": "@@ -21,6 +21,7 @@ limitations under the License.\n \n #include <gtest/gtest.h>\n #include \"xla/tsl/lib/monitoring/counter.h\"\n+#include \"xla/tsl/lib/monitoring/counter_gauge.h\"\n #include \"xla/tsl/lib/monitoring/gauge.h\"\n #include \"xla/tsl/lib/monitoring/percentile_sampler.h\"\n #include \"xla/tsl/lib/monitoring/sampler.h\"\n@@ -76,6 +77,13 @@ auto* test_bool_gauge_with_labels = tsl::monitoring::Gauge<bool, 2>::New(\n     \"/tsl/monitoring/test/bool_gauge_with_labels\", \"Test gauge.\", \"label1\",\n     \"label2\");\n \n+auto* test_counter_gauge = tsl::monitoring::CounterGauge<0>::New(\n+    \"/tsl/monitoring/test/counter_gauge\", \"Test counter gauge.\");\n+\n+auto* test_counter_gauge_with_labels = tsl::monitoring::CounterGauge<2>::New(\n+    \"/tsl/monitoring/test/counter_gauge_with_labels\",\n+    \"Test counter gauge with two labels.\", \"label1\", \"label2\");\n+\n auto* test_percentiles = tsl::monitoring::PercentileSampler<0>::New(\n     {\"/tsl/monitoring/test/percentiles\", \"Test percentiles.\"},\n     GetDefaultPercentiles(), /*max_samples=*/1024,\n@@ -1083,6 +1091,36 @@ TEST(CellReaderTest, BoolGaugeRepeatedSetAndRead) {\n   EXPECT_EQ(cell_reader.Read(\"x2\", \"y2\"), false);\n }\n \n+TEST(CellReaderTest, CounterGaugeRead) {\n+  CellReader<int64_t> cell_reader(\"/tsl/monitoring/test/counter_gauge\");\n+  EXPECT_EQ(cell_reader.Read(), 0);\n+  test_counter_gauge->GetCell()->IncrementBy(10);\n+  EXPECT_EQ(cell_reader.Read(), 10);\n+  test_counter_gauge->GetCell()->IncrementBy(20);\n+  EXPECT_EQ(cell_reader.Read(), 30);\n+  test_counter_gauge->GetCell()->IncrementBy(-30);\n+  EXPECT_EQ(cell_reader.Read(), 0);\n+}\n+\n+TEST(CellReaderTest, CounterGaugeRepeatedIncrementAndDecrement) {\n+  CellReader<int64_t> cell_reader(\"/tsl/monitoring/test/counter_gauge\");\n+  EXPECT_EQ(cell_reader.Read(), 0);\n+  const int kNumIterations = 10;\n+  for (int i = 0; i < kNumIterations; ++i) {\n+    test_counter_gauge->GetCell()->Increment();\n+    EXPECT_EQ(cell_reader.Read(), i + 1);\n+  }\n+  for (int i = 0; i < kNumIterations; ++i) {\n+    test_counter_gauge->GetCell()->Decrement();\n+    EXPECT_EQ(cell_reader.Read(), 10 - i - 1);\n+  }\n+  for (int i = 0; i < kNumIterations; ++i) {\n+    test_counter_gauge->GetCell()->Increment();\n+    test_counter_gauge->GetCell()->Decrement();\n+    EXPECT_EQ(cell_reader.Read(), 0);\n+  }\n+}\n+\n TEST(CellReaderTest, PercentilesDeltaNoLabels) {\n   CellReader<Percentiles> cell_reader(\"/tsl/monitoring/test/percentiles\");\n   Percentiles percentiles = cell_reader.Delta();"
        },
        {
            "sha": "709866f8da914e647d71401a85a7e241d1a63916",
            "filename": "third_party/xla/xla/tsl/lib/monitoring/counter_gauge.h",
            "status": "added",
            "additions": 180,
            "deletions": 0,
            "changes": 180,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2Fcounter_gauge.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2Fcounter_gauge.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2Fcounter_gauge.h?ref=0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1",
            "patch": "@@ -0,0 +1,180 @@\n+/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_TSL_LIB_MONITORING_COUNTER_GAUGE_H_\n+#define XLA_TSL_LIB_MONITORING_COUNTER_GAUGE_H_\n+\n+#include <array>\n+#include <atomic>\n+#include <cstdint>\n+#include <memory>\n+#include <string>\n+#include <utility>\n+\n+#include \"absl/base/thread_annotations.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"xla/tsl/lib/monitoring/collection_registry.h\"\n+#include \"xla/tsl/lib/monitoring/metric_def.h\"\n+#include \"xla/tsl/platform/logging.h\"\n+\n+namespace tsl {\n+namespace monitoring {\n+\n+// CounterGaugeCell stores each value of an CounterGauge.\n+//\n+// This class is thread-safe.\n+class CounterGaugeCell {\n+ public:\n+  explicit CounterGaugeCell(int64_t value) : value_(value) {}\n+  CounterGaugeCell() = default;\n+\n+  // Atomically increments the value by step. `step` can be any value.\n+  void IncrementBy(int64_t step);\n+\n+  // Atomically increments the value by 1.\n+  void Increment();\n+\n+  // Atomically decrements the value by 1.\n+  void Decrement();\n+\n+  // Retrieves the current value.\n+  int64_t value() const;\n+\n+ private:\n+  std::atomic<int64_t> value_;\n+\n+  CounterGaugeCell(const CounterGaugeCell&) = delete;\n+  void operator=(const CounterGaugeCell&) = delete;\n+};\n+\n+// A stateful class for updating a gauge integer metric.\n+//\n+// This class encapsulates a set of values (or a single value for a label-less\n+// metric). Each value is identified by a tuple of labels. The class allows the\n+// user to increment each value.\n+//\n+// Counter allocates storage and maintains a cell for each value. You can\n+// retrieve an individual cell using a label-tuple and update it separately.\n+// This improves performance since operations related to retrieval, like\n+// map-indexing and locking, are avoided.\n+//\n+// This class is thread-safe.\n+template <int NumLabels>\n+class CounterGauge {\n+ public:\n+  ~CounterGauge() {\n+    // Deleted here, before the metric_def is destroyed.\n+    registration_handle_.reset();\n+  }\n+\n+  // Creates the metric based on the metric-definition arguments.\n+  //\n+  // Example;\n+  // auto* counter_with_label = CounterGauge<1>::New(\"/tensorflow/counter\",\n+  //   \"Tensorflow counter\", \"MyLabelName\");\n+  template <typename... MetricDefArgs>\n+  static CounterGauge* New(MetricDefArgs&&... metric_def_args);\n+\n+  // Retrieves the cell for the specified labels, creating it on demand if\n+  // not already present.\n+  template <typename... Labels>\n+  CounterGaugeCell* GetCell(const Labels&... labels) ABSL_LOCKS_EXCLUDED(mu_);\n+\n+  absl::Status GetStatus() { return status_; }\n+\n+ private:\n+  explicit CounterGauge(\n+      const MetricDef<MetricKind::kGauge, int64_t, NumLabels>& metric_def)\n+      : metric_def_(metric_def),\n+        registration_handle_(CollectionRegistry::Default()->Register(\n+            &metric_def_, [&](MetricCollectorGetter getter) {\n+              auto metric_collector = getter.Get(&metric_def_);\n+\n+              absl::MutexLock l(mu_);\n+              for (const auto& cell : cells_) {\n+                metric_collector.CollectValue(cell.first, cell.second->value());\n+              }\n+            })) {\n+    if (registration_handle_) {\n+      status_ = absl::OkStatus();\n+    } else {\n+      status_ =\n+          absl::Status(absl::StatusCode::kAlreadyExists,\n+                       \"Another metric with the same name already exists.\");\n+    }\n+  }\n+\n+  mutable absl::Mutex mu_;\n+\n+  absl::Status status_;\n+\n+  using LabelArray = std::array<std::string, NumLabels>;\n+  absl::flat_hash_map<LabelArray, std::unique_ptr<CounterGaugeCell> > cells_\n+      ABSL_GUARDED_BY(mu_);\n+\n+  // The metric definition. This will be used to identify the metric when we\n+  // register it for collection.\n+  const MetricDef<MetricKind::kGauge, int64_t, NumLabels> metric_def_;\n+\n+  std::unique_ptr<CollectionRegistry::RegistrationHandle> registration_handle_;\n+\n+  CounterGauge(const CounterGauge&) = delete;\n+  void operator=(const CounterGauge&) = delete;\n+};\n+\n+////\n+//  Implementation details follow. API readers may skip.\n+////\n+\n+inline void CounterGaugeCell::IncrementBy(int64_t step) { value_ += step; }\n+\n+inline int64_t CounterGaugeCell::value() const { return value_; }\n+\n+inline void CounterGaugeCell::Increment() { IncrementBy(1); }\n+\n+inline void CounterGaugeCell::Decrement() { IncrementBy(-1); }\n+\n+template <int NumLabels>\n+template <typename... MetricDefArgs>\n+CounterGauge<NumLabels>* CounterGauge<NumLabels>::New(\n+    MetricDefArgs&&... metric_def_args) {\n+  return new CounterGauge<NumLabels>(\n+      MetricDef<MetricKind::kGauge, int64_t, NumLabels>(\n+          std::forward<MetricDefArgs>(metric_def_args)...));\n+}\n+\n+template <int NumLabels>\n+template <typename... Labels>\n+CounterGaugeCell* CounterGauge<NumLabels>::GetCell(const Labels&... labels)\n+    ABSL_LOCKS_EXCLUDED(mu_) {\n+  // Provides a more informative error message than the one during array\n+  // construction below.\n+  static_assert(sizeof...(Labels) == NumLabels,\n+                \"Mismatch between CounterGauge<NumLabels> and number of labels \"\n+                \"provided in GetCell(...).\");\n+\n+  const LabelArray& label_array = {{labels...}};\n+  absl::MutexLock l(mu_);\n+  auto [it, unused_inserted] =\n+      cells_.try_emplace(label_array, std::make_unique<CounterGaugeCell>());\n+  return it->second.get();\n+}\n+\n+}  // namespace monitoring\n+}  // namespace tsl\n+\n+#endif  // XLA_TSL_LIB_MONITORING_COUNTER_GAUGE_H_"
        },
        {
            "sha": "59f7afec0a5182b3cb8c45d4a82bc7f5e0845458",
            "filename": "third_party/xla/xla/tsl/lib/monitoring/counter_gauge_test.cc",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2Fcounter_gauge_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2Fcounter_gauge_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fmonitoring%2Fcounter_gauge_test.cc?ref=0ff0de7dab6c0b6ab2d4ef9d83ed047196501cc1",
            "patch": "@@ -0,0 +1,111 @@\n+/* Copyright 2025 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/tsl/lib/monitoring/counter_gauge.h\"\n+\n+#include <gtest/gtest.h>\n+\n+namespace tsl::monitoring {\n+namespace {\n+\n+auto* counter_gauge_with_labels =\n+    CounterGauge<1>::New(\"/tensorflow/test/counter_gauge_with_labels\",\n+                         \"CounterGauge with one label.\", \"MyLabel\");\n+\n+TEST(LabeledCounterGaugeTest, InitializedWithZero) {\n+  EXPECT_EQ(0, counter_gauge_with_labels->GetCell(\"Empty\")->value());\n+}\n+\n+TEST(LabeledCounterGaugeTest, GetCell) {\n+  auto* cell = counter_gauge_with_labels->GetCell(\"GetCellOp\");\n+  EXPECT_EQ(0, cell->value());\n+\n+  cell->IncrementBy(-42);\n+  EXPECT_EQ(-42, cell->value());\n+\n+  auto* same_cell = counter_gauge_with_labels->GetCell(\"GetCellOp\");\n+  EXPECT_EQ(-42, same_cell->value());\n+\n+  same_cell->IncrementBy(42);\n+  EXPECT_EQ(0, cell->value());\n+  EXPECT_EQ(0, same_cell->value());\n+}\n+\n+TEST(LabeledCounterGaugeTest, IncrementAndDecrement) {\n+  auto* cell = counter_gauge_with_labels->GetCell(\"IncrementAndDecrementOp\");\n+  cell->Increment();\n+  EXPECT_EQ(1, cell->value());\n+  cell->Increment();\n+  EXPECT_EQ(2, cell->value());\n+  cell->Decrement();\n+  EXPECT_EQ(1, cell->value());\n+  cell->Decrement();\n+  EXPECT_EQ(0, cell->value());\n+}\n+\n+TEST(LabeledCounterGaugeTest, SameName) {\n+  auto* same_counter =\n+      CounterGauge<1>::New(\"/tensorflow/test/counter_gauge_with_labels\",\n+                           \"Counter with one label.\", \"MyLabel\");\n+  EXPECT_TRUE(counter_gauge_with_labels->GetStatus().ok());\n+  EXPECT_TRUE(same_counter->GetStatus().ok());\n+  delete same_counter;\n+}\n+\n+auto* init_counter_gauge_without_labels = CounterGauge<0>::New(\n+    \"/tensorflow/test/init_counter_gauge_without_labels\",\n+    \"Counter without any labels to check if it is initialized as 0.\");\n+\n+TEST(UnlabeledCounterGaugeTest, InitializedWithZero) {\n+  EXPECT_EQ(0, init_counter_gauge_without_labels->GetCell()->value());\n+}\n+\n+auto* counter_gauge_without_labels =\n+    CounterGauge<0>::New(\"/tensorflow/test/counter_gauge_without_labels\",\n+                         \"Counter without any labels.\");\n+\n+TEST(UnlabeledCounterGaugeTest, GetCell) {\n+  auto* cell = counter_gauge_without_labels->GetCell();\n+  EXPECT_EQ(0, cell->value());\n+\n+  cell->IncrementBy(42);\n+  EXPECT_EQ(42, cell->value());\n+\n+  auto* same_cell = counter_gauge_without_labels->GetCell();\n+  EXPECT_EQ(42, same_cell->value());\n+\n+  same_cell->IncrementBy(58);\n+  EXPECT_EQ(100, cell->value());\n+  EXPECT_EQ(100, same_cell->value());\n+\n+  cell->IncrementBy(-100);\n+  EXPECT_EQ(0, cell->value());\n+  EXPECT_EQ(0, same_cell->value());\n+}\n+\n+TEST(UnlabeledCounterGaugeTest, IncrementAndDecrement) {\n+  auto* cell = counter_gauge_without_labels->GetCell();\n+  cell->Increment();\n+  EXPECT_EQ(1, cell->value());\n+  cell->Increment();\n+  EXPECT_EQ(2, cell->value());\n+  cell->Decrement();\n+  EXPECT_EQ(1, cell->value());\n+  cell->Decrement();\n+  EXPECT_EQ(0, cell->value());\n+}\n+\n+}  // namespace\n+}  // namespace tsl::monitoring"
        }
    ],
    "stats": {
        "total": 353,
        "additions": 353,
        "deletions": 0
    }
}