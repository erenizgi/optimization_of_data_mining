{
    "author": "ezhulenev",
    "message": "[xla:ffi] Add TypeRegistry::TypeInfo to be able to register functions to manipulate user-defined types\n\nPiperOrigin-RevId: 820811829",
    "sha": "d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
    "files": [
        {
            "sha": "09bbeaa657c259b35d55108a786b8b5b888b2dde",
            "filename": "third_party/xla/xla/ffi/BUILD",
            "status": "modified",
            "additions": 23,
            "deletions": 16,
            "changes": 39,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2FBUILD?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -62,7 +62,7 @@ cc_library(\n     srcs = [\"execution_context.cc\"],\n     hdrs = [\"execution_context.h\"],\n     deps = [\n-        \":type_id_registry\",\n+        \":type_registry\",\n         \"//xla:util\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:logging\",\n@@ -79,7 +79,7 @@ xla_cc_test(\n     srcs = [\"execution_context_test.cc\"],\n     deps = [\n         \":execution_context\",\n-        \":type_id_registry\",\n+        \":type_registry\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n@@ -94,13 +94,14 @@ cc_library(\n     srcs = [\"execution_state.cc\"],\n     hdrs = [\"execution_state.h\"],\n     deps = [\n-        \":type_id_registry\",\n+        \":type_registry\",\n         \"//xla:util\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/util:safe_reinterpret_cast\",\n+        \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n-        \"@local_tsl//tsl/platform:logging\",\n-        \"@local_tsl//tsl/platform:statusor\",\n     ],\n )\n \n@@ -109,11 +110,12 @@ xla_cc_test(\n     srcs = [\"execution_state_test.cc\"],\n     deps = [\n         \":execution_state\",\n+        \":type_registry\",\n         \"//xla/tsl/lib/core:status_test_util\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"//xla/tsl/platform:test\",\n         \"@com_google_googletest//:gtest\",\n         \"@com_google_googletest//:gtest_main\",\n-        \"@local_tsl//tsl/platform:statusor\",\n-        \"@local_tsl//tsl/platform:test\",\n     ],\n )\n \n@@ -124,7 +126,7 @@ cc_library(\n         \":api\",\n         \":execution_context\",\n         \":execution_state\",\n-        \":type_id_registry\",\n+        \":type_registry\",\n         \"//xla:executable_run_options\",\n         \"//xla:shape_util\",\n         \"//xla:types\",\n@@ -141,6 +143,7 @@ cc_library(\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:core_headers\",\n         \"@com_google_absl//absl/base:nullability\",\n+        \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings:string_view\",\n@@ -160,7 +163,7 @@ cc_library(\n         \":call_frame\",\n         \":execution_context\",\n         \":execution_state\",\n-        \":type_id_registry\",\n+        \":type_registry\",\n         \"//xla:executable_run_options\",\n         \"//xla:util\",\n         \"//xla/ffi/api:c_api\",\n@@ -218,7 +221,7 @@ xla_cc_test(\n         \":execution_state\",\n         \":ffi\",\n         \":ffi_api\",\n-        \":type_id_registry\",\n+        \":type_registry\",\n         \"//xla:executable_run_options\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/ffi/api:c_api\",\n@@ -243,27 +246,31 @@ xla_cc_test(\n )\n \n cc_library(\n-    name = \"type_id_registry\",\n-    srcs = [\"type_id_registry.cc\"],\n-    hdrs = [\"type_id_registry.h\"],\n+    name = \"type_registry\",\n+    srcs = [\"type_registry.cc\"],\n+    hdrs = [\"type_registry.h\"],\n     deps = [\n         \"//xla:util\",\n         \"//xla/tsl/lib/gtl:int_type\",\n+        \"//xla/tsl/util:safe_reinterpret_cast\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/base:core_headers\",\n+        \"@com_google_absl//absl/base:no_destructor\",\n         \"@com_google_absl//absl/container:flat_hash_map\",\n+        \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/strings:string_view\",\n         \"@com_google_absl//absl/synchronization\",\n     ],\n )\n \n xla_cc_test(\n-    name = \"type_id_registry_test\",\n-    srcs = [\"type_id_registry_test.cc\"],\n+    name = \"type_registry_test\",\n+    srcs = [\"type_registry_test.cc\"],\n     deps = [\n-        \":type_id_registry\",\n+        \":type_registry\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\","
        },
        {
            "sha": "30f8fcddf3b14463f43970edc4f29a9392c001a6",
            "filename": "third_party/xla/xla/ffi/api/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2FBUILD?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -89,7 +89,7 @@ xla_cc_test(\n         \"//xla/ffi:execution_context\",\n         \"//xla/ffi:execution_state\",\n         \"//xla/ffi:ffi_api\",\n-        \"//xla/ffi:type_id_registry\",\n+        \"//xla/ffi:type_registry\",\n         \"//xla/stream_executor:device_memory\",\n         \"//xla/stream_executor:device_memory_allocator\",\n         \"//xla/tsl/concurrency:async_value\","
        },
        {
            "sha": "ce4e6e7894403e292c55977be709996dc8c589ef",
            "filename": "third_party/xla/xla/ffi/api/api.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fapi.h?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -348,11 +348,13 @@ inline XLA_FFI_Error* Ffi::RegisterTypeId(const XLA_FFI_Api* api,\n                                           std::string_view name,\n                                           XLA_FFI_TypeId* type_id,\n                                           XLA_FFI_TypeInfo type_info) {\n+  assert(type_id && \"type_id must not be null\");\n   XLA_FFI_TypeId_Register_Args args;\n   args.struct_size = XLA_FFI_TypeId_Register_Args_STRUCT_SIZE;\n   args.extension_start = nullptr;\n   args.name = XLA_FFI_ByteSpan{name.data(), name.size()};\n   args.type_id = type_id;\n+  args.type_info = &type_info;\n   return api->XLA_FFI_TypeId_Register(&args);\n }\n "
        },
        {
            "sha": "58dd228f0b26a14c3fc12b9c53293073d2933ff3",
            "filename": "third_party/xla/xla/ffi/api/c_api.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fc_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fc_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fc_api.h?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -67,7 +67,7 @@ XLA_FFI_DEFINE_STRUCT_TRAITS(XLA_FFI_Extension_Base, next);\n // * Deleting a method or argument\n // * Changing the type of an argument\n // * Rearranging fields in the XLA_FFI_Api or argument structs\n-#define XLA_FFI_API_MAJOR 0\n+#define XLA_FFI_API_MAJOR 1\n \n // Incremented when the interface is updated in a way that is potentially\n // ABI-compatible with older versions, if supported by the caller and/or\n@@ -82,7 +82,7 @@ XLA_FFI_DEFINE_STRUCT_TRAITS(XLA_FFI_Extension_Base, next);\n // Minor changes include:\n // * Adding a new field to the XLA_FFI_Api or argument structs\n // * Renaming a method or argument (doesn't affect ABI)\n-#define XLA_FFI_API_MINOR 1\n+#define XLA_FFI_API_MINOR 0\n \n struct XLA_FFI_Api_Version {\n   size_t struct_size;\n@@ -491,6 +491,7 @@ struct XLA_FFI_TypeId_Register_Args {\n \n   XLA_FFI_ByteSpan name;\n   XLA_FFI_TypeId* type_id;  // in-out\n+  XLA_FFI_TypeInfo* type_info;\n };\n \n XLA_FFI_DEFINE_STRUCT_TRAITS(XLA_FFI_TypeId_Register_Args, type_id);"
        },
        {
            "sha": "0a3f0dbf9c1e275754191128223556c1d62bebbe",
            "filename": "third_party/xla/xla/ffi/api/ffi.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi.h?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -437,7 +437,7 @@ class CountDownPromise {\n     assert(state_->count.load() >= count && \"Invalid count down value\");\n \n     if (XLA_FFI_PREDICT_FALSE(!error.success())) {\n-      const std::lock_guard<std::mutex> lock(state_->mutex);\n+      std::lock_guard<std::mutex> lock(state_->mutex);  // NOLINT\n       state_->is_error.store(true, std::memory_order_release);\n       state_->error = error;\n     }\n@@ -448,7 +448,7 @@ class CountDownPromise {\n       bool is_error = state_->is_error.load(std::memory_order_acquire);\n       if (XLA_FFI_PREDICT_FALSE(is_error)) {\n         auto take_error = [&] {\n-          const std::lock_guard<std::mutex> lock(state_->mutex);\n+          std::lock_guard<std::mutex> lock(state_->mutex);  // NOLINT\n           return state_->error;\n         };\n         state_->promise.SetError(take_error());\n@@ -476,7 +476,7 @@ class CountDownPromise {\n     std::atomic<int64_t> count;\n     std::atomic<bool> is_error;\n \n-    std::mutex mutex;\n+    std::mutex mutex;  // NOLINT\n     Error error;\n   };\n "
        },
        {
            "sha": "aa436822a4399883de35ec6e8f3d0897ee5ef3dc",
            "filename": "third_party/xla/xla/ffi/api/ffi_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fapi%2Fffi_test.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -39,7 +39,7 @@ limitations under the License.\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/ffi/execution_state.h\"\n #include \"xla/ffi/ffi_api.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n+#include \"xla/ffi/type_registry.h\"\n #include \"xla/primitive_util.h\"\n #include \"xla/stream_executor/device_memory.h\"\n #include \"xla/stream_executor/device_memory_allocator.h\"\n@@ -1220,9 +1220,9 @@ TEST(FfiTest, UserData) {\n \n   ExecutionContext execution_context;\n   TF_ASSERT_OK(execution_context.Insert(\n-      TypeIdRegistry::TypeId(MyDataWithAutoTypeId::id.type_id), &data0));\n+      TypeRegistry::TypeId(MyDataWithAutoTypeId::id.type_id), &data0));\n   TF_ASSERT_OK(execution_context.Insert(\n-      TypeIdRegistry::TypeId(MyDataWithExplicitTypeId::id.type_id), &data1));\n+      TypeRegistry::TypeId(MyDataWithExplicitTypeId::id.type_id), &data1));\n \n   CallFrameBuilder builder(/*num_args=*/0, /*num_rets=*/0);\n   auto call_frame = builder.Build();"
        },
        {
            "sha": "827c85cdc4539f1c023829dd9952b39841c8fddb",
            "filename": "third_party/xla/xla/ffi/execution_context.h",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context.h?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -25,7 +25,7 @@ limitations under the License.\n #include \"absl/functional/function_ref.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n+#include \"xla/ffi/type_registry.h\"\n #include \"xla/tsl/platform/logging.h\"\n #include \"xla/tsl/platform/statusor.h\"\n \n@@ -45,7 +45,7 @@ namespace xla::ffi {\n // unique between separate calls to XLA execute.\n class ExecutionContext {\n  public:\n-  using TypeId = TypeIdRegistry::TypeId;\n+  using TypeId = TypeRegistry::TypeId;\n \n   template <typename T>\n   using Deleter = std::function<void(T*)>;\n@@ -67,7 +67,7 @@ class ExecutionContext {\n   template <typename T>\n   absl::StatusOr<T*> Lookup() const {\n     TF_ASSIGN_OR_RETURN(auto user_data,\n-                        LookupUserData(TypeIdRegistry::GetTypeId<T>()));\n+                        LookupUserData(TypeRegistry::GetTypeId<T>()));\n     return static_cast<T*>(user_data->data());\n   }\n \n@@ -110,7 +110,7 @@ class ExecutionContext {\n \n template <typename T>\n absl::Status ExecutionContext::Insert(T* data, Deleter<T> deleter) {\n-  return InsertUserData(TypeIdRegistry::GetTypeId<T>(),\n+  return InsertUserData(TypeRegistry::GetTypeId<T>(),\n                         std::make_unique<UserData>(\n                             data, [deleter = std::move(deleter)](void* data) {\n                               if (deleter) deleter(static_cast<T*>(data));\n@@ -119,7 +119,7 @@ absl::Status ExecutionContext::Insert(T* data, Deleter<T> deleter) {\n \n template <typename T, typename... Args>\n absl::Status ExecutionContext::Emplace(Args&&... args) {\n-  return InsertUserData(TypeIdRegistry::GetTypeId<T>(),\n+  return InsertUserData(TypeRegistry::GetTypeId<T>(),\n                         std::make_unique<UserData>(\n                             new T(std::forward<Args>(args)...),\n                             [](void* data) { delete static_cast<T*>(data); }));"
        },
        {
            "sha": "11739ff8178319dc65cf5c609e547d548ca55b09",
            "filename": "third_party/xla/xla/ffi/execution_context_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_context_test.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -20,7 +20,7 @@ limitations under the License.\n \n #include <gtest/gtest.h>\n #include \"absl/status/status.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n+#include \"xla/ffi/type_registry.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n@@ -62,8 +62,9 @@ TEST(ExecutionContextTest, InsertUserOwned) {\n }\n \n TEST(ExecutionContextTest, InsertUserOwnedWithTypeId) {\n-  TF_ASSERT_OK_AND_ASSIGN(TypeIdRegistry::TypeId type_id,\n-                          TypeIdRegistry::AssignExternalTypeId(\"I32UserData\"));\n+  TF_ASSERT_OK_AND_ASSIGN(TypeRegistry::TypeId type_id,\n+                          TypeRegistry::AssignExternalTypeId(\n+                              \"I32UserData\", TypeRegistry::TypeInfo{}));\n \n   I32UserData user_data(42);\n "
        },
        {
            "sha": "87916729ef755e00eb66e6e4d5ba7d05d765a3d5",
            "filename": "third_party/xla/xla/ffi/execution_state.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 14,
            "changes": 44,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -15,46 +15,62 @@ limitations under the License.\n \n #include \"xla/ffi/execution_state.h\"\n \n-#include <utility>\n-\n+#include \"absl/base/attributes.h\"\n #include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n+#include \"xla/ffi/type_registry.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n-#include \"tsl/platform/logging.h\"\n \n namespace xla::ffi {\n \n ExecutionState::ExecutionState()\n-    : type_id_(TypeIdRegistry::kUnknownTypeId),\n-      state_(nullptr),\n-      deleter_(nullptr) {}\n+    : type_id_(TypeRegistry::kUnknownTypeId), state_(nullptr) {}\n \n ExecutionState::~ExecutionState() {\n-  if (deleter_) deleter_(state_);\n+  if (type_info_.deleter) {\n+    type_info_.deleter(state_);\n+  }\n+}\n+\n+absl::Status ExecutionState::Set(TypeId type_id, void* state) {\n+  TF_ASSIGN_OR_RETURN(auto type_info,\n+                      TypeRegistry::GetExternalTypeInfo(type_id));\n+  if (type_info.deleter == nullptr) {\n+    return InvalidArgument(\n+        \"Type id %d does not have a registered type info with a deleter\",\n+        type_id.value());\n+  }\n+  return Set(type_id, type_info, state);\n }\n \n+ABSL_DEPRECATED(\"FFI users must rely in TypeInfo registration\")\n absl::Status ExecutionState::Set(TypeId type_id, void* state,\n-                                 Deleter<void> deleter) {\n-  DCHECK(state && deleter) << \"State and deleter must not be null\";\n+                                 void (*deleter)(void*)) {\n+  return Set(type_id, TypeInfo{deleter}, state);\n+}\n+\n+absl::Status ExecutionState::Set(TypeId type_id, TypeInfo type_info,\n+                                 void* state) {\n+  DCHECK(state && type_info.deleter) << \"State and deleter must not be null\";\n \n-  if (type_id_ != TypeIdRegistry::kUnknownTypeId) {\n+  if (type_id_ != TypeRegistry::kUnknownTypeId) {\n     return FailedPrecondition(\"State is already set with a type id %d\",\n                               type_id_.value());\n   }\n \n   type_id_ = type_id;\n+  type_info_ = type_info;\n   state_ = state;\n-  deleter_ = std::move(deleter);\n \n   return absl::OkStatus();\n }\n \n // Returns opaque state of the given type id. If set state type id does not\n // match the requested one, returns an error.\n absl::StatusOr<void*> ExecutionState::Get(TypeId type_id) const {\n-  if (type_id_ == TypeIdRegistry::kUnknownTypeId) {\n+  if (type_id_ == TypeRegistry::kUnknownTypeId) {\n     return NotFound(\"State is not set\");\n   }\n \n@@ -68,7 +84,7 @@ absl::StatusOr<void*> ExecutionState::Get(TypeId type_id) const {\n }\n \n bool ExecutionState::IsSet() const {\n-  return type_id_ != TypeIdRegistry::kUnknownTypeId;\n+  return type_id_ != TypeRegistry::kUnknownTypeId;\n }\n \n }  // namespace xla::ffi"
        },
        {
            "sha": "3be4d2339e8b9dd8ff9dcdab3664066f31a23371",
            "filename": "third_party/xla/xla/ffi/execution_state.h",
            "status": "modified",
            "additions": 19,
            "deletions": 15,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state.h?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -16,13 +16,13 @@ limitations under the License.\n #ifndef XLA_FFI_EXECUTION_STATE_H_\n #define XLA_FFI_EXECUTION_STATE_H_\n \n-#include <functional>\n #include <memory>\n \n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n-#include \"tsl/platform/statusor.h\"\n+#include \"xla/ffi/type_registry.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/util/safe_reinterpret_cast.h\"\n \n namespace xla::ffi {\n \n@@ -41,20 +41,22 @@ namespace xla::ffi {\n //\n class ExecutionState {\n  public:\n-  using TypeId = TypeIdRegistry::TypeId;\n-\n-  template <typename T>\n-  using Deleter = std::function<void(T*)>;\n+  using TypeId = TypeRegistry::TypeId;\n+  using TypeInfo = TypeRegistry::TypeInfo;\n \n   ExecutionState();\n   ~ExecutionState();\n \n   ExecutionState(const ExecutionState&) = delete;\n   ExecutionState& operator=(const ExecutionState&) = delete;\n \n-  // Sets opaque state with a given type id and deleter. Returns an error if\n-  // state is already set.\n-  absl::Status Set(TypeId type_id, void* state, Deleter<void> deleter);\n+  // Sets opaque state with a given type id. Returns an error if state is\n+  // already set, or if type id is not supported as a state.\n+  absl::Status Set(TypeId type_id, void* state);\n+\n+  // Sets opaque state with a given type id and custom deleter. Returns an error\n+  // if state is already set, or if type id is not supported as a state.\n+  absl::Status Set(TypeId type_id, void* state, void (*deleter)(void*));\n \n   // Returns opaque state of the given type id. If set state type id does not\n   // match the requested one, returns an error.\n@@ -73,21 +75,23 @@ class ExecutionState {\n   bool IsSet() const;\n \n  private:\n+  absl::Status Set(TypeId type_id, TypeInfo type_info, void* state);\n+\n   TypeId type_id_;\n+  TypeInfo type_info_;\n   void* state_;\n-  Deleter<void> deleter_;\n };\n \n template <typename T>\n absl::Status ExecutionState::Set(std::unique_ptr<T> state) {\n-  return Set(TypeIdRegistry::GetTypeId<T>(), state.release(),\n-             [](void* state) { delete reinterpret_cast<T*>(state); });\n+  return Set(TypeRegistry::GetTypeId<T>(), TypeRegistry::GetTypeInfo<T>(),\n+             state.release());\n }\n \n template <typename T>\n absl::StatusOr<T*> ExecutionState::Get() const {\n-  TF_ASSIGN_OR_RETURN(void* state, Get(TypeIdRegistry::GetTypeId<T>()));\n-  return reinterpret_cast<T*>(state);\n+  TF_ASSIGN_OR_RETURN(void* state, Get(TypeRegistry::GetTypeId<T>()));\n+  return tsl::safe_reinterpret_cast<T*>(state);\n }\n \n }  // namespace xla::ffi"
        },
        {
            "sha": "f3183b0bdb0d417af0d2031762004240d212d58b",
            "filename": "third_party/xla/xla/ffi/execution_state_test.cc",
            "status": "modified",
            "additions": 34,
            "deletions": 3,
            "changes": 37,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fexecution_state_test.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -20,17 +20,18 @@ limitations under the License.\n \n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"xla/ffi/type_registry.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n-#include \"tsl/platform/statusor.h\"\n-#include \"tsl/platform/test.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/test.h\"\n \n namespace xla::ffi {\n \n using TypeId = ExecutionState::TypeId;\n \n using ::testing::HasSubstr;\n \n-TEST(ExecutionStateTest, SetAndGet) {\n+TEST(ExecutionStateTest, SetAndGetForInternalType) {\n   ExecutionState state;\n   EXPECT_FALSE(state.IsSet());\n \n@@ -52,4 +53,34 @@ TEST(ExecutionStateTest, SetAndGet) {\n   EXPECT_EQ(*data, 42);\n }\n \n+TEST(ExecutionStateTest, SetAndGetForExternalType) {\n+  ExecutionState state;\n+  EXPECT_FALSE(state.IsSet());\n+\n+  {  // Empty state returns an error from Get().\n+    auto data = state.Get(TypeId(1));\n+    EXPECT_THAT(data.status().message(), HasSubstr(\"State is not set\"));\n+  }\n+\n+  {  // Empty state returns an error from Get().\n+    auto data = state.Get<int32_t>();\n+    EXPECT_THAT(data.status().message(), HasSubstr(\"State is not set\"));\n+  }\n+\n+  TypeRegistry::TypeInfo type_info = {\n+      [](void* ptr) { delete static_cast<int32_t*>(ptr); }};\n+  TF_ASSERT_OK_AND_ASSIGN(\n+      TypeRegistry::TypeId type_id,\n+      TypeRegistry::AssignExternalTypeId(\"int32_t\", type_info));\n+\n+  int32_t* value = new int32_t(42);\n+\n+  // Once set, state can be retrieved.\n+  TF_ASSERT_OK(state.Set(type_id, value));\n+  EXPECT_TRUE(state.IsSet());\n+\n+  TF_ASSERT_OK_AND_ASSIGN(void* data, state.Get(type_id));\n+  EXPECT_EQ(data, value);\n+}\n+\n }  // namespace xla::ffi"
        },
        {
            "sha": "39eab7724e7f5409c7f3c71367cdac3fae3c4884",
            "filename": "third_party/xla/xla/ffi/ffi.h",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fffi.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fffi.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi.h?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -37,6 +37,7 @@ limitations under the License.\n #include \"absl/base/attributes.h\"\n #include \"absl/base/nullability.h\"\n #include \"absl/base/optimization.h\"\n+#include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n@@ -46,7 +47,7 @@ limitations under the License.\n #include \"xla/ffi/api/c_api_internal.h\"  // IWYU pragma: keep\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/ffi/execution_state.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n+#include \"xla/ffi/type_registry.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/primitive_util.h\"\n #include \"xla/stream_executor/device_memory.h\"\n@@ -724,7 +725,7 @@ template <typename T>\n struct ResultEncoding<ExecutionStage::kInstantiate,\n                       absl::StatusOr<std::unique_ptr<T>>> {\n   static XLA_FFI_TypeId state_type_id() {\n-    return XLA_FFI_TypeId{TypeIdRegistry::GetTypeId<T>().value()};\n+    return XLA_FFI_TypeId{TypeRegistry::GetTypeId<T>().value()};\n   }\n \n   static XLA_FFI_Error* Encode(const XLA_FFI_Api* api,"
        },
        {
            "sha": "39244ff3ce3accd3ec1b520480ca572329f388c2",
            "filename": "third_party/xla/xla/ffi/ffi_api.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 12,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi_api.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -43,7 +43,7 @@ limitations under the License.\n #include \"xla/ffi/call_frame.h\"\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/ffi/execution_state.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n+#include \"xla/ffi/type_registry.h\"\n #include \"xla/hlo/ir/hlo_computation.h\"\n #include \"xla/service/platform_util.h\"\n #include \"xla/stream_executor/device_memory.h\"\n@@ -659,12 +659,14 @@ static XLA_FFI_Error* XLA_FFI_TypeId_Register(\n       XLA_FFI_ExecutionContext_Get_Args_STRUCT_SIZE, args->struct_size));\n \n   absl::string_view type_name(args->name.ptr, args->name.len);\n-  TypeIdRegistry::TypeId type_id(args->type_id->type_id);\n+  TypeRegistry::TypeId type_id(args->type_id->type_id);\n+  TypeRegistry::TypeInfo type_info = {args->type_info->deleter};\n \n   // If type_id is unknown, we are registering a new type and XLA will assign a\n   // unique type id to it.\n-  if (type_id == TypeIdRegistry::kUnknownTypeId) {\n-    auto assigned_type_id = TypeIdRegistry::AssignExternalTypeId(type_name);\n+  if (type_id == TypeRegistry::kUnknownTypeId) {\n+    auto assigned_type_id =\n+        TypeRegistry::AssignExternalTypeId(type_name, type_info);\n     if (!assigned_type_id.ok()) {\n       return new XLA_FFI_Error{std::move(assigned_type_id).status()};\n     }\n@@ -674,9 +676,10 @@ static XLA_FFI_Error* XLA_FFI_TypeId_Register(\n   }\n \n   // If type_id is set, we are relying on the caller-provided unique type id.\n-  if (auto status = TypeIdRegistry::RegisterExternalTypeId(type_name, type_id);\n-      !status.ok()) {\n-    return new XLA_FFI_Error{std::move(status)};\n+  auto registered_type_id =\n+      TypeRegistry::RegisterExternalTypeId(type_name, type_id, type_info);\n+  if (!registered_type_id.ok()) {\n+    return new XLA_FFI_Error{std::move(registered_type_id)};\n   }\n \n   return nullptr;\n@@ -690,7 +693,7 @@ static XLA_FFI_Error* XLA_FFI_ExecutionContext_Get(\n \n   DCHECK(args->ctx->execution_context) << \"ExecutionContext must be set\";\n   auto user_data = args->ctx->execution_context->Lookup(\n-      TypeIdRegistry::TypeId(args->type_id->type_id));\n+      TypeRegistry::TypeId(args->type_id->type_id));\n   if (!user_data.ok()) {\n     return new XLA_FFI_Error{std::move(user_data).status()};\n   }\n@@ -705,9 +708,16 @@ static XLA_FFI_Error* XLA_FFI_State_Set(XLA_FFI_State_Set_Args* args) {\n       args->struct_size));\n \n   DCHECK(args->ctx->execution_state) << \"ExecutionState must be set\";\n-  absl::Status status = args->ctx->execution_state->Set(\n-      TypeIdRegistry::TypeId(args->type_id->type_id), args->state,\n-      [deleter = args->deleter](void* state) { deleter(state); });\n+\n+  absl::Status status;\n+  if (args->deleter == nullptr) {\n+    status = args->ctx->execution_state->Set(\n+        TypeRegistry::TypeId(args->type_id->type_id), args->state);\n+  } else {\n+    status = args->ctx->execution_state->Set(\n+        TypeRegistry::TypeId(args->type_id->type_id), args->state,\n+        args->deleter);\n+  }\n \n   if (!status.ok()) {\n     return new XLA_FFI_Error{std::move(status)};\n@@ -723,7 +733,7 @@ static XLA_FFI_Error* XLA_FFI_State_Get(XLA_FFI_State_Get_Args* args) {\n \n   DCHECK(args->ctx->execution_state) << \"ExecutionState must be set\";\n   absl::StatusOr<void*> state = args->ctx->execution_state->Get(\n-      TypeIdRegistry::TypeId(args->type_id->type_id));\n+      TypeRegistry::TypeId(args->type_id->type_id));\n   if (!state.ok()) {\n     return new XLA_FFI_Error{std::move(state).status()};\n   }"
        },
        {
            "sha": "47b3a85fa1a3f468e34289adbb369a2484da7ac5",
            "filename": "third_party/xla/xla/ffi/ffi_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Fffi_test.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -39,7 +39,7 @@ limitations under the License.\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/ffi/execution_state.h\"\n #include \"xla/ffi/ffi_api.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n+#include \"xla/ffi/type_registry.h\"\n #include \"xla/stream_executor/device_memory.h\"\n #include \"xla/stream_executor/stream.h\"\n #include \"xla/tsl/concurrency/async_value_ref.h\"\n@@ -1102,7 +1102,7 @@ TEST(FfiTest, Metadata) {\n   EXPECT_EQ(metadata.api_version.major_version, XLA_FFI_API_MAJOR);\n   EXPECT_EQ(metadata.api_version.minor_version, XLA_FFI_API_MINOR);\n \n-  TypeIdRegistry::TypeId type_id = TypeIdRegistry::GetTypeId<StrState>();\n+  TypeRegistry::TypeId type_id = TypeRegistry::GetTypeId<StrState>();\n   EXPECT_EQ(metadata.state_type_id.type_id, type_id);\n }\n "
        },
        {
            "sha": "7fdcfe66e2f75f6900fade52d1c13177009a779c",
            "filename": "third_party/xla/xla/ffi/type_id_registry.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 96,
            "changes": 96,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46522b8a207b1722207821fa2ca017f559683ea8/third_party%2Fxla%2Fxla%2Fffi%2Ftype_id_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46522b8a207b1722207821fa2ca017f559683ea8/third_party%2Fxla%2Fxla%2Fffi%2Ftype_id_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Ftype_id_registry.cc?ref=46522b8a207b1722207821fa2ca017f559683ea8",
            "patch": "@@ -1,96 +0,0 @@\n-/* Copyright 2024 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/ffi/type_id_registry.h\"\n-\n-#include <atomic>\n-#include <cstdint>\n-#include <string>\n-\n-#include \"absl/algorithm/container.h\"\n-#include \"absl/base/attributes.h\"\n-#include \"absl/base/const_init.h\"\n-#include \"absl/container/flat_hash_map.h\"\n-#include \"absl/status/status.h\"\n-#include \"absl/status/statusor.h\"\n-#include \"absl/strings/string_view.h\"\n-#include \"absl/synchronization/mutex.h\"\n-#include \"xla/util.h\"\n-\n-namespace xla::ffi {\n-\n-ABSL_CONST_INIT absl::Mutex type_registry_mutex(absl::kConstInit);\n-\n-using ExternalTypeIdRegistry =\n-    absl::flat_hash_map<std::string, TypeIdRegistry::TypeId>;\n-\n-static ExternalTypeIdRegistry& StaticExternalTypeIdRegistry() {\n-  static auto* const registry = new ExternalTypeIdRegistry();\n-  return *registry;\n-}\n-\n-TypeIdRegistry::TypeId TypeIdRegistry::GetNextInternalTypeId() {\n-  static auto* counter = new std::atomic<int64_t>(1);\n-  return TypeId(counter->fetch_add(1));\n-}\n-\n-TypeIdRegistry::TypeId TypeIdRegistry::GetNextExternalTypeId() {\n-  static auto* counter = new std::atomic<int64_t>(1);\n-  return TypeId(counter->fetch_add(1));\n-}\n-\n-absl::StatusOr<TypeIdRegistry::TypeId> TypeIdRegistry::AssignExternalTypeId(\n-    absl::string_view name) {\n-  absl::MutexLock lock(type_registry_mutex);\n-  auto& registry = StaticExternalTypeIdRegistry();\n-\n-  // Try to emplace with unknow type id and fill it with real type id only if we\n-  // successfully acquired an entry for a given name.\n-  auto emplaced = registry.emplace(name, kUnknownTypeId);\n-  if (!emplaced.second) {\n-    return Internal(\"Type name %s already registered with type id %d\", name,\n-                    emplaced.first->second.value());\n-  }\n-\n-  // Returns true if the registry contains an entry with a given type id.\n-  auto type_id_is_in_use = [&registry](TypeId type_id) {\n-    return absl::c_any_of(registry,\n-                          [&](const auto& e) { return e.second == type_id; });\n-  };\n-\n-  // Create a new type id that is not already in use.\n-  TypeId type_id = GetNextExternalTypeId();\n-  while (type_id_is_in_use(type_id)) {\n-    type_id = GetNextExternalTypeId();\n-  }\n-\n-  return emplaced.first->second = type_id;\n-}\n-\n-absl::Status TypeIdRegistry::RegisterExternalTypeId(absl::string_view name,\n-                                                    TypeId type_id) {\n-  absl::MutexLock lock(type_registry_mutex);\n-  auto& registry = StaticExternalTypeIdRegistry();\n-\n-  auto emplaced = registry.emplace(name, type_id);\n-  if (!emplaced.second && emplaced.first->second != type_id) {\n-    return Internal(\"Type name %s already registered with type id %d vs %d)\",\n-                    name, emplaced.first->second.value(), type_id.value());\n-  }\n-\n-  return absl::OkStatus();\n-}\n-\n-}  // namespace xla::ffi"
        },
        {
            "sha": "7e555291afb0571dc4c7b2e5e8c098cfb7d92175",
            "filename": "third_party/xla/xla/ffi/type_id_registry_test.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 63,
            "changes": 63,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/46522b8a207b1722207821fa2ca017f559683ea8/third_party%2Fxla%2Fxla%2Fffi%2Ftype_id_registry_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/46522b8a207b1722207821fa2ca017f559683ea8/third_party%2Fxla%2Fxla%2Fffi%2Ftype_id_registry_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Ftype_id_registry_test.cc?ref=46522b8a207b1722207821fa2ca017f559683ea8",
            "patch": "@@ -1,63 +0,0 @@\n-/* Copyright 2024 The OpenXLA Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"xla/ffi/type_id_registry.h\"\n-\n-#include <cstdint>\n-#include <limits>\n-\n-#include <gmock/gmock.h>\n-#include <gtest/gtest.h>\n-#include \"absl/status/status.h\"\n-#include \"xla/tsl/lib/core/status_test_util.h\"\n-#include \"xla/tsl/platform/statusor.h\"\n-#include \"xla/tsl/platform/test.h\"\n-\n-namespace xla::ffi {\n-namespace {\n-\n-using ::testing::HasSubstr;\n-\n-TEST(TypeIdRegistryTest, RegisterExternalTypeId) {\n-  TF_ASSERT_OK_AND_ASSIGN(auto type_id,\n-                          TypeIdRegistry::AssignExternalTypeId(\"foo\"));\n-  EXPECT_GE(type_id.value(), 0);\n-\n-  auto duplicate_type_id = TypeIdRegistry::AssignExternalTypeId(\"foo\");\n-  EXPECT_THAT(duplicate_type_id.status().message(),\n-              HasSubstr(\"Type name foo already registered with type id\"));\n-\n-  // It's ok to register the same type with same type id.\n-  TF_ASSERT_OK(TypeIdRegistry::RegisterExternalTypeId(\"foo\", type_id));\n-\n-  // It's an error to register the same type with a different type id.\n-  auto wrong_type_id = TypeIdRegistry::RegisterExternalTypeId(\n-      \"foo\", TypeIdRegistry::TypeId(std::numeric_limits<int64_t>::max()));\n-  EXPECT_THAT(wrong_type_id.message(),\n-              HasSubstr(\"Type name foo already registered with type id\"));\n-\n-  // It's ok to register a new type with a user-provided type id.\n-  TF_ASSERT_OK(TypeIdRegistry::RegisterExternalTypeId(\n-      \"bar\", TypeIdRegistry::TypeId(std::numeric_limits<int64_t>::max())));\n-}\n-\n-TEST(TypeIdRegistryTest, RegisterInternalTypeId) {\n-  auto int32_type_id = TypeIdRegistry::GetTypeId<int32_t>();\n-  auto int64_type_id = TypeIdRegistry::GetTypeId<int64_t>();\n-  EXPECT_NE(int32_type_id, int64_type_id);\n-}\n-\n-}  // namespace\n-}  // namespace xla::ffi"
        },
        {
            "sha": "e6b8ea028985db9ba46d7fccbbecec7fe5dcbca3",
            "filename": "third_party/xla/xla/ffi/type_registry.cc",
            "status": "added",
            "additions": 134,
            "deletions": 0,
            "changes": 134,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -0,0 +1,134 @@\n+/* Copyright 2024 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/ffi/type_registry.h\"\n+\n+#include <atomic>\n+#include <cstdint>\n+#include <string>\n+\n+#include \"absl/algorithm/container.h\"\n+#include \"absl/base/attributes.h\"\n+#include \"absl/base/const_init.h\"\n+#include \"absl/base/no_destructor.h\"\n+#include \"absl/container/flat_hash_map.h\"\n+#include \"absl/log/log.h\"\n+#include \"absl/status/status.h\"\n+#include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_format.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/synchronization/mutex.h\"\n+#include \"xla/util.h\"\n+\n+namespace xla::ffi {\n+namespace {\n+\n+struct TypeRegistration {\n+  TypeRegistry::TypeId type_id;\n+  TypeRegistry::TypeInfo type_info;\n+};\n+\n+using ExternalTypeRegistry = absl::flat_hash_map<std::string, TypeRegistration>;\n+\n+}  // namespace\n+\n+ABSL_CONST_INIT absl::Mutex type_registry_mutex(absl::kConstInit);\n+\n+static ExternalTypeRegistry& StaticExternalTypeRegistry() {\n+  static absl::NoDestructor<ExternalTypeRegistry> registry;\n+  return *registry;\n+}\n+\n+TypeRegistry::TypeId TypeRegistry::GetNextInternalTypeId() {\n+  static auto* counter = new std::atomic<int64_t>(1);\n+  return TypeId(counter->fetch_add(1));\n+}\n+\n+TypeRegistry::TypeId TypeRegistry::GetNextExternalTypeId() {\n+  static auto* counter = new std::atomic<int64_t>(1);\n+  return TypeId(counter->fetch_add(1));\n+}\n+\n+absl::StatusOr<TypeRegistry::TypeId> TypeRegistry::AssignExternalTypeId(\n+    absl::string_view name, TypeInfo type_info) {\n+  VLOG(3) << absl::StrFormat(\"Assign external type id: name=%s\", name);\n+\n+  absl::MutexLock lock(type_registry_mutex);\n+  auto& registry = StaticExternalTypeRegistry();\n+\n+  // Try to emplace with unknow type id and fill it with real type id only if we\n+  // successfully acquired an entry for a given name.\n+  auto emplaced =\n+      registry.emplace(name, TypeRegistration{kUnknownTypeId, type_info});\n+  if (!emplaced.second) {\n+    return Internal(\"Type name %s already registered with type id %d\", name,\n+                    emplaced.first->second.type_id.value());\n+  }\n+\n+  // Returns true if the registry contains an entry with a given type id.\n+  auto type_id_is_in_use = [&registry](TypeId type_id) {\n+    return absl::c_any_of(\n+        registry, [&](const auto& e) { return e.second.type_id == type_id; });\n+  };\n+\n+  // Create a new type id that is not already in use.\n+  TypeId type_id = GetNextExternalTypeId();\n+  while (type_id_is_in_use(type_id)) {\n+    type_id = GetNextExternalTypeId();\n+  }\n+\n+  VLOG(3) << absl::StrFormat(\"Assigned external type id: name=%s type_id=%d\",\n+                             name, type_id.value());\n+  return emplaced.first->second.type_id = type_id;\n+}\n+\n+absl::Status TypeRegistry::RegisterExternalTypeId(absl::string_view name,\n+                                                  TypeId type_id,\n+                                                  TypeInfo type_info) {\n+  VLOG(3) << absl::StrFormat(\"Register external type id: name=%s type_id=%d\",\n+                             name, type_id.value());\n+\n+  absl::MutexLock lock(type_registry_mutex);\n+  auto& registry = StaticExternalTypeRegistry();\n+\n+  auto emplaced = registry.emplace(name, TypeRegistration{type_id, type_info});\n+  if (!emplaced.second && emplaced.first->second.type_id != type_id) {\n+    return Internal(\"Type name %s already registered with type id %d vs %d)\",\n+                    name, emplaced.first->second.type_id.value(),\n+                    type_id.value());\n+  }\n+\n+  return absl::OkStatus();\n+}\n+\n+absl::StatusOr<TypeRegistry::TypeInfo> TypeRegistry::GetExternalTypeInfo(\n+    TypeId type_id) {\n+  absl::MutexLock lock(type_registry_mutex);\n+  auto& registry = StaticExternalTypeRegistry();\n+\n+  auto it = absl::c_find_if(registry, [&](const auto& kv) {\n+    auto& [name, registration] = kv;\n+    return registration.type_id == type_id;\n+  });\n+\n+  if (it == registry.end()) {\n+    return Internal(\"Type id %d is not registered with a static registry\",\n+                    type_id.value());\n+  }\n+\n+  return it->second.type_info;\n+}\n+\n+}  // namespace xla::ffi"
        },
        {
            "sha": "8c61214ddc0f4d062e2e29ae8829e6a78ff81a63",
            "filename": "third_party/xla/xla/ffi/type_registry.h",
            "status": "renamed",
            "additions": 39,
            "deletions": 7,
            "changes": 46,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry.h?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -13,15 +13,16 @@ See the License for the specific language governing permissions and\n limitations under the License.\n ==============================================================================*/\n \n-#ifndef XLA_FFI_TYPE_ID_REGISTRY_H_\n-#define XLA_FFI_TYPE_ID_REGISTRY_H_\n+#ifndef XLA_FFI_TYPE_REGISTRY_H_\n+#define XLA_FFI_TYPE_REGISTRY_H_\n \n #include <cstdint>\n \n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n #include \"absl/strings/string_view.h\"\n #include \"xla/tsl/lib/gtl/int_type.h\"\n+#include \"xla/tsl/util/safe_reinterpret_cast.h\"\n \n namespace xla::ffi {\n \n@@ -43,26 +44,50 @@ namespace xla::ffi {\n //\n // 2. Internal type id. When FFI handler defined in the same binary we rely\n //    on a global static registry to automatically assign type ids.\n-class TypeIdRegistry {\n+//\n+// TypeInfo defines a set of functions that allow XLA runtime to manipulate\n+// external types. For user data, that is forwarded to FFI handlers, they all\n+// can be `nullptr` as XLA runtime doesn't manage their lifetime. For stateful\n+// handlers, XLA runtime at least must know how to destroy the state when XLA\n+// executable is destroyed.\n+class TypeRegistry {\n  public:\n+  // Unique (within a process) identifier for a type.\n   TSL_LIB_GTL_DEFINE_INT_TYPE(TypeId, int64_t);\n \n   static constexpr TypeId kUnknownTypeId = TypeId(0);\n \n+  // Pointers to functions that allow XLA runtime to manipulate external types.\n+  struct TypeInfo {\n+    using Deleter = void (*)(void*);\n+\n+    Deleter deleter = nullptr;\n+  };\n+\n   // Assigns a unique type id to an external type with a given name. Returns an\n   // error if a type with a given name is already registered in the process.\n-  static absl::StatusOr<TypeId> AssignExternalTypeId(absl::string_view name);\n+  static absl::StatusOr<TypeId> AssignExternalTypeId(absl::string_view name,\n+                                                     TypeInfo type_info);\n \n   // Registers external type with a given name and type id. Type id is provided\n   // by the caller, and must be unique. Returns an error if a type with a given\n   // name is already registered with a different type id.\n   static absl::Status RegisterExternalTypeId(absl::string_view name,\n-                                             TypeId type_id);\n+                                             TypeId type_id,\n+                                             TypeInfo type_info);\n+\n+  // Returns type info for a given external type id. Returns an error if type\n+  // id is not registered.\n+  static absl::StatusOr<TypeInfo> GetExternalTypeInfo(TypeId type_id);\n \n   // Returns a type id for a given type. For internal type ids only.\n   template <typename T>\n   static TypeId GetTypeId();\n \n+  // Returns type info for a given type id. For internal type ids only.\n+  template <typename T>\n+  static TypeInfo GetTypeInfo();\n+\n  private:\n   // We never mix external and internal type ids, so we can use different type\n   // id spaces to assign unique ids to each type.\n@@ -71,11 +96,18 @@ class TypeIdRegistry {\n };\n \n template <typename T>\n-TypeIdRegistry::TypeId TypeIdRegistry::GetTypeId() {\n+TypeRegistry::TypeId TypeRegistry::GetTypeId() {\n   static const TypeId id = GetNextInternalTypeId();\n   return id;\n }\n \n+template <typename T>\n+TypeRegistry::TypeInfo TypeRegistry::GetTypeInfo() {\n+  return TypeInfo{\n+      [](void* state) { delete tsl::safe_reinterpret_cast<T*>(state); },\n+  };\n+}\n+\n }  // namespace xla::ffi\n \n-#endif  // XLA_FFI_TYPE_ID_REGISTRY_H_\n+#endif  // XLA_FFI_TYPE_REGISTRY_H_",
            "previous_filename": "third_party/xla/xla/ffi/type_id_registry.h"
        },
        {
            "sha": "c39110b93897a432a68fc38d2b0dbf522b34d775",
            "filename": "third_party/xla/xla/ffi/type_registry_test.cc",
            "status": "added",
            "additions": 85,
            "deletions": 0,
            "changes": 85,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fffi%2Ftype_registry_test.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -0,0 +1,85 @@\n+/* Copyright 2024 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/ffi/type_registry.h\"\n+\n+#include <cstdint>\n+#include <limits>\n+\n+#include <gmock/gmock.h>\n+#include <gtest/gtest.h>\n+#include \"absl/status/status.h\"\n+#include \"xla/tsl/lib/core/status_test_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/tsl/platform/test.h\"\n+\n+namespace xla::ffi {\n+namespace {\n+\n+using ::testing::HasSubstr;\n+\n+TEST(TypeRegistryTest, RegisterExternalTypeId) {\n+  TypeRegistry::TypeInfo type_info = {+[](void* state) {}};\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto foo_id,\n+                          TypeRegistry::AssignExternalTypeId(\"foo\", type_info));\n+  EXPECT_GE(foo_id.value(), 0);\n+\n+  auto duplicate_foo_id = TypeRegistry::AssignExternalTypeId(\"foo\", type_info);\n+  EXPECT_THAT(duplicate_foo_id.status().message(),\n+              HasSubstr(\"Type name foo already registered with type id\"));\n+\n+  // It's ok to register the same type with same type id.\n+  TF_ASSERT_OK(TypeRegistry::RegisterExternalTypeId(\"foo\", foo_id, type_info));\n+\n+  // It's an error to register the same type with a different type id.\n+  auto wrong_foo_id = TypeRegistry::RegisterExternalTypeId(\n+      \"foo\", TypeRegistry::TypeId(std::numeric_limits<int64_t>::max()),\n+      type_info);\n+  EXPECT_THAT(wrong_foo_id.message(),\n+              HasSubstr(\"Type name foo already registered with type id\"));\n+\n+  // Registered type has a correct type info.\n+  TF_ASSERT_OK_AND_ASSIGN(TypeRegistry::TypeInfo foo_info,\n+                          TypeRegistry::GetExternalTypeInfo(foo_id));\n+  EXPECT_EQ(foo_info.deleter, type_info.deleter);\n+\n+  // It's ok to register a new type with a user-provided type id.\n+  auto bar_id = TypeRegistry::TypeId(std::numeric_limits<int64_t>::max());\n+  TF_ASSERT_OK(TypeRegistry::RegisterExternalTypeId(\n+      \"bar\", TypeRegistry::TypeId(std::numeric_limits<int64_t>::max()),\n+      type_info));\n+\n+  // And a new type has a correct type info.\n+  TF_ASSERT_OK_AND_ASSIGN(TypeRegistry::TypeInfo bar_info,\n+                          TypeRegistry::GetExternalTypeInfo(bar_id));\n+  EXPECT_EQ(bar_info.deleter, type_info.deleter);\n+}\n+\n+TEST(TypeRegistryTest, RegisterInternalTypeId) {\n+  auto int32_type_id = TypeRegistry::GetTypeId<int32_t>();\n+  auto int64_type_id = TypeRegistry::GetTypeId<int64_t>();\n+  EXPECT_NE(int32_type_id, int64_type_id);\n+}\n+\n+TEST(TypeRegistryTest, InternalTypeInfo) {\n+  int32_t* ptr = new int32_t{42};\n+\n+  TypeRegistry::TypeInfo type_info = TypeRegistry::GetTypeInfo<int32_t>();\n+  type_info.deleter(ptr);\n+}\n+\n+}  // namespace\n+}  // namespace xla::ffi"
        },
        {
            "sha": "2f7528c82cc6d0e3fb81ac65293a553661abff16",
            "filename": "third_party/xla/xla/pjrt/c/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FBUILD?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -82,9 +82,10 @@ cc_library(\n         \":pjrt_c_api_hdrs\",\n         \":pjrt_c_api_helpers\",\n         \":pjrt_c_api_wrapper_impl\",\n+        \"//xla/ffi\",\n         \"//xla/ffi:execution_context\",\n         \"//xla/ffi:ffi_api\",\n-        \"//xla/ffi:type_id_registry\",\n+        \"//xla/ffi:type_registry\",\n         \"//xla/ffi/api:c_api\",\n         \"//xla/ffi/api:ffi\",\n         \"@com_google_absl//absl/status\",\n@@ -567,7 +568,7 @@ xla_test(\n         \"//xla/client:client_library\",\n         \"//xla/ffi:execution_context\",\n         \"//xla/ffi:ffi_api\",\n-        \"//xla/ffi:type_id_registry\",\n+        \"//xla/ffi:type_registry\",\n         \"//xla/ffi/api:ffi\",\n         \"//xla/pjrt:pjrt_common\",\n         \"//xla/pjrt:pjrt_compiler\","
        },
        {
            "sha": "2b3e266fbd32f3e94e666625b046b7ca2ede7840",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_ffi_extension.h",
            "status": "modified",
            "additions": 21,
            "deletions": 2,
            "changes": 23,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_extension.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_extension.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_extension.h?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -30,7 +30,24 @@ extern \"C\" {\n // and GPU backends it gives access to the XLA FFI internals.\n //\n // See: https://en.wikipedia.org/wiki/Foreign_function_interface\n-#define PJRT_API_FFI_EXTENSION_VERSION 2\n+#define PJRT_API_FFI_EXTENSION_VERSION 3\n+\n+struct PJRT_FFI_Type_Info {\n+  void (*deleter)(void* object);\n+  void (*serialize)();    // placeholder for future use\n+  void (*deserialize)();  // placeholder for future use\n+};\n+\n+struct PJRT_FFI_Type_Register_Args {\n+  size_t struct_size;\n+  PJRT_Extension_Base* extension_start;\n+\n+  const char* type_name;\n+  size_t type_name_size;\n+  int64_t type_id;  // in-out\n+  PJRT_FFI_Type_Info* type_info;\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_FFI_Type_Register_Args, type_info);\n \n struct PJRT_FFI_TypeID_Register_Args {\n   size_t struct_size;\n@@ -46,6 +63,7 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_FFI_TypeID_Register_Args, type_id);\n // XLA will assign a unique type id to it and return via out argument, otherwise\n // it will verify that user-provided type id matches previously registered type\n // id for the given type name.\n+typedef PJRT_Error* PJRT_FFI_Type_Register(PJRT_FFI_Type_Register_Args* args);\n typedef PJRT_Error* PJRT_FFI_TypeID_Register(\n     PJRT_FFI_TypeID_Register_Args* args);\n \n@@ -94,8 +112,9 @@ typedef struct PJRT_FFI_Extension {\n   PJRT_FFI_TypeID_Register* type_id_register;\n   PJRT_FFI_UserData_Add* user_data_add;\n   PJRT_FFI_Register_Handler* register_handler;\n+  PJRT_FFI_Type_Register* type_register;\n } PJRT_FFI;\n-PJRT_DEFINE_STRUCT_TRAITS(PJRT_FFI_Extension, register_handler);\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_FFI_Extension, type_register);\n \n #ifdef __cplusplus\n }"
        },
        {
            "sha": "e65b6f1d6bc8d81576b462046046075c4bcb0b21",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_ffi_internal.cc",
            "status": "modified",
            "additions": 36,
            "deletions": 6,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_internal.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_internal.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_ffi_internal.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -19,8 +19,9 @@ limitations under the License.\n #include \"absl/strings/string_view.h\"\n #include \"xla/ffi/api/c_api.h\"\n #include \"xla/ffi/execution_context.h\"\n+#include \"xla/ffi/ffi.h\"\n #include \"xla/ffi/ffi_api.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n+#include \"xla/ffi/type_registry.h\"\n #include \"xla/pjrt/c/pjrt_c_api.h\"\n #include \"xla/pjrt/c/pjrt_c_api_ffi_extension.h\"\n #include \"xla/pjrt/c/pjrt_c_api_helpers.h\"\n@@ -35,20 +36,48 @@ static PJRT_Error* PJRT_FFI_TypeID_Register(\n       PJRT_FFI_TypeID_Register_Args_STRUCT_SIZE, args->struct_size));\n \n   absl::string_view type_name(args->type_name, args->type_name_size);\n-  xla::ffi::TypeIdRegistry::TypeId type_id(args->type_id);\n+  xla::ffi::TypeRegistry::TypeId type_id(args->type_id);\n \n-  if (type_id == xla::ffi::TypeIdRegistry::kUnknownTypeId) {\n+  if (type_id == xla::ffi::TypeRegistry::kUnknownTypeId) {\n     // If type_id is unknown, we are registering a new type and XLA will assign\n     // a unique type id to it.\n     PJRT_ASSIGN_OR_RETURN(\n         auto assigned_type_id,\n-        xla::ffi::TypeIdRegistry::AssignExternalTypeId(type_name));\n+        xla::ffi::TypeRegistry::AssignExternalTypeId(type_name, {}));\n     args->type_id = assigned_type_id.value();\n \n   } else {\n     // If type_id is set, we are relying on the caller-provided unique type id.\n     PJRT_RETURN_IF_ERROR(\n-        xla::ffi::TypeIdRegistry::RegisterExternalTypeId(type_name, type_id));\n+        xla::ffi::TypeRegistry::RegisterExternalTypeId(type_name, type_id, {}));\n+  }\n+\n+  return nullptr;\n+}\n+\n+static PJRT_Error* PJRT_FFI_Type_Register(PJRT_FFI_Type_Register_Args* args) {\n+  PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n+      \"PJRT_FFI_Type_Register_Args\", PJRT_FFI_Type_Register_Args_STRUCT_SIZE,\n+      args->struct_size));\n+\n+  absl::string_view type_name(args->type_name, args->type_name_size);\n+  xla::ffi::TypeRegistry::TypeId type_id(args->type_id);\n+  xla::ffi::TypeRegistry::TypeInfo type_info = {\n+      args->type_info->deleter,\n+  };\n+\n+  if (type_id == xla::ffi::TypeRegistry::kUnknownTypeId) {\n+    // If type_id is unknown, we are registering a new type and XLA will assign\n+    // a unique type id to it.\n+    PJRT_ASSIGN_OR_RETURN(\n+        auto assigned_type_id,\n+        xla::ffi::TypeRegistry::AssignExternalTypeId(type_name, type_info));\n+    args->type_id = assigned_type_id.value();\n+\n+  } else {\n+    // If type_id is set, we are relying on the caller-provided unique type id.\n+    PJRT_RETURN_IF_ERROR(xla::ffi::TypeRegistry::RegisterExternalTypeId(\n+        type_name, type_id, type_info));\n   }\n \n   return nullptr;\n@@ -64,7 +93,7 @@ static PJRT_Error* PJRT_FFI_UserData_Add(PJRT_FFI_UserData_Add_Args* args) {\n         \"PJRT FFI extension requires execute context to be not nullptr\")};\n   }\n \n-  xla::ffi::TypeIdRegistry::TypeId type_id(args->user_data.type_id);\n+  xla::ffi::TypeRegistry::TypeId type_id(args->user_data.type_id);\n   PJRT_RETURN_IF_ERROR(args->context->execute_context->ffi_context().Insert(\n       type_id, args->user_data.data, args->user_data.deleter));\n   return nullptr;\n@@ -102,6 +131,7 @@ PJRT_FFI_Extension CreateFfiExtension(PJRT_Extension_Base* next) {\n       /*type_id_register=*/PJRT_FFI_TypeID_Register,\n       /*user_data_add=*/PJRT_FFI_UserData_Add,\n       /*register_handler=*/PJRT_FFI_Register_Handler,\n+      /*type_register=*/PJRT_FFI_Type_Register,\n   };\n }\n "
        },
        {
            "sha": "1df28573a11e74de83a82ac38351ff26f1a963a1",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_gpu_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_gpu_test.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -44,7 +44,7 @@ limitations under the License.\n #include \"xla/ffi/api/ffi.h\"\n #include \"xla/ffi/execution_context.h\"\n #include \"xla/ffi/ffi_api.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n+#include \"xla/ffi/type_registry.h\"\n #include \"xla/future.h\"\n #include \"xla/literal.h\"\n #include \"xla/literal_util.h\"\n@@ -366,7 +366,7 @@ TEST_F(PjrtCApiGpuTest, CreateAndDestroyExecuteContext) {\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto lookup_user_data,\n       create_arg.context->execute_context->ffi_context().Lookup(\n-          xla::ffi::TypeIdRegistry::TypeId(42)));\n+          xla::ffi::TypeRegistry::TypeId(42)));\n   EXPECT_EQ(lookup_user_data, &string_data);\n \n   PJRT_ExecuteContext_Destroy_Args destroy_args;"
        },
        {
            "sha": "b8f2712af0187a26b0da75f2640615baf6242283",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2FBUILD?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -324,7 +324,7 @@ cc_library(\n         \"//xla:util\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/ffi:execution_context\",\n-        \"//xla/ffi:type_id_registry\",\n+        \"//xla/ffi:type_registry\",\n         \"//xla/hlo/ir:hlo\",\n         \"//xla/hlo/translate/mhlo_to_hlo:type_to_shape\",\n         \"//xla/pjrt:host_callback\","
        },
        {
            "sha": "4f4905fb5ba3481fff49aa58e1d578d9cf39a8fb",
            "filename": "third_party/xla/xla/python/pjrt_ifrt/pjrt_executable.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_executable.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_executable.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fpjrt_ifrt%2Fpjrt_executable.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -35,7 +35,7 @@ limitations under the License.\n #include \"mlir/Dialect/Func/IR/FuncOps.h\"\n #include \"mlir/IR/BuiltinOps.h\"\n #include \"xla/ffi/execution_context.h\"\n-#include \"xla/ffi/type_id_registry.h\"\n+#include \"xla/ffi/type_registry.h\"\n #include \"xla/hlo/ir/hlo_sharding.h\"\n #include \"xla/hlo/translate/mhlo_to_hlo/type_to_shape.h\"\n #include \"xla/layout.h\"\n@@ -768,8 +768,7 @@ PjRtLoadedExecutable::Execute(absl::Span<ArrayRef> args,\n     }\n     ffi_callbacks->callbacks = callbacks->data();\n     ffi_callbacks->num_callbacks = callbacks->size();\n-    auto type_id = xla::ffi::TypeIdRegistry::TypeId(\n-        xla::FfiLoadedHostCallbacks::id.type_id);\n+    ffi::TypeRegistry::TypeId type_id(FfiLoadedHostCallbacks::id.type_id);\n     CHECK_OK(context->ffi_context().Insert(type_id, ffi_callbacks.get()));\n     opts.context = context.get();\n   }"
        },
        {
            "sha": "da6992f4537309f9b6344a4c695ee7b3fca687fd",
            "filename": "third_party/xla/xla/tools/multihost_hlo_runner/python_hlo_runner.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Ftools%2Fmultihost_hlo_runner%2Fpython_hlo_runner.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb/third_party%2Fxla%2Fxla%2Ftools%2Fmultihost_hlo_runner%2Fpython_hlo_runner.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftools%2Fmultihost_hlo_runner%2Fpython_hlo_runner.cc?ref=d531cdce30a44933ed1d9a08fb9c0069f7f9f1cb",
            "patch": "@@ -351,7 +351,7 @@ NB_MODULE(py_hlo_multihost_runner, m) {\n   m.def(\"custom_call_targets\", GetRegisteredCustomCallTargets,\n         nb::arg(\"platform\"));\n   m.def(\n-      \"register_custom_type_id\",\n+      \"register_custom_type\",\n       [](absl::string_view type_name, nb::object type_id) {\n         xla::ThrowIfError(RegisterCustomTypeId(type_name, type_id));\n       },"
        }
    ],
    "stats": {
        "total": 742,
        "additions": 478,
        "deletions": 264
    }
}