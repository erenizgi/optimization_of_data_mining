{
    "author": "SiqiaoWu1993",
    "message": "Refactor graph_exeutor to move the logic of sorting input and output names out.\n\nPiperOrigin-RevId: 805555732",
    "sha": "b38cbf061352a04628bd6035ddcf78f8fbfb39e6",
    "files": [
        {
            "sha": "67eedc6f3e656b8fd741a0e997fa6d1e24014bf9",
            "filename": "tensorflow/core/tfrt/graph_executor/graph_executor.cc",
            "status": "modified",
            "additions": 50,
            "deletions": 41,
            "changes": 91,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b38cbf061352a04628bd6035ddcf78f8fbfb39e6/tensorflow%2Fcore%2Ftfrt%2Fgraph_executor%2Fgraph_executor.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b38cbf061352a04628bd6035ddcf78f8fbfb39e6/tensorflow%2Fcore%2Ftfrt%2Fgraph_executor%2Fgraph_executor.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Ftfrt%2Fgraph_executor%2Fgraph_executor.cc?ref=b38cbf061352a04628bd6035ddcf78f8fbfb39e6",
            "patch": "@@ -537,11 +537,6 @@ absl::StatusOr<std::unique_ptr<GraphExecutor>> GraphExecutor::Create(\n       std::move(kernel_registry));\n }\n \n-namespace {\n-\n-// Sort the strings in `names` and store the results in `sorted_names`. In\n-// addition, the original index in `names` for the item `sorted_names[i]` is\n-// stored in `original_indices[i]`.\n void CreateSortedNamesAndOriginalIndices(absl::Span<const std::string> names,\n                                          std::vector<std::string>& sorted_names,\n                                          std::vector<int>& original_indices) {\n@@ -564,45 +559,16 @@ void CreateSortedNamesAndOriginalIndices(absl::Span<const std::string> names,\n   }\n }\n \n-}  // namespace\n-\n-absl::Status GraphExecutor::Run(\n+absl::Status GraphExecutor::RunWithSortedInputsOutputs(\n     const RunOptions& run_options,\n     absl::Span<const std::pair<std::string, tensorflow::Tensor>> inputs,\n-    absl::Span<const std::string> output_tensor_names,\n-    absl::Span<const std::string> target_tensor_names,\n+    absl::Span<const std::string> sorted_input_names,\n+    absl::Span<const tensorflow::DataType> sorted_input_dtypes,\n+    absl::Span<const std::string> sorted_output_names,\n+    absl::Span<const std::string> sorted_target_node_names,\n+    absl::Span<const int> input_original_indices,\n+    absl::Span<const int> output_original_indices,\n     std::vector<tensorflow::Tensor>* outputs) {\n-  // TODO(b/192498110): Validate input type.\n-\n-  // Sort the input/output names to have a stable order, so that the\n-  // `joined_name`, which is used as the cache key, will be the same as long as\n-  // the same set of inputs/outputs are specified.\n-  std::vector<std::string> input_names;\n-  input_names.reserve(inputs.size());\n-  for (const auto& p : inputs) input_names.push_back(p.first);\n-  std::vector<std::string> sorted_input_names;\n-  std::vector<int> input_original_indices;\n-  CreateSortedNamesAndOriginalIndices(input_names, sorted_input_names,\n-                                      input_original_indices);\n-  // We also need to create sorted input dtypes as they are needed for the\n-  // compilation.\n-  std::vector<tensorflow::DataType> sorted_input_dtypes;\n-  sorted_input_dtypes.reserve(inputs.size());\n-  for (int original_index : input_original_indices) {\n-    sorted_input_dtypes.push_back(inputs.at(original_index).second.dtype());\n-  }\n-\n-  std::vector<std::string> sorted_output_names;\n-  std::vector<int> output_original_indices;\n-  CreateSortedNamesAndOriginalIndices(output_tensor_names, sorted_output_names,\n-                                      output_original_indices);\n-\n-  // For target node names, we only need to sort them. The original indices are\n-  // not needed.\n-  std::vector<std::string> sorted_target_node_names(target_tensor_names.begin(),\n-                                                    target_tensor_names.end());\n-  std::sort(sorted_target_node_names.begin(), sorted_target_node_names.end());\n-\n   // Load the client graph.\n   TF_ASSIGN_OR_RETURN(\n       LoadedClientGraph & loaded_client_graph,\n@@ -679,6 +645,49 @@ absl::Status GraphExecutor::Run(\n   return absl::OkStatus();\n }\n \n+absl::Status GraphExecutor::Run(\n+    const RunOptions& run_options,\n+    absl::Span<const std::pair<std::string, tensorflow::Tensor>> inputs,\n+    absl::Span<const std::string> output_tensor_names,\n+    absl::Span<const std::string> target_tensor_names,\n+    std::vector<tensorflow::Tensor>* outputs) {\n+  // TODO(b/192498110): Validate input type.\n+\n+  // Sort the input/output names to have a stable order, so that the\n+  // `joined_name`, which is used as the cache key, will be the same as long as\n+  // the same set of inputs/outputs are specified.\n+  std::vector<std::string> input_names;\n+  input_names.reserve(inputs.size());\n+  for (const auto& p : inputs) input_names.push_back(p.first);\n+  std::vector<std::string> sorted_input_names;\n+  std::vector<int> input_original_indices;\n+  CreateSortedNamesAndOriginalIndices(input_names, sorted_input_names,\n+                                      input_original_indices);\n+  // We also need to create sorted input dtypes as they are needed for the\n+  // compilation.\n+  std::vector<tensorflow::DataType> sorted_input_dtypes;\n+  sorted_input_dtypes.reserve(inputs.size());\n+  for (int original_index : input_original_indices) {\n+    sorted_input_dtypes.push_back(inputs.at(original_index).second.dtype());\n+  }\n+\n+  std::vector<std::string> sorted_output_names;\n+  std::vector<int> output_original_indices;\n+  CreateSortedNamesAndOriginalIndices(output_tensor_names, sorted_output_names,\n+                                      output_original_indices);\n+\n+  // For target node names, we only need to sort them. The original indices are\n+  // not needed.\n+  std::vector<std::string> sorted_target_node_names(target_tensor_names.begin(),\n+                                                    target_tensor_names.end());\n+  std::sort(sorted_target_node_names.begin(), sorted_target_node_names.end());\n+\n+  return RunWithSortedInputsOutputs(\n+      run_options, inputs, sorted_input_names, sorted_input_dtypes,\n+      sorted_output_names, sorted_target_node_names, input_original_indices,\n+      output_original_indices, outputs);\n+}\n+\n absl::Status GraphExecutor::Extend(const GraphDef& graph) {\n   return graph_execution_state_->Extend(graph);\n }"
        },
        {
            "sha": "22d3bc319e802ea61a3f887e2439cd5000bc1d84",
            "filename": "tensorflow/core/tfrt/graph_executor/graph_executor.h",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b38cbf061352a04628bd6035ddcf78f8fbfb39e6/tensorflow%2Fcore%2Ftfrt%2Fgraph_executor%2Fgraph_executor.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b38cbf061352a04628bd6035ddcf78f8fbfb39e6/tensorflow%2Fcore%2Ftfrt%2Fgraph_executor%2Fgraph_executor.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Ftfrt%2Fgraph_executor%2Fgraph_executor.h?ref=b38cbf061352a04628bd6035ddcf78f8fbfb39e6",
            "patch": "@@ -273,6 +273,24 @@ class GraphExecutor {\n       absl::Span<const std::string> target_tensor_names,\n       std::vector<tensorflow::Tensor>* outputs);\n \n+  // Similar as `Run`, but it requires additional input parameters to specify\n+  // the sorted input/output names and the original indices of the\n+  // inputs/outputs. The caller must guarantee that inputs are in the same order\n+  // as of `sorted_input_names`. The sorted input/output names are needed to\n+  // consistently build the key for looking up the `LoadedClientGraph` in the\n+  // cache. The original indices are needed to map the results to the original\n+  // inputs/outputs.\n+  absl::Status RunWithSortedInputsOutputs(\n+      const RunOptions& run_options,\n+      absl::Span<const std::pair<std::string, tensorflow::Tensor>> inputs,\n+      absl::Span<const std::string> sorted_input_names,\n+      absl::Span<const tensorflow::DataType> sorted_input_dtypes,\n+      absl::Span<const std::string> sorted_output_names,\n+      absl::Span<const std::string> sorted_target_node_names,\n+      absl::Span<const int> input_original_indices,\n+      absl::Span<const int> output_original_indices,\n+      std::vector<tensorflow::Tensor>* outputs);\n+\n   // Runs the graph identified by `graph_name` using the input `inputs` and\n   // stores the output of the execution in `outputs`. It is the client's\n   // responsibility to ensure `graph_name` corresponds to logically different\n@@ -385,6 +403,13 @@ class GraphExecutor {\n void RegisterMlirDialect(mlir::DialectRegistry& registry,\n                          tensorflow::BackendCompiler* backend_compiler);\n \n+// Sort the strings in `names` and store the results in `sorted_names`. In\n+// addition, the original index in `names` for the item `sorted_names[i]` is\n+// stored in `original_indices[i]`.\n+void CreateSortedNamesAndOriginalIndices(absl::Span<const std::string> names,\n+                                         std::vector<std::string>& sorted_names,\n+                                         std::vector<int>& original_indices);\n+\n }  // namespace tfrt_stub\n }  // namespace tensorflow\n "
        }
    ],
    "stats": {
        "total": 116,
        "additions": 75,
        "deletions": 41
    }
}