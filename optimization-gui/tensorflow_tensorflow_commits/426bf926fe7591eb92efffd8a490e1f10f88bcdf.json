{
    "author": "tensorflower-gardener",
    "message": "[SymbolicMap] Include MLIRContext inside SymbolicExprContext\n\nAs a step towards using SymbolicExpr within IndexingMap instead of AffineExpr, this CL integrates adds MLIRContext inside the SymbolicExprContext class.\n\nThis change prepares the codebase for the subsequent replacement of `AffineExpr` with `SymbolicExpr` in the core `IndexingMap` logic.\n\nPiperOrigin-RevId: 812682332",
    "sha": "426bf926fe7591eb92efffd8a490e1f10f88bcdf",
    "files": [
        {
            "sha": "25e9cbc26b1d6e3625a00727cc4080ba7f56981b",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2FBUILD?ref=426bf926fe7591eb92efffd8a490e1f10f88bcdf",
            "patch": "@@ -247,6 +247,7 @@ cc_library(\n         \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/types:span\",\n         \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//mlir:IR\",\n         \"@llvm-project//mlir:Support\",\n     ],\n )"
        },
        {
            "sha": "f5e87640602c64f93636deb13ec5e2f5d7482ad5",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.cc?ref=426bf926fe7591eb92efffd8a490e1f10f88bcdf",
            "patch": "@@ -41,6 +41,7 @@ limitations under the License.\n #include \"llvm/ADT/DenseSet.h\"\n #include \"llvm/ADT/SmallVector.h\"\n #include \"llvm/Support/MathExtras.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/Support/StorageUniquer.h\"\n \n namespace xla {\n@@ -885,7 +886,8 @@ SymbolicExpr SymbolicExpr::max(SymbolicExpr other) const {\n   return GetContext()->CreateBinaryOp(SymbolicExprType::kMax, *this, other);\n }\n \n-SymbolicExprContext::SymbolicExprContext() {\n+SymbolicExprContext::SymbolicExprContext(mlir::MLIRContext* mlir_context)\n+    : mlir_context_(mlir_context) {\n   uniquer_.registerParametricStorageType<SymbolicExprStorage>();\n }\n "
        },
        {
            "sha": "f02c091446e3192f8568238c29ce74a678940a46",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr.h",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr.h?ref=426bf926fe7591eb92efffd8a490e1f10f88bcdf",
            "patch": "@@ -27,6 +27,7 @@ limitations under the License.\n #include \"llvm/ADT/DenseSet.h\"\n #include \"llvm/ADT/Hashing.h\"\n #include \"llvm/Support/raw_ostream.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n #include \"mlir/Support/LLVM.h\"\n #include \"mlir/Support/StorageUniquer.h\"\n \n@@ -149,17 +150,22 @@ inline ::llvm::hash_code hash_value(SymbolicExpr expr) {\n \n class SymbolicExprContext {\n  public:\n-  SymbolicExprContext();\n+  explicit SymbolicExprContext(mlir::MLIRContext* mlir_context);\n   SymbolicExpr Parse(absl::string_view expr_str);\n   SymbolicExpr CreateConstant(int64_t value);\n   SymbolicExpr CreateVariable(int64_t var_id);\n   SymbolicExpr CreateBinaryOp(SymbolicExprType type, SymbolicExpr lhs,\n                               SymbolicExpr rhs);\n \n+  mlir::MLIRContext* GetMLIRContext() const { return mlir_context_; }\n+\n  private:\n   SymbolicExpr GetOrCreate(SymbolicExprType type, int64_t value,\n                            SymbolicExpr lhs, SymbolicExpr rhs);\n   mlir::StorageUniquer uniquer_;\n+  // TODO(b/446856305): MLIRContext is only used here temporarily while we have\n+  // AffineMap <-> SymbolicMap convertors.\n+  mlir::MLIRContext* mlir_context_;\n };\n \n }  // namespace gpu"
        },
        {
            "sha": "d515d6ff54260cac57855ac640c9c59a57b56828",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_expr_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_expr_test.cc?ref=426bf926fe7591eb92efffd8a490e1f10f88bcdf",
            "patch": "@@ -34,7 +34,8 @@ using ::testing::Values;\n // Test fixture to hold the context for all tests.\n struct SymbolicExprTest : public ::testing::Test {\n  protected:\n-  SymbolicExprContext ctx;\n+  // There should not be any usage of MLIRContext in this test.\n+  SymbolicExprContext ctx{nullptr};\n   SymbolicExpr v0 = ctx.CreateVariable(0);\n   SymbolicExpr v1 = ctx.CreateVariable(1);\n   SymbolicExpr c2 = ctx.CreateConstant(2);"
        },
        {
            "sha": "e3e6661bb9a0a0060165fe8db527ce4984cdcfea",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_converter_test.cc",
            "status": "modified",
            "additions": 47,
            "deletions": 52,
            "changes": 99,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_converter_test.cc?ref=426bf926fe7591eb92efffd8a490e1f10f88bcdf",
            "patch": "@@ -52,63 +52,61 @@ AffineMap ParseAffineMap(absl::string_view serialized_affine_map,\n       .getValue();\n }\n \n-TEST(SymbolicMapConverterTest, AffineToSymbolicRoundTrip) {\n-  MLIRContext mlir_context;\n-  SymbolicExprContext symbolic_context;\n+class SymbolicMapConverterTest : public ::testing::Test {\n+ public:\n+  SymbolicMapConverterTest() : symbolic_expr_context_(&mlir_context_) {}\n \n+  MLIRContext mlir_context_;\n+  SymbolicExprContext symbolic_expr_context_;\n+};\n+\n+TEST_F(SymbolicMapConverterTest, AffineToSymbolicRoundTrip) {\n   AffineMap affine_map = ParseAffineMap(\n       \"(d0, d1)[s0, s1] -> (d0 + s1 * 2, d1 - s0, d0 floordiv 3, d1 mod 4)\",\n-      &mlir_context);\n+      &mlir_context_);\n \n   SymbolicMap symbolic_map =\n-      AffineMapToSymbolicMap(affine_map, &symbolic_context);\n+      AffineMapToSymbolicMap(affine_map, &symbolic_expr_context_);\n \n   EXPECT_EQ(symbolic_map.GetNumResults(), 4);\n \n   AffineMap round_trip_map =\n-      SymbolicMapToAffineMap(symbolic_map, &mlir_context);\n+      SymbolicMapToAffineMap(symbolic_map, &mlir_context_);\n   EXPECT_EQ(affine_map, round_trip_map);\n }\n \n-TEST(SymbolicMapConverterTest, SymbolicToAffineFailure) {\n-  MLIRContext mlir_context;\n-  SymbolicExprContext symbolic_context;\n-\n-  SymbolicExpr d0 = symbolic_context.CreateVariable(0);\n-  SymbolicExpr c1 = symbolic_context.CreateConstant(1);\n+TEST_F(SymbolicMapConverterTest, SymbolicToAffineFailure) {\n+  SymbolicExpr d0 = symbolic_expr_context_.CreateVariable(0);\n+  SymbolicExpr c1 = symbolic_expr_context_.CreateConstant(1);\n   // kMax is not representable in AffineExpr.\n   SymbolicExpr max_expr = d0.max(c1);\n \n   AffineMap affine_map = SymbolicMapToAffineMap(\n-      SymbolicMap::Get(&symbolic_context, 1, 0, {max_expr}), &mlir_context);\n+      SymbolicMap::Get(&symbolic_expr_context_, 1, 0, {max_expr}),\n+      &mlir_context_);\n   EXPECT_FALSE(affine_map);\n }\n \n-TEST(SymbolicMapConverterTest, SymbolicToAffineNestedFailure) {\n-  MLIRContext mlir_context;\n-  SymbolicExprContext symbolic_context;\n-\n-  SymbolicExpr d0 = symbolic_context.CreateVariable(0);\n-  SymbolicExpr c1 = symbolic_context.CreateConstant(1);\n-  SymbolicExpr c2 = symbolic_context.CreateConstant(2);\n+TEST_F(SymbolicMapConverterTest, SymbolicToAffineNestedFailure) {\n+  SymbolicExpr d0 = symbolic_expr_context_.CreateVariable(0);\n+  SymbolicExpr c1 = symbolic_expr_context_.CreateConstant(1);\n+  SymbolicExpr c2 = symbolic_expr_context_.CreateConstant(2);\n \n   // d0 + max(c1, c2). max is not representable in AffineExpr.\n   SymbolicExpr nested_max_expr = d0 + c1.max(c2);\n \n   // This should not crash and should return a null AffineMap.\n   AffineMap affine_map = SymbolicMapToAffineMap(\n-      SymbolicMap::Get(&symbolic_context, 1, 0, {nested_max_expr}),\n-      &mlir_context);\n+      SymbolicMap::Get(&symbolic_expr_context_, 1, 0, {nested_max_expr}),\n+      &mlir_context_);\n   EXPECT_FALSE(affine_map);\n }\n \n-TEST(SymbolicMapConverterTest, ConvertAffineConstraintsToSymbolicConstraints) {\n-  MLIRContext mlir_context;\n-  SymbolicExprContext symbolic_context;\n-\n-  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &mlir_context);\n-  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &mlir_context);\n-  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &mlir_context);\n+TEST_F(SymbolicMapConverterTest,\n+       ConvertAffineConstraintsToSymbolicConstraints) {\n+  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &mlir_context_);\n+  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &mlir_context_);\n+  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &mlir_context_);\n \n   llvm::MapVector<mlir::AffineExpr, Interval> affine_constraints;\n   affine_constraints[d0 + s0] = {0, 127};\n@@ -117,28 +115,25 @@ TEST(SymbolicMapConverterTest, ConvertAffineConstraintsToSymbolicConstraints) {\n \n   llvm::MapVector<SymbolicExpr, Interval> symbolic_constraints =\n       ConvertAffineConstraintsToSymbolicConstraints(\n-          affine_constraints, &symbolic_context, /*num_dims=*/1);\n+          affine_constraints, &symbolic_expr_context_, /*num_dims=*/1);\n \n-  SymbolicExpr sym_d0 = symbolic_context.CreateVariable(0);\n-  SymbolicExpr sym_s0 = symbolic_context.CreateVariable(1);\n-  SymbolicExpr sym_c1 = symbolic_context.CreateConstant(1);\n+  SymbolicExpr sym_d0 = symbolic_expr_context_.CreateVariable(0);\n+  SymbolicExpr sym_s0 = symbolic_expr_context_.CreateVariable(1);\n+  SymbolicExpr sym_c1 = symbolic_expr_context_.CreateConstant(1);\n \n   EXPECT_EQ(symbolic_constraints.size(), 3);\n   EXPECT_EQ(symbolic_constraints[sym_d0 + sym_s0], (Interval{0, 127}));\n   EXPECT_EQ(symbolic_constraints[sym_s0 * 2], (Interval{0, 63}));\n   EXPECT_EQ(symbolic_constraints[sym_d0 - sym_c1], (Interval{10, 20}));\n }\n \n-TEST(AffineToSymbolicExprTest, ConvertAffineToSymbolicExpr) {\n-  MLIRContext mlir_context;\n-  SymbolicExprContext symbolic_context;\n-\n-  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &mlir_context);\n-  mlir::AffineExpr d1 = mlir::getAffineDimExpr(1, &mlir_context);\n-  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &mlir_context);\n-  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &mlir_context);\n-  mlir::AffineExpr c2 = mlir::getAffineConstantExpr(2, &mlir_context);\n-  mlir::AffineExpr c3 = mlir::getAffineConstantExpr(3, &mlir_context);\n+TEST_F(SymbolicMapConverterTest, ConvertAffineToSymbolicExpr) {\n+  mlir::AffineExpr d0 = mlir::getAffineDimExpr(0, &mlir_context_);\n+  mlir::AffineExpr d1 = mlir::getAffineDimExpr(1, &mlir_context_);\n+  mlir::AffineExpr s0 = mlir::getAffineSymbolExpr(0, &mlir_context_);\n+  mlir::AffineExpr c1 = mlir::getAffineConstantExpr(1, &mlir_context_);\n+  mlir::AffineExpr c2 = mlir::getAffineConstantExpr(2, &mlir_context_);\n+  mlir::AffineExpr c3 = mlir::getAffineConstantExpr(3, &mlir_context_);\n \n   mlir::AffineExpr affine_expr =\n       mlir::getAffineBinaryOpExpr(\n@@ -148,19 +143,19 @@ TEST(AffineToSymbolicExprTest, ConvertAffineToSymbolicExpr) {\n           c3) +\n       d1;  // ((d0 * 2 + s0 - 1) floordiv 2) mod 3 + d1\n \n-  SymbolicExpr exp_d0 = symbolic_context.CreateVariable(0);\n-  SymbolicExpr exp_d1 = symbolic_context.CreateVariable(1);\n-  SymbolicExpr exp_s0 = symbolic_context.CreateVariable(2);\n-  SymbolicExpr exp_c1 = symbolic_context.CreateConstant(1);\n-  SymbolicExpr exp_c2 = symbolic_context.CreateConstant(2);\n-  SymbolicExpr exp_c3 = symbolic_context.CreateConstant(3);\n+  SymbolicExpr exp_d0 = symbolic_expr_context_.CreateVariable(0);\n+  SymbolicExpr exp_d1 = symbolic_expr_context_.CreateVariable(1);\n+  SymbolicExpr exp_s0 = symbolic_expr_context_.CreateVariable(2);\n+  SymbolicExpr exp_c1 = symbolic_expr_context_.CreateConstant(1);\n+  SymbolicExpr exp_c2 = symbolic_expr_context_.CreateConstant(2);\n+  SymbolicExpr exp_c3 = symbolic_expr_context_.CreateConstant(3);\n \n   SymbolicExpr expected_symbolic_expr =\n       ((exp_d0 * exp_c2 + exp_s0 - exp_c1) / exp_c2) % exp_c3 + exp_d1;\n \n-  EXPECT_EQ(\n-      AffineToSymbolicExpr(affine_expr, &symbolic_context, /*num_dims=*/2),\n-      expected_symbolic_expr);\n+  EXPECT_EQ(AffineToSymbolicExpr(affine_expr, &symbolic_expr_context_,\n+                                 /*num_dims=*/2),\n+            expected_symbolic_expr);\n }\n \n }  // namespace"
        },
        {
            "sha": "cfabfd6f85eebd3219af9546686e61ae062d20c9",
            "filename": "third_party/xla/xla/service/gpu/model/experimental/symbolic_map_test.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 24,
            "changes": 40,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/426bf926fe7591eb92efffd8a490e1f10f88bcdf/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fmodel%2Fexperimental%2Fsymbolic_map_test.cc?ref=426bf926fe7591eb92efffd8a490e1f10f88bcdf",
            "patch": "@@ -26,8 +26,12 @@ namespace {\n \n using ::testing::ElementsAre;\n \n-TEST(SymbolicMapTest, GetSymbolAndDimExpressions) {\n-  SymbolicExprContext ctx;\n+struct SymbolicMapTest : public ::testing::Test {\n+  // TODO(b/446856305): MLIRContext should not be used in this test.\n+  SymbolicExprContext ctx{nullptr};\n+};\n+\n+TEST_F(SymbolicMapTest, GetSymbolAndDimExpressions) {\n   SymbolicExpr d0 = ctx.CreateVariable(0);\n   SymbolicExpr d1 = ctx.CreateVariable(1);\n   SymbolicExpr s0 = ctx.CreateVariable(2);\n@@ -39,8 +43,7 @@ TEST(SymbolicMapTest, GetSymbolAndDimExpressions) {\n   EXPECT_EQ(map.GetDimExpression(1), d1);\n }\n \n-TEST(SymbolicMapTest, ToString) {\n-  SymbolicExprContext ctx;\n+TEST_F(SymbolicMapTest, ToString) {\n   SymbolicExpr d0 = ctx.CreateVariable(0);\n   SymbolicExpr d1 = ctx.CreateVariable(1);\n   SymbolicExpr s0 = ctx.CreateVariable(2);\n@@ -62,16 +65,13 @@ TEST(SymbolicMapTest, ToString) {\n   EXPECT_EQ(symbols_only.ToString(), \"()[s0, s1] -> (s0, s1)\");\n }\n \n-TEST(SymbolicMapTest, IsEmpty) {\n-  SymbolicExprContext ctx;\n+TEST_F(SymbolicMapTest, IsEmpty) {\n   EXPECT_TRUE(SymbolicMap::Get(&ctx, 0, 0, {}).IsEmpty());\n   EXPECT_TRUE(SymbolicMap::Get(&ctx, 2, 1, {}).IsEmpty());\n   EXPECT_FALSE(SymbolicMap::Get(&ctx, 1, 0, {ctx.CreateVariable(0)}).IsEmpty());\n }\n \n-TEST(SymbolicMapTest, IsIdentity) {\n-  SymbolicExprContext ctx;\n-\n+TEST_F(SymbolicMapTest, IsIdentity) {\n   SymbolicMap true_identity = SymbolicMap::Get(\n       &ctx, 2, 0, {ctx.CreateVariable(0), ctx.CreateVariable(1)});\n   EXPECT_TRUE(true_identity.IsIdentity());\n@@ -97,9 +97,7 @@ TEST(SymbolicMapTest, IsIdentity) {\n   EXPECT_FALSE(unordered_variable_id.IsIdentity());\n }\n \n-TEST(SymbolicMapTest, GetConstantResults) {\n-  SymbolicExprContext ctx;\n-\n+TEST_F(SymbolicMapTest, GetConstantResults) {\n   SymbolicMap all_constants_map = SymbolicMap::Get(\n       &ctx, 0, 0, {ctx.CreateConstant(5), ctx.CreateConstant(10)});\n   EXPECT_TRUE(all_constants_map.IsConstant());\n@@ -116,8 +114,7 @@ TEST(SymbolicMapTest, GetConstantResults) {\n   EXPECT_THAT(no_results_map.GetConstantResults(), ElementsAre());\n }\n \n-TEST(SymbolicMapTest, ReplaceDimsAndSymbols) {\n-  SymbolicExprContext ctx;\n+TEST_F(SymbolicMapTest, ReplaceDimsAndSymbols) {\n   SymbolicExpr d0 = ctx.CreateVariable(0);\n   SymbolicExpr d1 = ctx.CreateVariable(1);\n   SymbolicExpr s0 = ctx.CreateVariable(2);\n@@ -148,8 +145,7 @@ TEST(SymbolicMapTest, ReplaceDimsAndSymbols) {\n               ElementsAre((new_d0 * c1 + new_d1) + new_s0 * c2));\n }\n \n-TEST(SymbolicMapTest, Compose) {\n-  SymbolicExprContext ctx;\n+TEST_F(SymbolicMapTest, Compose) {\n   SymbolicExpr d0 = ctx.CreateVariable(0);\n   SymbolicExpr d1 = ctx.CreateVariable(1);\n \n@@ -198,8 +194,7 @@ TEST(SymbolicMapTest, Compose) {\n               ElementsAre(d0 + reindexed_map1_s0, d1 * 2));\n }\n \n-TEST(SymbolicMapTest, Replace) {\n-  SymbolicExprContext ctx;\n+TEST_F(SymbolicMapTest, Replace) {\n   SymbolicExpr d0 = ctx.CreateVariable(0);\n   SymbolicExpr d1 = ctx.CreateVariable(1);\n   SymbolicExpr c2 = ctx.CreateConstant(2);\n@@ -220,8 +215,7 @@ TEST(SymbolicMapTest, Replace) {\n   EXPECT_EQ(no_replacement_map, map);\n }\n \n-TEST(SymbolicMapTest, GetUnusedVariables) {\n-  SymbolicExprContext ctx;\n+TEST_F(SymbolicMapTest, GetUnusedVariables) {\n   SymbolicExpr d0 = ctx.CreateVariable(0);\n   SymbolicExpr d1 = ctx.CreateVariable(1);\n   // d2 is unused.\n@@ -275,8 +269,7 @@ TEST(SymbolicMapTest, GetUnusedVariables) {\n   EXPECT_FALSE(no_dim_symbols[1]);\n }\n \n-TEST(SymbolicMapTest, CompressDims) {\n-  SymbolicExprContext ctx;\n+TEST_F(SymbolicMapTest, CompressDims) {\n   SymbolicExpr d0 = ctx.CreateVariable(0);\n   [[maybe_unused]] SymbolicExpr d1 = ctx.CreateVariable(1);  // Unused\n   SymbolicExpr d2 = ctx.CreateVariable(2);\n@@ -305,8 +298,7 @@ TEST(SymbolicMapTest, CompressDims) {\n                \"Attempting to compress a used dimension: 0\");\n }\n \n-TEST(SymbolicMapTest, CompressSymbols) {\n-  SymbolicExprContext ctx;\n+TEST_F(SymbolicMapTest, CompressSymbols) {\n   SymbolicExpr d0 = ctx.CreateVariable(0);\n   SymbolicExpr s0 = ctx.CreateVariable(1);\n   [[maybe_unused]] SymbolicExpr s1 = ctx.CreateVariable(2);  // Unused"
        }
    ],
    "stats": {
        "total": 155,
        "additions": 76,
        "deletions": 79
    }
}