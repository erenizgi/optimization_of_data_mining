{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 832621143",
    "sha": "d3478df12513c38f31d3ad70b40ba376f1297a1c",
    "files": [
        {
            "sha": "0c7fc36e5d295bda1b10f7b15365989e01211634",
            "filename": "third_party/xla/xla/tsl/lib/io/table.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable.cc?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -34,14 +34,14 @@ struct Table::Rep {\n   Options options;\n   absl::Status status;\n   RandomAccessFile* file;\n-  uint64 cache_id;\n+  uint64_t cache_id;\n \n   BlockHandle metaindex_handle;  // Handle to metaindex_block: saved from footer\n   Block* index_block;\n };\n \n absl::Status Table::Open(const Options& options, RandomAccessFile* file,\n-                         uint64 size, Table** table) {\n+                         uint64_t size, Table** table) {\n   *table = nullptr;\n   if (size < Footer::kEncodedLength) {\n     return errors::DataLoss(\"file is too short to be an sstable\");\n@@ -181,10 +181,10 @@ absl::Status Table::InternalGet(absl::string_view key, void* arg,\n   return s;\n }\n \n-uint64 Table::ApproximateOffsetOf(absl::string_view key) const {\n+uint64_t Table::ApproximateOffsetOf(absl::string_view key) const {\n   Iterator* index_iter = rep_->index_block->NewIterator();\n   index_iter->Seek(key);\n-  uint64 result;\n+  uint64_t result;\n   if (index_iter->Valid()) {\n     BlockHandle handle;\n     absl::string_view input = index_iter->value();"
        },
        {
            "sha": "253ad4dad7258650c589352405378641ff7eb1f4",
            "filename": "third_party/xla/xla/tsl/lib/io/table.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable.h?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -44,7 +44,7 @@ class Table {\n   // \"*file\", but the client must ensure that \"file\" remains live\n   // for the duration of the returned table's lifetime.\n   static absl::Status Open(const Options& options, tsl::RandomAccessFile* file,\n-                           uint64 file_size, Table** table);\n+                           uint64_t file_size, Table** table);\n \n   ~Table();\n \n@@ -59,7 +59,7 @@ class Table {\n   // bytes, and so includes effects like compression of the underlying data.\n   // E.g., the approximate offset of the last key in the table will\n   // be close to the file length.\n-  uint64 ApproximateOffsetOf(absl::string_view key) const;\n+  uint64_t ApproximateOffsetOf(absl::string_view key) const;\n \n  private:\n   struct Rep;"
        },
        {
            "sha": "0ee043a09093e8c1abdc10f66f1507f3184cce40",
            "filename": "third_party/xla/xla/tsl/lib/io/table_builder.cc",
            "status": "modified",
            "additions": 17,
            "deletions": 17,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable_builder.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable_builder.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable_builder.cc?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -33,7 +33,7 @@ namespace table {\n \n namespace {\n \n-void FindShortestSeparator(string* start, absl::string_view limit) {\n+void FindShortestSeparator(std::string* start, absl::string_view limit) {\n   // Find length of common prefix\n   size_t min_length = std::min(start->size(), limit.size());\n   size_t diff_index = 0;\n@@ -45,22 +45,22 @@ void FindShortestSeparator(string* start, absl::string_view limit) {\n   if (diff_index >= min_length) {\n     // Do not shorten if one string is a prefix of the other\n   } else {\n-    uint8 diff_byte = static_cast<uint8>((*start)[diff_index]);\n-    if (diff_byte < static_cast<uint8>(0xff) &&\n-        diff_byte + 1 < static_cast<uint8>(limit[diff_index])) {\n+    uint8_t diff_byte = static_cast<uint8_t>((*start)[diff_index]);\n+    if (diff_byte < static_cast<uint8_t>(0xff) &&\n+        diff_byte + 1 < static_cast<uint8_t>(limit[diff_index])) {\n       (*start)[diff_index]++;\n       start->resize(diff_index + 1);\n       assert(absl::string_view(*start).compare(limit) < 0);\n     }\n   }\n }\n \n-void FindShortSuccessor(string* key) {\n+void FindShortSuccessor(std::string* key) {\n   // Find first character that can be incremented\n   size_t n = key->size();\n   for (size_t i = 0; i < n; i++) {\n-    const uint8 byte = (*key)[i];\n-    if (byte != static_cast<uint8>(0xff)) {\n+    const uint8_t byte = (*key)[i];\n+    if (byte != static_cast<uint8_t>(0xff)) {\n       (*key)[i] = byte + 1;\n       key->resize(i + 1);\n       return;\n@@ -74,11 +74,11 @@ struct TableBuilder::Rep {\n   Options options;\n   Options index_block_options;\n   WritableFile* file;\n-  uint64 offset;\n+  uint64_t offset;\n   absl::Status status;\n   BlockBuilder data_block;\n   BlockBuilder index_block;\n-  string last_key;\n+  std::string last_key;\n   int64_t num_entries;\n   bool closed;  // Either Finish() or Abandon() has been called.\n \n@@ -94,7 +94,7 @@ struct TableBuilder::Rep {\n   bool pending_index_entry;\n   BlockHandle pending_handle;  // Handle to add to index block\n \n-  string compressed_output;\n+  std::string compressed_output;\n \n   Rep(const Options& opt, WritableFile* f)\n       : options(opt),\n@@ -136,7 +136,7 @@ void TableBuilder::Add(absl::string_view key, absl::string_view value) {\n   if (r->pending_index_entry) {\n     assert(r->data_block.empty());\n     FindShortestSeparator(&r->last_key, key);\n-    string handle_encoding;\n+    std::string handle_encoding;\n     r->pending_handle.EncodeTo(&handle_encoding);\n     r->index_block.Add(r->last_key, absl::string_view(handle_encoding));\n     r->pending_index_entry = false;\n@@ -183,7 +183,7 @@ void TableBuilder::WriteBlock(BlockBuilder* block, BlockHandle* handle) {\n       break;\n \n     case kSnappyCompression: {\n-      string* compressed = &r->compressed_output;\n+      std::string* compressed = &r->compressed_output;\n       if (port::Snappy_Compress(raw.data(), raw.size(), compressed) &&\n           compressed->size() < raw.size() - (raw.size() / 8u)) {\n         block_contents = *compressed;\n@@ -210,7 +210,7 @@ void TableBuilder::WriteRawBlock(absl::string_view block_contents,\n   if (r->status.ok()) {\n     char trailer[kBlockTrailerSize];\n     trailer[0] = type;\n-    uint32 crc = crc32c::Value(block_contents.data(), block_contents.size());\n+    uint32_t crc = crc32c::Value(block_contents.data(), block_contents.size());\n     crc = crc32c::Extend(crc, trailer, 1);  // Extend crc to cover block type\n     core::EncodeFixed32(trailer + 1, crc32c::Mask(crc));\n     r->status = r->file->Append(absl::string_view(trailer, kBlockTrailerSize));\n@@ -241,7 +241,7 @@ absl::Status TableBuilder::Finish() {\n   if (ok()) {\n     if (r->pending_index_entry) {\n       FindShortSuccessor(&r->last_key);\n-      string handle_encoding;\n+      std::string handle_encoding;\n       r->pending_handle.EncodeTo(&handle_encoding);\n       r->index_block.Add(r->last_key, absl::string_view(handle_encoding));\n       r->pending_index_entry = false;\n@@ -254,7 +254,7 @@ absl::Status TableBuilder::Finish() {\n     Footer footer;\n     footer.set_metaindex_handle(metaindex_block_handle);\n     footer.set_index_handle(index_block_handle);\n-    string footer_encoding;\n+    std::string footer_encoding;\n     footer.EncodeTo(&footer_encoding);\n     r->status = r->file->Append(footer_encoding);\n     if (r->status.ok()) {\n@@ -270,9 +270,9 @@ void TableBuilder::Abandon() {\n   r->closed = true;\n }\n \n-uint64 TableBuilder::NumEntries() const { return rep_->num_entries; }\n+uint64_t TableBuilder::NumEntries() const { return rep_->num_entries; }\n \n-uint64 TableBuilder::FileSize() const { return rep_->offset; }\n+uint64_t TableBuilder::FileSize() const { return rep_->offset; }\n \n }  // namespace table\n }  // namespace tsl"
        },
        {
            "sha": "bbbb2da5931f8c33f03a740b252fd9fb6a581db2",
            "filename": "third_party/xla/xla/tsl/lib/io/table_builder.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable_builder.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable_builder.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable_builder.h?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -75,11 +75,11 @@ class TableBuilder {\n   void Abandon();\n \n   // Number of calls to Add() so far.\n-  uint64 NumEntries() const;\n+  uint64_t NumEntries() const;\n \n   // Size of the file generated so far.  If invoked after a successful\n   // Finish() call, returns the size of the final generated file.\n-  uint64 FileSize() const;\n+  uint64_t FileSize() const;\n \n  private:\n   bool ok() const { return status().ok(); }"
        },
        {
            "sha": "2411834653cc4017ce07c8c83946d8535bbf2ca0",
            "filename": "third_party/xla/xla/tsl/lib/io/table_test.cc",
            "status": "modified",
            "additions": 48,
            "deletions": 46,
            "changes": 94,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftable_test.cc?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -41,30 +41,30 @@ typedef std::pair<absl::string_view, absl::string_view> StringPiecePair;\n \n namespace test {\n static absl::string_view RandomString(random::SimplePhilox* rnd, int len,\n-                                      string* dst) {\n+                                      std::string* dst) {\n   dst->resize(len);\n   for (int i = 0; i < len; i++) {\n     (*dst)[i] = static_cast<char>(' ' + rnd->Uniform(95));  // ' ' .. '~'\n   }\n   return absl::string_view(*dst);\n }\n-static string RandomKey(random::SimplePhilox* rnd, int len) {\n+static std::string RandomKey(random::SimplePhilox* rnd, int len) {\n   // Make sure to generate a wide variety of characters so we\n   // test the boundary conditions for short-key optimizations.\n   static const char kTestChars[] = {'\\0', '\\1', 'a',    'b',    'c',\n                                     'd',  'e',  '\\xfd', '\\xfe', '\\xff'};\n-  string result;\n+  std::string result;\n   for (int i = 0; i < len; i++) {\n     result += kTestChars[rnd->Uniform(sizeof(kTestChars))];\n   }\n   return result;\n }\n static absl::string_view CompressibleString(random::SimplePhilox* rnd,\n                                             double compressed_fraction,\n-                                            size_t len, string* dst) {\n+                                            size_t len, std::string* dst) {\n   int raw = static_cast<int>(len * compressed_fraction);\n   if (raw < 1) raw = 1;\n-  string raw_data;\n+  std::string raw_data;\n   RandomString(rnd, raw, &raw_data);\n \n   // Duplicate the random data until we have filled \"len\" bytes\n@@ -77,13 +77,13 @@ static absl::string_view CompressibleString(random::SimplePhilox* rnd,\n }\n }  // namespace test\n \n-static void Increment(string* key) { key->push_back('\\0'); }\n+static void Increment(std::string* key) { key->push_back('\\0'); }\n \n // An STL comparator that compares two StringPieces\n namespace {\n struct STLLessThan {\n   STLLessThan() {}\n-  bool operator()(const string& a, const string& b) const {\n+  bool operator()(const std::string& a, const std::string& b) const {\n     return absl::string_view(a).compare(absl::string_view(b)) < 0;\n   }\n };\n@@ -93,7 +93,7 @@ class StringSink : public WritableFile {\n  public:\n   ~StringSink() override {}\n \n-  const string& contents() const { return contents_; }\n+  const std::string& contents() const { return contents_; }\n \n   absl::Status Close() override { return absl::OkStatus(); }\n   absl::Status Flush() override { return absl::OkStatus(); }\n@@ -112,7 +112,7 @@ class StringSink : public WritableFile {\n   }\n \n  private:\n-  string contents_;\n+  std::string contents_;\n };\n \n class StringSource : public RandomAccessFile {\n@@ -122,13 +122,13 @@ class StringSource : public RandomAccessFile {\n \n   ~StringSource() override {}\n \n-  uint64 Size() const { return contents_.size(); }\n+  uint64_t Size() const { return contents_.size(); }\n \n   absl::Status Name(absl::string_view* result) const override {\n     return errors::Unimplemented(\"StringSource does not support Name()\");\n   }\n \n-  absl::Status Read(uint64 offset, size_t n, absl::string_view* result,\n+  absl::Status Read(uint64_t offset, size_t n, absl::string_view* result,\n                     char* scratch) const override {\n     if (offset > contents_.size()) {\n       return errors::InvalidArgument(\"invalid Read offset\");\n@@ -142,14 +142,14 @@ class StringSource : public RandomAccessFile {\n     return absl::OkStatus();\n   }\n \n-  uint64 BytesRead() const { return bytes_read_; }\n+  uint64_t BytesRead() const { return bytes_read_; }\n \n  private:\n-  string contents_;\n-  mutable uint64 bytes_read_;\n+  std::string contents_;\n+  mutable uint64_t bytes_read_;\n };\n \n-typedef std::map<string, string, STLLessThan> KVMap;\n+typedef std::map<std::string, std::string, STLLessThan> KVMap;\n \n // Helper class for tests to unify the interface between\n // BlockBuilder/TableBuilder and Block/Table.\n@@ -158,14 +158,15 @@ class Constructor {\n   explicit Constructor() : data_(STLLessThan()) {}\n   virtual ~Constructor() {}\n \n-  void Add(const string& key, absl::string_view value) {\n-    data_[key] = string(value);\n+  void Add(const std::string& key, absl::string_view value) {\n+    data_[key] = std::string(value);\n   }\n \n   // Finish constructing the data structure with all the keys that have\n   // been added so far.  Returns the keys in sorted order in \"*keys\"\n   // and stores the key/value pairs in \"*kvmap\"\n-  void Finish(const Options& options, std::vector<string>* keys, KVMap* kvmap) {\n+  void Finish(const Options& options, std::vector<std::string>* keys,\n+              KVMap* kvmap) {\n     *kvmap = data_;\n     keys->clear();\n     for (KVMap::const_iterator it = data_.begin(); it != data_.end(); ++it) {\n@@ -201,7 +202,7 @@ class BlockConstructor : public Constructor {\n       builder.Add(it->first, it->second);\n     }\n     // Open the block\n-    data_ = string(builder.Finish());\n+    data_ = std::string(builder.Finish());\n     BlockContents contents;\n     contents.data = data_;\n     contents.cacheable = false;\n@@ -212,7 +213,7 @@ class BlockConstructor : public Constructor {\n   Iterator* NewIterator() const override { return block_->NewIterator(); }\n \n  private:\n-  string data_;\n+  std::string data_;\n   Block* block_;\n };\n \n@@ -242,11 +243,11 @@ class TableConstructor : public Constructor {\n \n   Iterator* NewIterator() const override { return table_->NewIterator(); }\n \n-  uint64 ApproximateOffsetOf(absl::string_view key) const {\n+  uint64_t ApproximateOffsetOf(absl::string_view key) const {\n     return table_->ApproximateOffsetOf(key);\n   }\n \n-  uint64 BytesRead() const { return source_->BytesRead(); }\n+  uint64_t BytesRead() const { return source_->BytesRead(); }\n \n  private:\n   void Reset() {\n@@ -298,20 +299,21 @@ class Harness : public ::testing::Test {\n \n   ~Harness() override { delete constructor_; }\n \n-  void Add(const string& key, const string& value) {\n+  void Add(const std::string& key, const std::string& value) {\n     constructor_->Add(key, value);\n   }\n \n   void Test(random::SimplePhilox* rnd, int num_random_access_iters = 200) {\n-    std::vector<string> keys;\n+    std::vector<std::string> keys;\n     KVMap data;\n     constructor_->Finish(options_, &keys, &data);\n \n     TestForwardScan(keys, data);\n     TestRandomAccess(rnd, keys, data, num_random_access_iters);\n   }\n \n-  void TestForwardScan(const std::vector<string>& keys, const KVMap& data) {\n+  void TestForwardScan(const std::vector<std::string>& keys,\n+                       const KVMap& data) {\n     Iterator* iter = constructor_->NewIterator();\n     ASSERT_TRUE(!iter->Valid());\n     iter->SeekToFirst();\n@@ -325,7 +327,7 @@ class Harness : public ::testing::Test {\n   }\n \n   void TestRandomAccess(random::SimplePhilox* rnd,\n-                        const std::vector<string>& keys, const KVMap& data,\n+                        const std::vector<std::string>& keys, const KVMap& data,\n                         int num_random_access_iters) {\n     static const bool kVerbose = false;\n     Iterator* iter = constructor_->NewIterator();\n@@ -356,7 +358,7 @@ class Harness : public ::testing::Test {\n         }\n \n         case 2: {\n-          string key = PickRandomKey(rnd, keys);\n+          std::string key = PickRandomKey(rnd, keys);\n           model_iter = data.lower_bound(key);\n           if (kVerbose)\n             fprintf(stderr, \"Seek '%s'\\n\", absl::CEscape(key).c_str());\n@@ -396,13 +398,13 @@ class Harness : public ::testing::Test {\n     }\n   }\n \n-  string PickRandomKey(random::SimplePhilox* rnd,\n-                       const std::vector<string>& keys) {\n+  std::string PickRandomKey(random::SimplePhilox* rnd,\n+                            const std::vector<std::string>& keys) {\n     if (keys.empty()) {\n       return \"foo\";\n     } else {\n       const int index = rnd->Uniform(keys.size());\n-      string result = keys[index];\n+      std::string result = keys[index];\n       switch (rnd->Uniform(3)) {\n         case 0:\n           // Return an existing key\n@@ -443,7 +445,7 @@ TEST_F(Harness, Empty) {\n // code never generates such blocks, but the Java version of leveldb\n // seems to.\n TEST_F(Harness, ZeroRestartPointsInBlock) {\n-  char data[sizeof(uint32)];\n+  char data[sizeof(uint32_t)];\n   memset(data, 0, sizeof(data));\n   BlockContents contents;\n   contents.data = absl::string_view(data, sizeof(data));\n@@ -497,8 +499,8 @@ TEST_F(Harness, SimpleMultiBigValues) {\n     random::PhiloxRandom philox(testing::RandomSeed() + 3, 17);\n     random::SimplePhilox rnd(&philox);\n     Add(\"ainitial\", \"tiny\");\n-    Add(\"anext\", string(10000000, 'a'));\n-    Add(\"anext2\", string(10000000, 'b'));\n+    Add(\"anext\", std::string(10000000, 'a'));\n+    Add(\"anext2\", std::string(10000000, 'b'));\n     Add(\"azz\", \"tiny\");\n     Test(&rnd, 100 /* num_random_access_iters */);\n   }\n@@ -526,16 +528,16 @@ TEST_F(Harness, Randomized) {\n                 int(kNumTestArgs), num_entries);\n       }\n       for (int e = 0; e < num_entries; e++) {\n-        string v;\n+        std::string v;\n         Add(test::RandomKey(&rnd, rnd.Skewed(4)),\n-            string(test::RandomString(&rnd, rnd.Skewed(5), &v)));\n+            std::string(test::RandomString(&rnd, rnd.Skewed(5), &v)));\n       }\n       Test(&rnd);\n     }\n   }\n }\n \n-static bool Between(uint64 val, uint64 low, uint64 high) {\n+static bool Between(uint64_t val, uint64_t low, uint64_t high) {\n   bool result = (val >= low) && (val <= high);\n   if (!result) {\n     fprintf(stderr, \"Value %llu is not in range [%llu, %llu]\\n\",\n@@ -552,12 +554,12 @@ TEST(TableTest, ApproximateOffsetOfPlain) {\n   TableConstructor c;\n   c.Add(\"k01\", \"hello\");\n   c.Add(\"k02\", \"hello2\");\n-  c.Add(\"k03\", string(10000, 'x'));\n-  c.Add(\"k04\", string(200000, 'x'));\n-  c.Add(\"k05\", string(300000, 'x'));\n+  c.Add(\"k03\", std::string(10000, 'x'));\n+  c.Add(\"k04\", std::string(200000, 'x'));\n+  c.Add(\"k05\", std::string(300000, 'x'));\n   c.Add(\"k06\", \"hello3\");\n-  c.Add(\"k07\", string(100000, 'x'));\n-  std::vector<string> keys;\n+  c.Add(\"k07\", std::string(100000, 'x'));\n+  std::vector<std::string> keys;\n   KVMap kvmap;\n   Options options;\n   options.block_size = 1024;\n@@ -578,7 +580,7 @@ TEST(TableTest, ApproximateOffsetOfPlain) {\n }\n \n static bool SnappyCompressionSupported() {\n-  string out;\n+  std::string out;\n   absl::string_view in = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n   return port::Snappy_Compress(in.data(), in.size(), &out);\n }\n@@ -592,12 +594,12 @@ TEST(TableTest, ApproximateOffsetOfCompressed) {\n   random::PhiloxRandom philox(301, 17);\n   random::SimplePhilox rnd(&philox);\n   TableConstructor c;\n-  string tmp;\n+  std::string tmp;\n   c.Add(\"k01\", \"hello\");\n   c.Add(\"k02\", test::CompressibleString(&rnd, 0.25, 10000, &tmp));\n   c.Add(\"k03\", \"hello3\");\n   c.Add(\"k04\", test::CompressibleString(&rnd, 0.25, 10000, &tmp));\n-  std::vector<string> keys;\n+  std::vector<std::string> keys;\n   KVMap kvmap;\n   Options options;\n   options.block_size = 1024;\n@@ -614,12 +616,12 @@ TEST(TableTest, ApproximateOffsetOfCompressed) {\n TEST(TableTest, SeekToFirstKeyDoesNotReadTooMuch) {\n   random::PhiloxRandom philox(301, 17);\n   random::SimplePhilox rnd(&philox);\n-  string tmp;\n+  std::string tmp;\n   TableConstructor c;\n   c.Add(\"k01\", \"firstvalue\");\n   c.Add(\"k03\", test::CompressibleString(&rnd, 0.25, 1000000, &tmp));\n   c.Add(\"k04\", \"abc\");\n-  std::vector<string> keys;\n+  std::vector<std::string> keys;\n   KVMap kvmap;\n   Options options;\n   options.block_size = 1024;"
        },
        {
            "sha": "91a676ef9382d106d6d334ffd470242cb58c93ca",
            "filename": "third_party/xla/xla/tsl/lib/io/two_level_iterator.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftwo_level_iterator.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftwo_level_iterator.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Ftwo_level_iterator.cc?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -77,7 +77,7 @@ class TwoLevelIterator : public Iterator {\n   Iterator* data_iter_;  // May be NULL\n   // If data_iter_ is non-NULL, then \"data_block_handle_\" holds the\n   // \"index_value\" passed to block_function_ to create the data_iter_.\n-  string data_block_handle_;\n+  std::string data_block_handle_;\n };\n \n TwoLevelIterator::TwoLevelIterator(Iterator* index_iter,"
        },
        {
            "sha": "0fe1e4e15ba55540ecaf84f1f9a8c8ab98016bd0",
            "filename": "third_party/xla/xla/tsl/lib/io/zlib_buffers_test.cc",
            "status": "modified",
            "additions": 23,
            "deletions": 22,
            "changes": 45,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_buffers_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_buffers_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_buffers_test.cc?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -35,8 +35,8 @@ static std::vector<int> OutputBufferSizes() { return {100, 200, 500, 1000}; }\n \n static std::vector<int> NumCopies() { return {1, 50, 500}; }\n \n-static string GetRecord() {\n-  static const string lorem_ipsum =\n+static std::string GetRecord() {\n+  static const std::string lorem_ipsum =\n       \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n       \" Fusce vehicula tincidunt libero sit amet ultrices. Vestibulum non \"\n       \"felis augue. Duis vitae augue id lectus lacinia congue et ut purus. \"\n@@ -52,8 +52,8 @@ static string GetRecord() {\n   return lorem_ipsum;\n }\n \n-static string GenTestString(int copies = 1) {\n-  string result = \"\";\n+static std::string GenTestString(int copies = 1) {\n+  std::string result = \"\";\n   for (int i = 0; i < copies; i++) {\n     result += GetRecord();\n   }\n@@ -65,11 +65,11 @@ typedef io::ZlibCompressionOptions CompressionOptions;\n void TestAllCombinations(CompressionOptions input_options,\n                          CompressionOptions output_options) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   for (auto file_size : NumCopies()) {\n     // Write to compressed file\n-    string data = GenTestString(file_size);\n+    std::string data = GenTestString(file_size);\n     for (auto input_buf_size : InputBufferSizes()) {\n       for (auto output_buf_size : OutputBufferSizes()) {\n         std::unique_ptr<WritableFile> file_writer;\n@@ -111,18 +111,18 @@ TEST(ZlibBuffers, Gzip) {\n   TestAllCombinations(CompressionOptions::GZIP(), CompressionOptions::GZIP());\n }\n \n-void TestMultipleWrites(uint8 input_buf_size, uint8 output_buf_size,\n+void TestMultipleWrites(uint8_t input_buf_size, uint8_t output_buf_size,\n                         int num_writes, bool with_flush = false) {\n   Env* env = Env::Default();\n   CompressionOptions input_options = CompressionOptions::DEFAULT();\n   CompressionOptions output_options = CompressionOptions::DEFAULT();\n \n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n-  string data = GenTestString();\n+  std::string data = GenTestString();\n   std::unique_ptr<WritableFile> file_writer;\n-  string actual_result;\n-  string expected_result;\n+  std::string actual_result;\n+  std::string expected_result;\n \n   TF_ASSERT_OK(env->NewWritableFile(fname, &file_writer));\n   ZlibOutputBuffer out(file_writer.get(), input_buf_size, output_buf_size,\n@@ -166,7 +166,7 @@ TEST(ZlibBuffers, MultipleWriteCallsWithFlush) {\n \n TEST(ZlibInputStream, FailsToReadIfWindowBitsAreIncompatible) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   CompressionOptions output_options = CompressionOptions::DEFAULT();\n   CompressionOptions input_options = CompressionOptions::DEFAULT();\n@@ -175,7 +175,7 @@ TEST(ZlibInputStream, FailsToReadIfWindowBitsAreIncompatible) {\n   // inflate() has smaller history buffer.\n   input_options.window_bits = output_options.window_bits - 1;\n \n-  string data = GenTestString(10);\n+  std::string data = GenTestString(10);\n   std::unique_ptr<WritableFile> file_writer;\n   TF_ASSERT_OK(env->NewWritableFile(fname, &file_writer));\n   tstring result;\n@@ -199,10 +199,10 @@ TEST(ZlibInputStream, FailsToReadIfWindowBitsAreIncompatible) {\n   CHECK(absl::StrContains(read_status.message(), \"inflate() failed\"));\n }\n \n-void WriteCompressedFile(Env* env, const string& fname, int input_buf_size,\n+void WriteCompressedFile(Env* env, const std::string& fname, int input_buf_size,\n                          int output_buf_size,\n                          const CompressionOptions& output_options,\n-                         const string& data) {\n+                         const std::string& data) {\n   std::unique_ptr<WritableFile> file_writer;\n   TF_ASSERT_OK(env->NewWritableFile(fname, &file_writer));\n \n@@ -219,10 +219,10 @@ void WriteCompressedFile(Env* env, const string& fname, int input_buf_size,\n void TestTell(CompressionOptions input_options,\n               CompressionOptions output_options) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   for (auto file_size : NumCopies()) {\n-    string data = GenTestString(file_size);\n+    std::string data = GenTestString(file_size);\n     for (auto input_buf_size : InputBufferSizes()) {\n       for (auto output_buf_size : OutputBufferSizes()) {\n         // Write the compressed file.\n@@ -237,7 +237,7 @@ void TestTell(CompressionOptions input_options,\n         ZlibInputStream in(input_stream.get(), input_buf_size, output_buf_size,\n                            input_options);\n \n-        tstring first_half(string(data, 0, data.size() / 2));\n+        tstring first_half(std::string(data, 0, data.size() / 2));\n         tstring bytes_read;\n \n         // Read the first half of the uncompressed file and expect that Tell()\n@@ -264,10 +264,10 @@ void TestTell(CompressionOptions input_options,\n void TestSkipNBytes(CompressionOptions input_options,\n                     CompressionOptions output_options) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n   for (auto file_size : NumCopies()) {\n-    string data = GenTestString(file_size);\n+    std::string data = GenTestString(file_size);\n     for (auto input_buf_size : InputBufferSizes()) {\n       for (auto output_buf_size : OutputBufferSizes()) {\n         // Write the compressed file.\n@@ -283,7 +283,8 @@ void TestSkipNBytes(CompressionOptions input_options,\n                            input_options);\n \n         size_t data_half_size = data.size() / 2;\n-        string second_half(data, data_half_size, data.size() - data_half_size);\n+        std::string second_half(data, data_half_size,\n+                                data.size() - data_half_size);\n \n         // Skip past the first half of the file and expect Tell() returns\n         // correctly.\n@@ -303,7 +304,7 @@ void TestSkipNBytes(CompressionOptions input_options,\n \n void TestSoftErrorOnDecompress(CompressionOptions input_options) {\n   Env* env = Env::Default();\n-  string fname;\n+  std::string fname;\n   ASSERT_TRUE(env->LocalTempFilename(&fname));\n \n   input_options.soft_fail_on_error = true;"
        },
        {
            "sha": "be3ae029bb1b16a5c0a0025d80dd580c7b1b841e",
            "filename": "third_party/xla/xla/tsl/lib/io/zlib_compression_options.h",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_compression_options.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_compression_options.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_compression_options.h?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -30,7 +30,7 @@ class ZlibCompressionOptions {\n   static ZlibCompressionOptions GZIP();\n \n   // Defaults to Z_NO_FLUSH\n-  int8 flush_mode;\n+  int8_t flush_mode;\n \n   // Size of the buffer used for caching the data read from source file.\n   int64_t input_buffer_size = 256 << 10;\n@@ -74,25 +74,25 @@ class ZlibCompressionOptions {\n   // error code Z_DATA_ERROR instead of trying to allocate a larger window.\n   //\n   // Defaults to MAX_WBITS\n-  int8 window_bits;\n+  int8_t window_bits;\n \n   // From the zlib manual (http://www.zlib.net/manual.html):\n   // The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:\n   // 1 gives best speed, 9 gives best compression, 0 gives no compression at all\n   // (the input data is simply copied a block at a time). Z_DEFAULT_COMPRESSION\n   // requests a default compromise between speed and compression (currently\n   // equivalent to level 6).\n-  int8 compression_level;\n+  int8_t compression_level;\n \n   // Only Z_DEFLATED is supported at this time.\n-  int8 compression_method;\n+  int8_t compression_method;\n \n   // From the zlib manual (http://www.zlib.net/manual.html):\n   // The mem_level parameter specifies how much memory should be allocated for\n   // the internal compression state. mem_level=1 uses minimum memory but is slow\n   // and reduces compression ratio; mem_level=9 uses maximum memory for optimal\n   // speed. The default value is 8.\n-  int8 mem_level = 9;\n+  int8_t mem_level = 9;\n \n   // From the zlib manual (http://www.zlib.net/manual.html):\n   // The strategy parameter is used to tune the compression algorithm. Use the\n@@ -109,7 +109,7 @@ class ZlibCompressionOptions {\n   // but not the correctness of the compressed output even if it is not set\n   // appropriately. Z_FIXED prevents the use of dynamic Huffman codes, allowing\n   // for a simpler decoder for special applications.\n-  int8 compression_strategy;\n+  int8_t compression_strategy;\n \n   // When this is set to true and we are unable to find the header to correctly\n   // decompress a file, we return an error when `ReadNBytes` is called instead"
        },
        {
            "sha": "31dd50b54100c5766434e6ba3c69880911671ba7",
            "filename": "third_party/xla/xla/tsl/lib/io/zlib_inputstream.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_inputstream.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_inputstream.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_inputstream.cc?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -250,7 +250,8 @@ absl::Status ZlibInputStream::Inflate() {\n   // not fatal and `inflate` can be called again with more input and output\n   // space to continue inflating.\n   if (error != Z_OK && error != Z_STREAM_END && error != Z_BUF_ERROR) {\n-    string error_string = absl::StrCat(\"inflate() failed with error \", error);\n+    std::string error_string =\n+        absl::StrCat(\"inflate() failed with error \", error);\n     if (z_stream_def_->stream->msg != nullptr) {\n       absl::StrAppend(&error_string, \": \", z_stream_def_->stream->msg);\n     }"
        },
        {
            "sha": "f30b125b30738d7d6f62e85595c4fb8a43b55177",
            "filename": "third_party/xla/xla/tsl/lib/io/zlib_outputbuffer.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_outputbuffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_outputbuffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_outputbuffer.cc?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -68,7 +68,7 @@ absl::Status ZlibOutputBuffer::Init() {\n   return absl::OkStatus();\n }\n \n-int32 ZlibOutputBuffer::AvailableInputSpace() const {\n+int32_t ZlibOutputBuffer::AvailableInputSpace() const {\n   return input_buffer_capacity_ - z_stream_->avail_in;\n }\n \n@@ -130,7 +130,7 @@ absl::Status ZlibOutputBuffer::DeflateBuffered(int flush_mode) {\n }\n \n absl::Status ZlibOutputBuffer::FlushOutputBufferToFile() {\n-  uint32 bytes_to_write = output_buffer_capacity_ - z_stream_->avail_out;\n+  uint32_t bytes_to_write = output_buffer_capacity_ - z_stream_->avail_out;\n   if (bytes_to_write > 0) {\n     absl::Status s = file_->Append(absl::string_view(\n         reinterpret_cast<char*>(z_stream_output_.get()), bytes_to_write));\n@@ -231,7 +231,8 @@ absl::Status ZlibOutputBuffer::Deflate(int flush) {\n       (error == Z_STREAM_END && flush == Z_FINISH)) {\n     return absl::OkStatus();\n   }\n-  string error_string = absl::StrCat(\"deflate() failed with error \", error);\n+  std::string error_string =\n+      absl::StrCat(\"deflate() failed with error \", error);\n   if (z_stream_->msg != nullptr) {\n     absl::StrAppend(&error_string, \": \", z_stream_->msg);\n   }"
        },
        {
            "sha": "6a20456e2cb5b85d840b10384be7156579223fbf",
            "filename": "third_party/xla/xla/tsl/lib/io/zlib_outputbuffer.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_outputbuffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/d3478df12513c38f31d3ad70b40ba376f1297a1c/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_outputbuffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Flib%2Fio%2Fzlib_outputbuffer.h?ref=d3478df12513c38f31d3ad70b40ba376f1297a1c",
            "patch": "@@ -126,7 +126,7 @@ class ZlibOutputBuffer : public WritableFile {\n   void AddToInputBuffer(absl::string_view data);\n \n   // Returns the total space available in z_input_stream_ buffer.\n-  int32 AvailableInputSpace() const;\n+  int32_t AvailableInputSpace() const;\n \n   // Deflate contents in z_stream_input_ and store results in z_stream_output_.\n   // The contents of output stream are written to file if more space is needed.\n@@ -145,7 +145,7 @@ class ZlibOutputBuffer : public WritableFile {\n   // Calls `deflate()` and returns DataLoss Status if it failed.\n   absl::Status Deflate(int flush);\n \n-  static bool IsSyncOrFullFlush(uint8 flush_mode) {\n+  static bool IsSyncOrFullFlush(uint8_t flush_mode) {\n     return flush_mode == Z_SYNC_FLUSH || flush_mode == Z_FULL_FLUSH;\n   }\n "
        }
    ],
    "stats": {
        "total": 217,
        "additions": 111,
        "deletions": 106
    }
}