{
    "author": "apivovarov",
    "message": "Refactor client_library_test_base.cc\n\nChanges:\n- Update includes\n- Remove a redundant `else` block\n- Switch from `std::transform` to `absl::c_transform` for better readability.\n- Add PrepareArguments method.\n- Add PrepareExpectedLiteralAndShape method.\n- Refactor `ComputeAndCompareLiteralWithStatus` to reduce cognitive complexity and improve readability.\nPiperOrigin-RevId: 837214268",
    "sha": "2586544eb79be9d856011640558c56036ae2374c",
    "files": [
        {
            "sha": "15afb44badcdd804487c7516a11e5efa291705f0",
            "filename": "third_party/xla/xla/literal_util.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2586544eb79be9d856011640558c56036ae2374c/third_party%2Fxla%2Fxla%2Fliteral_util.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2586544eb79be9d856011640558c56036ae2374c/third_party%2Fxla%2Fxla%2Fliteral_util.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fliteral_util.h?ref=2586544eb79be9d856011640558c56036ae2374c",
            "patch": "@@ -19,6 +19,7 @@ limitations under the License.\n #define XLA_LITERAL_UTIL_H_\n \n #include <array>\n+#include <cmath>\n #include <cstdint>\n #include <initializer_list>\n #include <iterator>\n@@ -40,6 +41,7 @@ limitations under the License.\n #include \"xla/layout.h\"\n #include \"xla/layout_util.h\"\n #include \"xla/literal.h\"\n+#include \"xla/literal_util.h\"\n #include \"xla/primitive_util.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\""
        },
        {
            "sha": "f18efd98e2b8891b67c4dcb139be3fb140c9c1fb",
            "filename": "third_party/xla/xla/tests/BUILD",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2586544eb79be9d856011640558c56036ae2374c/third_party%2Fxla%2Fxla%2Ftests%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2586544eb79be9d856011640558c56036ae2374c/third_party%2Fxla%2Fxla%2Ftests%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftests%2FBUILD?ref=2586544eb79be9d856011640558c56036ae2374c",
            "patch": "@@ -310,7 +310,7 @@ cc_library(\n     deps = [\n         \":client_library_test_runner_utils\",\n         \":literal_test_util\",\n-        \":test_utils\",\n+        \"//xla:array\",\n         \"//xla:array2d\",\n         \"//xla:array3d\",\n         \"//xla:array4d\",\n@@ -330,19 +330,17 @@ cc_library(\n         \"//xla/service:interpreter_plugin\",  # reference backend\n         \"//xla/service:platform_util\",\n         \"//xla/stream_executor:platform\",\n-        \"//xla/stream_executor:stream_executor_h\",\n         \"//xla/tsl/lib/core:bitmap\",\n         \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest_for_library\",\n-        \"@local_tsl//tsl/platform:ml_dtypes\",\n-        \"@local_tsl//tsl/platform:test\",\n     ],\n     alwayslink = True,  # This library registers test cases at static initialization time.\n )\n@@ -2522,19 +2520,22 @@ xla_test(\n     ],\n     deps = [\n         \":client_library_test_base\",\n+        \":literal_test_util\",\n         \":xla_internal_test_main\",\n         \"//xla:literal\",\n+        \"//xla:literal_util\",\n         \"//xla:shape_util\",\n-        \"//xla:util\",\n+        \"//xla:types\",\n         \"//xla:xla_data_proto_cc\",\n         \"//xla/client:local_client\",\n         \"//xla/hlo/builder:xla_builder\",\n         \"//xla/hlo/testlib:test\",\n+        \"//xla/service\",\n         \"//xla/tests:xla_test_backend_predicates\",\n+        \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/log\",\n         \"@com_google_absl//absl/types:span\",\n         \"@eigen_archive//:eigen3\",\n-        \"@local_tsl//tsl/platform:protobuf\",\n-        \"@local_tsl//tsl/platform:test\",\n     ],\n )\n "
        },
        {
            "sha": "44385f7015b345ac0b73c176d30521be9f7390fa",
            "filename": "third_party/xla/xla/tests/client_library_test_base.cc",
            "status": "modified",
            "additions": 49,
            "deletions": 29,
            "changes": 78,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2586544eb79be9d856011640558c56036ae2374c/third_party%2Fxla%2Fxla%2Ftests%2Fclient_library_test_base.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2586544eb79be9d856011640558c56036ae2374c/third_party%2Fxla%2Fxla%2Ftests%2Fclient_library_test_base.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftests%2Fclient_library_test_base.cc?ref=2586544eb79be9d856011640558c56036ae2374c",
            "patch": "@@ -28,6 +28,7 @@ limitations under the License.\n #include <vector>\n \n #include <gtest/gtest.h>\n+#include \"absl/algorithm/container.h\"\n #include \"absl/log/check.h\"\n #include \"absl/log/log.h\"\n #include \"absl/status/status.h\"\n@@ -182,9 +183,8 @@ std::string ClientLibraryTestBase::ExecuteToString(\n       client_->ExecuteAndTransfer(computation, arguments, &execution_options_);\n   if (!result.ok()) {\n     return result.status().ToString();\n-  } else {\n-    return result.value().ToString();\n   }\n+  return result.value().ToString();\n }\n \n void ClientLibraryTestBase::ComputeAndCompareR1(\n@@ -322,15 +322,14 @@ absl::StatusOr<Literal> ClientLibraryTestBase::ComputeAndTransfer(\n   return ExecuteAndTransfer(computation, arguments, shape_with_layout);\n }\n \n-absl::Status ClientLibraryTestBase::ComputeAndCompareLiteralWithStatus(\n-    XlaBuilder* builder, const Literal& expected,\n+absl::StatusOr<std::vector<GlobalData*>>\n+ClientLibraryTestBase::PrepareArguments(\n     absl::Span<GlobalData* const> arguments_passed_in,\n-    std::optional<ErrorSpec> error, const Shape* shape_with_layout) {\n+    std::vector<std::unique_ptr<GlobalData>>& owning_arguments) {\n   std::vector<GlobalData*> arguments(arguments_passed_in.begin(),\n                                      arguments_passed_in.end());\n \n-  // Transfer and use elements of arguments_, if the AddParam() API was used.\n-  std::vector<std::unique_ptr<GlobalData>> owning_arguments;\n+  // If AddParam() API was used, transfer and use elements of arguments_.\n   if (!arguments_.empty()) {\n     CHECK(arguments.empty());\n     for (const auto& argument : arguments_) {\n@@ -341,6 +340,37 @@ absl::Status ClientLibraryTestBase::ComputeAndCompareLiteralWithStatus(\n       arguments.push_back(owning_arguments.back().get());\n     }\n   }\n+  return arguments;\n+}\n+\n+ClientLibraryTestBase::LiteralWithShape\n+ClientLibraryTestBase::PrepareExpectedLiteralAndShape(\n+    const Literal& expected, const Shape* shape_with_layout) {\n+  ClientLibraryTestBase::LiteralWithShape out;\n+  if (test_type_ != F32) {\n+    // Convert literal\n+    out.literal = MaybeConvertLiteralToTestType(expected);\n+    // Convert shape\n+    if (shape_with_layout != nullptr) {\n+      out.shape = *shape_with_layout;\n+      ShapeUtil::ForEachMutableSubshape(\n+          &out.shape.value(), [&](Shape* subshape, const ShapeIndex&) {\n+            if (subshape->element_type() == F32) {\n+              subshape->set_element_type(test_type_);\n+            }\n+          });\n+    }\n+  }\n+  return out;\n+}\n+\n+absl::Status ClientLibraryTestBase::ComputeAndCompareLiteralWithStatus(\n+    XlaBuilder* builder, const Literal& expected,\n+    absl::Span<GlobalData* const> arguments_passed_in,\n+    std::optional<ErrorSpec> error, const Shape* shape_with_layout) {\n+  std::vector<std::unique_ptr<GlobalData>> owning_arguments;\n+  TF_ASSIGN_OR_RETURN(std::vector<GlobalData*> arguments,\n+                      PrepareArguments(arguments_passed_in, owning_arguments));\n \n   TF_ASSIGN_OR_RETURN(auto computation, builder->Build());\n   if (error == std::nullopt) {\n@@ -351,23 +381,15 @@ absl::Status ClientLibraryTestBase::ComputeAndCompareLiteralWithStatus(\n   }\n   // We allow using a float expected literal for a non float outputs. In this\n   // case, we need to convert the expected literal to test_type_.\n-  const Literal* expected_ptr = &expected;\n-  Literal converted_expected;\n-  Shape layout_shape;\n-  if (test_type_ != F32) {\n-    converted_expected = MaybeConvertLiteralToTestType(expected);\n-    expected_ptr = &converted_expected;\n-    if (shape_with_layout != nullptr) {\n-      layout_shape = *shape_with_layout;\n-      ShapeUtil::ForEachMutableSubshape(\n-          &layout_shape, [&](Shape* subshape, const ShapeIndex& /*index*/) {\n-            if (subshape->element_type() == F32) {\n-              subshape->set_element_type(test_type_);\n-            }\n-          });\n-      shape_with_layout = &layout_shape;\n-    }\n+  LiteralWithShape expected_converted =\n+      PrepareExpectedLiteralAndShape(expected, shape_with_layout);\n+  const Literal* expected_ptr = expected_converted.literal.has_value()\n+                                    ? &expected_converted.literal.value()\n+                                    : &expected;\n+  if (expected_converted.shape.has_value()) {\n+    shape_with_layout = &expected_converted.shape.value();\n   }\n+\n   auto expect = [&](const Literal& actual, const std::string& error_message) {\n     if (error) {\n       EXPECT_TRUE(LiteralTestUtil::Near(*expected_ptr, actual, *error))\n@@ -472,14 +494,12 @@ ClientLibraryTestBase::ComputeValueAndReference(\n \n   // Create raw pointers to the GlobalData for the rest of the call stack.\n   std::vector<GlobalData*> argument_data_ptr;\n-  std::transform(\n-      argument_data.begin(), argument_data.end(),\n-      std::back_inserter(argument_data_ptr),\n+  absl::c_transform(\n+      argument_data, std::back_inserter(argument_data_ptr),\n       [](const std::unique_ptr<GlobalData>& data) { return data.get(); });\n   std::vector<GlobalData*> ref_argument_data_ptr;\n-  std::transform(\n-      ref_argument_data.begin(), ref_argument_data.end(),\n-      std::back_inserter(ref_argument_data_ptr),\n+  absl::c_transform(\n+      ref_argument_data, std::back_inserter(ref_argument_data_ptr),\n       [](const std::unique_ptr<GlobalData>& data) { return data.get(); });\n \n   TF_ASSIGN_OR_RETURN(auto computation, builder->Build());"
        },
        {
            "sha": "a33e4d0237eba581bb6a94446d918de9c5f3a953",
            "filename": "third_party/xla/xla/tests/client_library_test_base.h",
            "status": "modified",
            "additions": 35,
            "deletions": 12,
            "changes": 47,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2586544eb79be9d856011640558c56036ae2374c/third_party%2Fxla%2Fxla%2Ftests%2Fclient_library_test_base.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2586544eb79be9d856011640558c56036ae2374c/third_party%2Fxla%2Fxla%2Ftests%2Fclient_library_test_base.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftests%2Fclient_library_test_base.h?ref=2586544eb79be9d856011640558c56036ae2374c",
            "patch": "@@ -22,6 +22,19 @@ limitations under the License.\n // This macro helps to ensure that migration test base classes are not used in\n // conjunction with ClientLibraryTestBase.\n // TODO: b/408276009 - Remove these macros once all tests have been migrated.\n+#include <functional>\n+#include <optional>\n+#include <utility>\n+\n+#include <gtest/gtest.h>\n+#include \"absl/log/check.h\"\n+#include \"absl/status/status.h\"\n+#include \"xla/array.h\"\n+#include \"xla/client/local_client.h\"\n+#include \"xla/error_spec.h\"\n+#include \"xla/service/service.h\"\n+#include \"xla/shape.h\"\n+#include \"xla/stream_executor/platform.h\"\n #define XLA_TEST_NOT_MIGRATED_TO_HLO_RUNNER_PJRT\n #ifdef XLA_TEST_MIGRATED_TO_HLO_RUNNER_PJRT\n static_assert(false,\n@@ -46,15 +59,10 @@ static_assert(false,\n #include \"xla/hlo/builder/xla_computation.h\"\n #include \"xla/literal.h\"\n #include \"xla/literal_util.h\"\n-#include \"xla/stream_executor/stream_executor.h\"\n #include \"xla/tests/client_library_test_runner_utils.h\"\n-#include \"xla/tests/literal_test_util.h\"\n-#include \"xla/tests/test_utils.h\"\n #include \"xla/tsl/lib/core/bitmap.h\"\n #include \"xla/types.h\"\n #include \"xla/xla_data.pb.h\"\n-#include \"tsl/platform/ml_dtypes.h\"\n-#include \"tsl/platform/test.h\"\n \n namespace xla {\n \n@@ -215,11 +223,10 @@ class ClientLibraryTestBase : public ::testing::Test {\n   // Creates an array of pseudorandom values lying between the given minimum and\n   // maximum values.\n   template <typename NativeT>\n-  std::vector<NativeT> CreatePseudorandomR1(const int width, NativeT min_value,\n+  std::vector<NativeT> CreatePseudorandomR1(int width, NativeT min_value,\n                                             NativeT max_value, uint32_t seed);\n   template <typename NativeT>\n-  std::unique_ptr<Array2D<NativeT>> CreatePseudorandomR2(const int rows,\n-                                                         const int cols,\n+  std::unique_ptr<Array2D<NativeT>> CreatePseudorandomR2(int rows, int cols,\n                                                          NativeT min_value,\n                                                          NativeT max_value,\n                                                          uint32_t seed);\n@@ -233,16 +240,14 @@ class ClientLibraryTestBase : public ::testing::Test {\n   //\n   // If provided, offset is added uniformly to every element (e.g. an offset of\n   // 64 would cause 0 in the above to be 64, 1 to be 65, 1000 to be 1064, etc.)\n-  std::unique_ptr<Array2D<float>> CreatePatternedMatrix(const int rows,\n-                                                        const int cols,\n+  std::unique_ptr<Array2D<float>> CreatePatternedMatrix(int rows, int cols,\n                                                         float offset = 0.0);\n \n   // Creates a (rows x cols) array as above, padded out to\n   // (rows_padded x cols_padded) with zeroes.  Requires rows_padded >= rows\n   // and cols_padded > cols.\n   std::unique_ptr<Array2D<float>> CreatePatternedMatrixWithZeroPadding(\n-      const int rows, const int cols, const int rows_padded,\n-      const int cols_padded);\n+      int rows, int cols, int rows_padded, int cols_padded);\n \n   // Creates a parameter instruction, transfers the literal for the parameter to\n   // server, then stores into \"data_handle\" the global handle for that\n@@ -413,6 +418,24 @@ class ClientLibraryTestBase : public ::testing::Test {\n   // Converts an f32 shape to test_type_.\n   Shape MaybeConvertShapeToTestType(const Shape& shape);\n \n+  // Helper function to prepare arguments, moving transfer logic out of the main\n+  // function.\n+  absl::StatusOr<std::vector<GlobalData*>> PrepareArguments(\n+      absl::Span<GlobalData* const> arguments_passed_in,\n+      std::vector<std::unique_ptr<GlobalData>>& owning_arguments);\n+\n+  struct LiteralWithShape {\n+    std::optional<Literal> literal;\n+    std::optional<Shape> shape;\n+  };\n+\n+  // Converts the expected literal and the shape with layout to test_type_.\n+  // If the test_type_ is not F32, the expected literal will be converted to\n+  // test_type_. If the shape_with_layout is not nullptr and the test_type_ is\n+  // not F32, the shape_with_layout will be converted to test_type_.\n+  LiteralWithShape PrepareExpectedLiteralAndShape(\n+      const Literal& expected, const Shape* shape_with_layout);\n+\n   // Type to use when running tests. By default, we use F32 for historical\n   // reasons and we rely on the underlying tests to change it.\n   PrimitiveType test_type_ = F32;"
        },
        {
            "sha": "7e390a4b80b71b4d97131c9609a13b9251cba4df",
            "filename": "third_party/xla/xla/tests/prng_test.cc",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/2586544eb79be9d856011640558c56036ae2374c/third_party%2Fxla%2Fxla%2Ftests%2Fprng_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/2586544eb79be9d856011640558c56036ae2374c/third_party%2Fxla%2Fxla%2Ftests%2Fprng_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftests%2Fprng_test.cc?ref=2586544eb79be9d856011640558c56036ae2374c",
            "patch": "@@ -15,7 +15,6 @@ limitations under the License.\n \n #include <array>\n #include <cmath>\n-#include <cstddef>\n #include <cstdint>\n #include <limits>\n #include <memory>\n@@ -24,19 +23,23 @@ limitations under the License.\n #include <vector>\n \n #include \"xla/tests/xla_test_backend_predicates.h\"\n+#include \"absl/log/log.h\"\n #include \"absl/types/span.h\"\n+#include \"Eigen/Core\"\n #include \"unsupported/Eigen/SpecialFunctions\"\n #include \"xla/client/local_client.h\"\n #include \"xla/hlo/builder/xla_builder.h\"\n #include \"xla/hlo/testlib/test.h\"\n #include \"xla/literal.h\"\n+#include \"xla/literal_util.h\"\n #include \"xla/primitive_util.h\"\n+#include \"xla/service/service.h\"\n #include \"xla/shape_util.h\"\n #include \"xla/tests/client_library_test_base.h\"\n-#include \"xla/util.h\"\n+#include \"xla/tests/literal_test_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n+#include \"xla/types.h\"\n #include \"xla/xla_data.pb.h\"\n-#include \"tsl/platform/protobuf.h\"\n-#include \"tsl/platform/test.h\"\n \n namespace xla {\n namespace {"
        }
    ],
    "stats": {
        "total": 153,
        "additions": 101,
        "deletions": 52
    }
}