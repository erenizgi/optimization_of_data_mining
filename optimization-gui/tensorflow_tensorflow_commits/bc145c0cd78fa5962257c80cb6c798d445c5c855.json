{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 847188284",
    "sha": "bc145c0cd78fa5962257c80cb6c798d445c5c855",
    "files": [
        {
            "sha": "5edbfd28bdccbf59a59dbfb868ad928614ee8638",
            "filename": "tensorflow/core/lib/wav/wav_io.cc",
            "status": "modified",
            "additions": 37,
            "deletions": 32,
            "changes": 69,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bc145c0cd78fa5962257c80cb6c798d445c5c855/tensorflow%2Fcore%2Flib%2Fwav%2Fwav_io.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bc145c0cd78fa5962257c80cb6c798d445c5c855/tensorflow%2Fcore%2Flib%2Fwav%2Fwav_io.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Flib%2Fwav%2Fwav_io.cc?ref=bc145c0cd78fa5962257c80cb6c798d445c5c855",
            "patch": "@@ -73,7 +73,7 @@ constexpr char kRiffType[] = \"WAVE\";\n constexpr char kFormatChunkId[] = \"fmt \";\n constexpr char kDataChunkId[] = \"data\";\n \n-inline int16 FloatToInt16Sample(float data) {\n+inline int16_t FloatToInt16Sample(float data) {\n   constexpr float kMultiplier = 1.0f * (1 << 15);\n   return std::min<float>(std::max<float>(roundf(data * kMultiplier),\n                                          std::numeric_limits<int16_t>::min()),\n@@ -212,7 +212,7 @@ absl::Status EncodeAudioAsS16LEWav(const float* audio, size_t sample_rate,\n   for (size_t i = 0; i < num_samples; ++i) {\n     int16_t sample = FloatToInt16Sample(audio[i]);\n     core::EncodeFixed16(&data[i * kBytesPerSample],\n-                        static_cast<uint16>(sample));\n+                        static_cast<uint16_t>(sample));\n   }\n   return absl::OkStatus();\n }\n@@ -230,13 +230,14 @@ template Status EncodeAudioAsS16LEWav<tstring>(const float* audio,\n \n absl::Status DecodeLin16WaveAsFloatVector(const std::string& wav_string,\n                                           std::vector<float>* float_values,\n-                                          uint32* sample_count,\n-                                          uint16* channel_count,\n-                                          uint32* sample_rate) {\n+                                          uint32_t* sample_count,\n+                                          uint16_t* channel_count,\n+                                          uint32_t* sample_rate) {\n   int offset = 0;\n   TF_RETURN_IF_ERROR(ExpectText(wav_string, kRiffChunkId, &offset));\n-  uint32 total_file_size;\n-  TF_RETURN_IF_ERROR(ReadValue<uint32>(wav_string, &total_file_size, &offset));\n+  uint32_t total_file_size;\n+  TF_RETURN_IF_ERROR(\n+      ReadValue<uint32_t>(wav_string, &total_file_size, &offset));\n   TF_RETURN_IF_ERROR(ExpectText(wav_string, kRiffType, &offset));\n   std::string found_text;\n   TF_RETURN_IF_ERROR(ReadString(wav_string, 4, &found_text, &offset));\n@@ -252,57 +253,61 @@ absl::Status DecodeLin16WaveAsFloatVector(const std::string& wav_string,\n         found_text != \"link\" && found_text != \"axml\") {\n       return errors::InvalidArgument(\"Unexpected field \", found_text);\n     }\n-    uint32 size_of_chunk;\n-    TF_RETURN_IF_ERROR(ReadValue<uint32>(wav_string, &size_of_chunk, &offset));\n+    uint32_t size_of_chunk;\n+    TF_RETURN_IF_ERROR(\n+        ReadValue<uint32_t>(wav_string, &size_of_chunk, &offset));\n     TF_RETURN_IF_ERROR(\n         IncrementOffset(offset, size_of_chunk, wav_string.size(), &offset));\n     TF_RETURN_IF_ERROR(ReadString(wav_string, 4, &found_text, &offset));\n   }\n-  uint32 format_chunk_size;\n+  uint32_t format_chunk_size;\n   TF_RETURN_IF_ERROR(\n-      ReadValue<uint32>(wav_string, &format_chunk_size, &offset));\n+      ReadValue<uint32_t>(wav_string, &format_chunk_size, &offset));\n   if ((format_chunk_size != 16) && (format_chunk_size != 18)) {\n     return errors::InvalidArgument(\n         \"Bad format chunk size for WAV: Expected 16 or 18, but got\",\n         format_chunk_size);\n   }\n-  uint16 audio_format;\n-  TF_RETURN_IF_ERROR(ReadValue<uint16>(wav_string, &audio_format, &offset));\n+  uint16_t audio_format;\n+  TF_RETURN_IF_ERROR(ReadValue<uint16_t>(wav_string, &audio_format, &offset));\n   if (audio_format != 1) {\n     return errors::InvalidArgument(\n         \"Bad audio format for WAV: Expected 1 (PCM), but got\", audio_format);\n   }\n-  TF_RETURN_IF_ERROR(ReadValue<uint16>(wav_string, channel_count, &offset));\n+  TF_RETURN_IF_ERROR(ReadValue<uint16_t>(wav_string, channel_count, &offset));\n   if (*channel_count < 1) {\n     return errors::InvalidArgument(\n         \"Bad number of channels for WAV: Expected at least 1, but got \",\n         *channel_count);\n   }\n-  TF_RETURN_IF_ERROR(ReadValue<uint32>(wav_string, sample_rate, &offset));\n-  uint32 bytes_per_second;\n-  TF_RETURN_IF_ERROR(ReadValue<uint32>(wav_string, &bytes_per_second, &offset));\n-  uint16 bytes_per_sample;\n-  TF_RETURN_IF_ERROR(ReadValue<uint16>(wav_string, &bytes_per_sample, &offset));\n+  TF_RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, sample_rate, &offset));\n+  uint32_t bytes_per_second;\n+  TF_RETURN_IF_ERROR(\n+      ReadValue<uint32_t>(wav_string, &bytes_per_second, &offset));\n+  uint16_t bytes_per_sample;\n+  TF_RETURN_IF_ERROR(\n+      ReadValue<uint16_t>(wav_string, &bytes_per_sample, &offset));\n   // Confusingly, bits per sample is defined as holding the number of bits for\n   // one channel, unlike the definition of sample used elsewhere in the WAV\n   // spec. For example, bytes per sample is the memory needed for all channels\n   // for one point in time.\n-  uint16 bits_per_sample;\n-  TF_RETURN_IF_ERROR(ReadValue<uint16>(wav_string, &bits_per_sample, &offset));\n+  uint16_t bits_per_sample;\n+  TF_RETURN_IF_ERROR(\n+      ReadValue<uint16_t>(wav_string, &bits_per_sample, &offset));\n   if (bits_per_sample != 16) {\n     return errors::InvalidArgument(\n         \"Can only read 16-bit WAV files, but received \", bits_per_sample);\n   }\n-  const uint32 expected_bytes_per_sample =\n+  const uint32_t expected_bytes_per_sample =\n       ((bits_per_sample * *channel_count) + 7) / 8;\n   if (bytes_per_sample != expected_bytes_per_sample) {\n     return errors::InvalidArgument(\n         \"Bad bytes per sample in WAV header: Expected \",\n         expected_bytes_per_sample, \" but got \", bytes_per_sample);\n   }\n-  const uint64 expected_bytes_per_second =\n-      static_cast<uint64>(bytes_per_sample) * *sample_rate;\n-  if (static_cast<uint64>(bytes_per_second) != expected_bytes_per_second) {\n+  const uint64_t expected_bytes_per_second =\n+      static_cast<uint64_t>(bytes_per_sample) * *sample_rate;\n+  if (static_cast<uint64_t>(bytes_per_second) != expected_bytes_per_second) {\n     return errors::InvalidArgument(\n         \"Bad bytes per second in WAV header: Expected \",\n         expected_bytes_per_second, \" but got \", bytes_per_second,\n@@ -318,31 +323,31 @@ absl::Status DecodeLin16WaveAsFloatVector(const std::string& wav_string,\n   while (offset < wav_string.size()) {\n     std::string chunk_id;\n     TF_RETURN_IF_ERROR(ReadString(wav_string, 4, &chunk_id, &offset));\n-    uint32 chunk_size;\n-    TF_RETURN_IF_ERROR(ReadValue<uint32>(wav_string, &chunk_size, &offset));\n-    if (chunk_size > std::numeric_limits<int32>::max()) {\n+    uint32_t chunk_size;\n+    TF_RETURN_IF_ERROR(ReadValue<uint32_t>(wav_string, &chunk_size, &offset));\n+    if (chunk_size > std::numeric_limits<int32_t>::max()) {\n       return errors::InvalidArgument(\n           \"WAV data chunk '\", chunk_id, \"' is too large: \", chunk_size,\n-          \" bytes, but the limit is \", std::numeric_limits<int32>::max());\n+          \" bytes, but the limit is \", std::numeric_limits<int32_t>::max());\n     }\n     if (chunk_id == kDataChunkId) {\n       if (was_data_found) {\n         return errors::InvalidArgument(\"More than one data chunk found in WAV\");\n       }\n       was_data_found = true;\n       *sample_count = chunk_size / bytes_per_sample;\n-      const uint32 data_count = *sample_count * *channel_count;\n+      const uint32_t data_count = *sample_count * *channel_count;\n       int unused_new_offset = 0;\n       // Validate that the data exists before allocating space for it\n       // (prevent easy OOM errors).\n-      TF_RETURN_IF_ERROR(IncrementOffset(offset, sizeof(int16) * data_count,\n+      TF_RETURN_IF_ERROR(IncrementOffset(offset, sizeof(int16_t) * data_count,\n                                          wav_string.size(),\n                                          &unused_new_offset));\n       float_values->resize(data_count);\n       for (int i = 0; i < data_count; ++i) {\n         int16_t single_channel_value = 0;\n         TF_RETURN_IF_ERROR(\n-            ReadValue<int16>(wav_string, &single_channel_value, &offset));\n+            ReadValue<int16_t>(wav_string, &single_channel_value, &offset));\n         (*float_values)[i] = Int16SampleToFloat(single_channel_value);\n       }\n     } else {"
        }
    ],
    "stats": {
        "total": 69,
        "additions": 37,
        "deletions": 32
    }
}