{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 845598430",
    "sha": "3ed66e80c401cdfb40b229644192880048aad9ad",
    "files": [
        {
            "sha": "ed7ff78c77da57abc2d6744edaf081fe081dd834",
            "filename": "tensorflow/core/tpu/ops/sparse_core_preprocess_ops.cc",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/3ed66e80c401cdfb40b229644192880048aad9ad/tensorflow%2Fcore%2Ftpu%2Fops%2Fsparse_core_preprocess_ops.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/3ed66e80c401cdfb40b229644192880048aad9ad/tensorflow%2Fcore%2Ftpu%2Fops%2Fsparse_core_preprocess_ops.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Ftpu%2Fops%2Fsparse_core_preprocess_ops.cc?ref=3ed66e80c401cdfb40b229644192880048aad9ad",
            "patch": "@@ -73,22 +73,22 @@ REGISTER_OP(\"GetMinibatchesInCsrWithPhysicalReplica\")\n       for (int i = 0; i < c->num_inputs(); ++i) {\n         TF_RETURN_IF_ERROR(c->WithRank(c->input(i), 1, &rank));\n       }\n-      int32 max_minibatches_per_sc;\n+      int32_t max_minibatches_per_sc;\n       TF_RETURN_IF_ERROR(\n           c->GetAttr(\"max_minibatches_per_sc\", &max_minibatches_per_sc));\n-      int32 num_replica;\n+      int32_t num_replica;\n       TF_RETURN_IF_ERROR(c->GetAttr(\"num_replica\", &num_replica));\n-      int32 sample_count;\n+      int32_t sample_count;\n       TF_RETURN_IF_ERROR(c->GetAttr(\"sample_count\", &sample_count));\n-      int32 max_ids_per_chip_per_sample;\n+      int32_t max_ids_per_chip_per_sample;\n       TF_RETURN_IF_ERROR(c->GetAttr(\"max_ids_per_chip_per_sample\",\n                                     &max_ids_per_chip_per_sample));\n \n       // We can't get this number programmatically since the shape inference\n       // will be run as part of the graph generation which might not have the\n       // tpu system available.\n       const int xla_pad_size = 8;\n-      int32 num_sc_per_chip;\n+      int32_t num_sc_per_chip;\n       TF_RETURN_IF_ERROR(c->GetAttr(\"num_sc_per_chip\", &num_sc_per_chip));\n \n       const int num_physical_replica = num_replica * num_sc_per_chip;\n@@ -253,22 +253,22 @@ REGISTER_OP(\"ConvertToSparseCoreCsrWrappedCooTensor\")\n     .Attr(\"table_name: string\")\n     .Attr(\"allow_id_dropping: bool\")\n     .SetShapeFn([](shape_inference::InferenceContext* c) {\n-      int32 max_minibatches_per_sc;\n+      int32_t max_minibatches_per_sc;\n       TF_RETURN_IF_ERROR(\n           c->GetAttr(\"max_minibatches_per_sc\", &max_minibatches_per_sc));\n-      int32 num_replica;\n+      int32_t num_replica;\n       TF_RETURN_IF_ERROR(c->GetAttr(\"num_replica\", &num_replica));\n-      int32 sample_count_per_sc;\n+      int32_t sample_count_per_sc;\n       TF_RETURN_IF_ERROR(\n           c->GetAttr(\"sample_count_per_sc\", &sample_count_per_sc));\n-      int32 max_ids_per_chip_per_sample;\n+      int32_t max_ids_per_chip_per_sample;\n       TF_RETURN_IF_ERROR(c->GetAttr(\"max_ids_per_chip_per_sample\",\n                                     &max_ids_per_chip_per_sample));\n       // We can't get this number programmatically since the shape inference\n       // will be run as part of the graph generation which might not have the\n       // tpu system available.\n       const int xla_pad_size = 8;\n-      int32 num_sc_per_chip;\n+      int32_t num_sc_per_chip;\n       TF_RETURN_IF_ERROR(c->GetAttr(\"num_sc_per_chip\", &num_sc_per_chip));\n \n       const int num_physical_replica = num_replica * num_sc_per_chip;"
        }
    ],
    "stats": {
        "total": 20,
        "additions": 10,
        "deletions": 10
    }
}