{
    "author": "SandSnip3r",
    "message": "In XLA's HostOffloadLegalize pass, support sinking a copy past a transposing bitcast.\n\nPiperOrigin-RevId: 803686148",
    "sha": "34df173e205f2a64a0654628ca11eca8764675cc",
    "files": [
        {
            "sha": "faa0199cfc73361eb87e0d23c65d16e116179987",
            "filename": "third_party/xla/xla/hlo/transforms/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34df173e205f2a64a0654628ca11eca8764675cc/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34df173e205f2a64a0654628ca11eca8764675cc/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2FBUILD?ref=34df173e205f2a64a0654628ca11eca8764675cc",
            "patch": "@@ -249,6 +249,7 @@ cc_library(\n         \"//xla/service:hlo_value\",\n         \"//xla/service:host_offload_utils\",\n         \"//xla/service:memory_annotations_hdr\",\n+        \"//xla/tsl/platform:statusor\",\n         \"@com_google_absl//absl/algorithm:container\",\n         \"@com_google_absl//absl/container:flat_hash_set\",\n         \"@com_google_absl//absl/container:inlined_vector\","
        },
        {
            "sha": "1efd19941fab0ec3acd565f93ac61dda02baced9",
            "filename": "third_party/xla/xla/hlo/transforms/host_offload_legalize.cc",
            "status": "modified",
            "additions": 195,
            "deletions": 71,
            "changes": 266,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34df173e205f2a64a0654628ca11eca8764675cc/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fhost_offload_legalize.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34df173e205f2a64a0654628ca11eca8764675cc/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fhost_offload_legalize.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fhost_offload_legalize.cc?ref=34df173e205f2a64a0654628ca11eca8764675cc",
            "patch": "@@ -17,9 +17,11 @@ limitations under the License.\n \n #include <array>\n #include <cstdint>\n+#include <iterator>\n #include <memory>\n #include <queue>\n #include <string>\n+#include <utility>\n #include <vector>\n \n #include \"absl/algorithm/container.h\"\n@@ -36,12 +38,14 @@ limitations under the License.\n #include \"xla/hlo/ir/hlo_instruction.h\"\n #include \"xla/hlo/ir/hlo_opcode.h\"\n #include \"xla/layout.h\"\n+#include \"xla/layout_util.h\"\n #include \"xla/service/call_graph.h\"\n #include \"xla/service/hlo_value.h\"\n #include \"xla/service/host_offload_utils.h\"\n #include \"xla/service/memory_annotations.h\"\n #include \"xla/shape.h\"\n #include \"xla/shape_util.h\"\n+#include \"xla/tsl/platform/statusor.h\"\n #include \"xla/util.h\"\n #include \"tsl/platform/errors.h\"\n #include \"tsl/platform/statusor.h\"\n@@ -378,6 +382,183 @@ Shape AddMajormostDimension(const Shape& shape) {\n   return new_shape;\n }\n \n+absl::StatusOr<std::pair<Shape, Shape>> GetNewShapesAfterBitcastReducedRank(\n+    const HloInstruction* bitcast, const HloInstruction* copy_to_move,\n+    const Shape& shape_before_copy, const Shape& shape_after_copy) {\n+  const Shape& before_bitcast_shape = bitcast->operand(0)->shape();\n+  if (!(ShapeUtil::IsEffectivelyMostMajorDimension(before_bitcast_shape, 0) &&\n+        before_bitcast_shape.dimensions(0) == 1)) {\n+    return absl::InternalError(\n+        absl::StrFormat(\"Only handling bitcasts with majormost dimension \"\n+                        \"of size 1. This bitcast is \\\"%s\\\"\",\n+                        bitcast->ToString()));\n+  }\n+  const Shape new_bitcast_shape = RemoveMajormostDimension(shape_before_copy);\n+  VLOG(2) << absl::StreamFormat(\n+      \" Encountered bitcast \\\"%s\\\", updating current shape from %s to \"\n+      \"%s\",\n+      bitcast->name(), shape_before_copy.ToString(true),\n+      new_bitcast_shape.ToString(true));\n+  const Shape new_copy_shape = RemoveMajormostDimension(shape_after_copy);\n+  VLOG(2) << absl::StreamFormat(\" Also updating shape after copy from %s to %s\",\n+                                shape_after_copy.ToString(true),\n+                                new_copy_shape.ToString(true));\n+  return std::make_pair(new_bitcast_shape, new_copy_shape);\n+}\n+\n+absl::StatusOr<std::pair<Shape, Shape>> GetNewShapesAfterBitcastIncreasedRank(\n+    const HloInstruction* bitcast, const HloInstruction* copy_to_move,\n+    const Shape& shape_before_copy, const Shape& shape_after_copy) {\n+  const Shape& after_bitcast_shape = bitcast->shape();\n+  if (!(ShapeUtil::IsEffectivelyMostMajorDimension(after_bitcast_shape, 0) &&\n+        after_bitcast_shape.dimensions(0) == 1)) {\n+    return absl::UnimplementedError(\n+        absl::StrFormat(\"Only handling bitcasts with majormost dimension \"\n+                        \"of size 1. This bitcast is \\\"%s\\\"\",\n+                        bitcast->ToString()));\n+  }\n+  const Shape new_bitcast_shape = AddMajormostDimension(shape_before_copy);\n+  VLOG(2) << absl::StreamFormat(\n+      \" Encountered bitcast \\\"%s\\\", updating current shape from %s to \"\n+      \"%s\",\n+      bitcast->name(), shape_before_copy.ToString(true),\n+      new_bitcast_shape.ToString(true));\n+  const Shape new_copy_shape = AddMajormostDimension(shape_after_copy);\n+  VLOG(2) << absl::StreamFormat(\" Also updating shape after copy from %s to %s\",\n+                                shape_after_copy.ToString(true),\n+                                new_copy_shape.ToString(true));\n+  return std::make_pair(new_bitcast_shape, new_copy_shape);\n+}\n+\n+absl::StatusOr<std::pair<Shape, Shape>> GetNewShapesAfterBitcastSameRank(\n+    const HloInstruction* bitcast, const HloInstruction* copy_to_move,\n+    const Shape& shape_before_copy, const Shape& shape_after_copy) {\n+  const Shape& before_bitcast_shape = bitcast->operand(0)->shape();\n+  const Shape& after_bitcast_shape = bitcast->shape();\n+\n+  // Maybe is a transposing bitcast.\n+  if (!Shape::Equal().IgnoreLayout()(after_bitcast_shape,\n+                                     before_bitcast_shape)) {\n+    // Something about the shape other than the layout changes. This is not\n+    // supported.\n+    return absl::UnimplementedError(absl::StrFormat(\n+        \"Only handling bitcasts which change the layout. This bitcast (\\\"%s\\\") \"\n+        \"has input shape \\\"%s\\\" and output shape \\\"%s\\\".\",\n+        bitcast->name(),\n+        bitcast->operand(0)->shape().ToString(/*print_layout=*/true),\n+        bitcast->shape().ToString(/*print_layout=*/true)));\n+  }\n+\n+  if (Shape::Equal()(after_bitcast_shape, before_bitcast_shape)) {\n+    // This bitcast did nothing. We do not need to adjust the copy shapes at\n+    // all.\n+    return std::make_pair(shape_before_copy, shape_after_copy);\n+  }\n+\n+  // We know the shapes are equal ignoring layout.\n+  const auto& before_layout = before_bitcast_shape.layout();\n+  const auto& after_layout = after_bitcast_shape.layout();\n+\n+  // First, check if the dimension ordering is actually different. If not,\n+  // it's not a transpose.\n+  const bool minor_to_major_is_different = !absl::c_equal(\n+      before_layout.minor_to_major(), after_layout.minor_to_major());\n+\n+  if (minor_to_major_is_different) {\n+    // To confirm that *only* the dimension order has changed, we can create\n+    // copies of the layouts, clear the minor_to_major field, and then\n+    // compare the remaining properties (tiling, memory space, etc.).\n+    Layout before_layout_copy = before_layout;\n+    Layout after_layout_copy = after_layout;\n+    before_layout_copy.clear_minor_to_major();\n+    after_layout_copy.clear_minor_to_major();\n+\n+    if (LayoutUtil::Equal(before_layout_copy, after_layout_copy)) {\n+      // This is a pure transposing bitcast where other layout properties are\n+      // preserved.\n+      VLOG(2) << \"Bitcast is a transposing bitcast: \" << bitcast->ToString();\n+      // We now need to identify the permutation of dimensions and apply the\n+      // same tranpose to the before & after shapes of the copy.\n+      std::vector<int> permutation(before_layout.minor_to_major().size());\n+      const auto before_minor_to_major = before_layout.minor_to_major();\n+      const auto after_minor_to_major = after_layout.minor_to_major();\n+      for (int i = 0; i < before_minor_to_major.size(); ++i) {\n+        // Find the index of this item in the after layout.\n+        const int j = std::distance(\n+            after_minor_to_major.begin(),\n+            absl::c_find(after_minor_to_major, before_minor_to_major[i]));\n+        permutation[i] = j;\n+      }\n+      // Now that the permutation is known, apply it to the shape before and\n+      // after the copy.\n+      auto apply_permutation = [&permutation](Shape& new_shape,\n+                                              const Shape& original_shape) {\n+        DimensionVector& major_to_minor =\n+            *new_shape.mutable_layout()->mutable_minor_to_major();\n+        for (int i = 0; i < permutation.size(); ++i) {\n+          major_to_minor[i] =\n+              original_shape.layout().minor_to_major(permutation[i]);\n+        }\n+      };\n+      Shape new_shape_before_copy = shape_before_copy;\n+      Shape new_shape_after_copy = shape_after_copy;\n+      apply_permutation(new_shape_before_copy, shape_before_copy);\n+      apply_permutation(new_shape_after_copy, shape_after_copy);\n+      return std::make_pair(new_shape_before_copy, new_shape_after_copy);\n+    }\n+  }\n+  return absl::UnimplementedError(absl::StrFormat(\n+      \"Something about this layout changed other than the minor-to-major \"\n+      \"ordering. This is unsuppored. Bitcast: \\\"%s\\\"\",\n+      bitcast->ToString()));\n+}\n+\n+// This function is to be called when we are moving a copy down the graph. The\n+// bitcast presumably changes the shape in some way. Since the copy will be move\n+// down after this bitcast, we need to adjust the input and output shape of the\n+// copy as if this bitcast applied before the copy.\n+absl::StatusOr<std::pair<Shape, Shape>> GetNewShapesAfterBitcast(\n+    const HloInstruction* bitcast, const HloInstruction* copy_to_move,\n+    const Shape& shape_before_copy, const Shape& shape_after_copy) {\n+  if (!Shape::Equal().IgnoreLayout()(copy_to_move->operand(0)->shape(),\n+                                     copy_to_move->shape())) {\n+    return absl::InternalError(absl::StrFormat(\n+        \"Expecting copy to only change instruction's layout. Copy: %s\",\n+        copy_to_move->ToString()));\n+  }\n+\n+  const Shape& before_bitcast_shape = bitcast->operand(0)->shape();\n+  const Shape& after_bitcast_shape = bitcast->shape();\n+\n+  // Dimensionality decreases.\n+  if (after_bitcast_shape.dimensions().size() ==\n+      before_bitcast_shape.dimensions().size() - 1) {\n+    // This bitcast is removing a dimension.\n+    return GetNewShapesAfterBitcastReducedRank(\n+        bitcast, copy_to_move, shape_before_copy, shape_after_copy);\n+  }\n+\n+  // Dimensionality increases.\n+  if (after_bitcast_shape.dimensions().size() ==\n+      before_bitcast_shape.dimensions().size() + 1) {\n+    // This bitcast is adding a dimension.\n+    return GetNewShapesAfterBitcastIncreasedRank(\n+        bitcast, copy_to_move, shape_before_copy, shape_after_copy);\n+  }\n+\n+  // Dimensionality does not change.\n+  if (after_bitcast_shape.dimensions().size() ==\n+      before_bitcast_shape.dimensions().size()) {\n+    return GetNewShapesAfterBitcastSameRank(\n+        bitcast, copy_to_move, shape_before_copy, shape_after_copy);\n+  }\n+\n+  // Dimensionality changes in some other way.\n+  return absl::UnimplementedError(absl::StrFormat(\n+      \"Bitcast changes dimensionality in an unsupported way. Bitcast: \\\"%s\\\"\",\n+      bitcast->ToString()));\n+}\n+\n absl::Status MoveCopyDown(\n     const InstructionAndIndex& copy_to_move_instruction_and_index,\n     const CallGraph* call_graph,\n@@ -406,88 +587,31 @@ absl::Status MoveCopyDown(\n             << current_instruction_and_index.instruction->ToString()\n             << \", index: \" << current_instruction_and_index.index;\n     // Get the users of the current instruction.\n-    absl::StatusOr<std::vector<InstructionAndIndex>> current_value_down =\n+    absl::StatusOr<std::vector<InstructionAndIndex>> current_instruction_users =\n         WalkDownMemoryOffload(current_instruction_and_index, *call_graph,\n                               /*for_move_copy_phase=*/true);\n-    if (!current_value_down.ok()) {\n+    if (!current_instruction_users.ok()) {\n       VLOG(5) << \"WalkDownMemoryOffload failed: \"\n-              << current_value_down.status();\n+              << current_instruction_users.status();\n       break;\n     }\n \n     for (InstructionAndIndex& instruction_and_index :\n-         current_value_down.value()) {\n+         current_instruction_users.value()) {\n       HloInstruction* instruction = instruction_and_index.instruction;\n       Shape shape_before_copy =\n           current_instruction_and_shapes.shape_before_copy;\n       Shape shape_after_copy = current_instruction_and_shapes.shape_after_copy;\n       VLOG(5) << \"Evaluating successor: \" << instruction->ToString();\n       const int index = instruction_and_index.index;\n       if (instruction->opcode() == HloOpcode::kBitcast) {\n-        // For now, we only know how to move a copy over a bitcast which\n-        // \"reshapes\" away the majormost dimension (which must be a degenerate\n-        // dimension), or reshapes to add a degenerate majormost dimension.\n-        const Shape& before_bitcast_shape = instruction->operand(0)->shape();\n-        const Shape& after_bitcast_shape = instruction->shape();\n-        if (!Shape::Equal().IgnoreLayout()(copy_to_move->operand(0)->shape(),\n-                                           copy_to_move->shape())) {\n-          return absl::InternalError(absl::StrFormat(\n-              \"Expecting copy to only change instructions layout. Copy: %s\",\n-              copy_to_move->ToString()));\n-        }\n-        if (after_bitcast_shape.dimensions().size() ==\n-            before_bitcast_shape.dimensions().size() - 1) {\n-          if (!(ShapeUtil::IsEffectivelyMostMajorDimension(before_bitcast_shape,\n-                                                           0) &&\n-                before_bitcast_shape.dimensions(0) == 1)) {\n-            return absl::InternalError(absl::StrFormat(\n-                \"Only handling bitcasts with majormost dimension \"\n-                \"of size 1. This bitcast is \\\"%s\\\"\",\n-                instruction->ToString()));\n-          }\n-          const Shape new_bitcast_shape =\n-              RemoveMajormostDimension(shape_before_copy);\n-          VLOG(2) << absl::StreamFormat(\n-              \" Encountered bitcast \\\"%s\\\", updating current shape from %s to \"\n-              \"%s\",\n-              instruction->name(), shape_before_copy.ToString(true),\n-              new_bitcast_shape.ToString(true));\n-          shape_before_copy = new_bitcast_shape;\n-          const Shape new_copy_shape =\n-              RemoveMajormostDimension(shape_after_copy);\n-          VLOG(2) << absl::StreamFormat(\n-              \" Also updating shape after copy from %s to %s\",\n-              shape_after_copy.ToString(true), new_copy_shape.ToString(true));\n-          shape_after_copy = new_copy_shape;\n-        } else if (after_bitcast_shape.dimensions().size() ==\n-                   before_bitcast_shape.dimensions().size() + 1) {\n-          if (!(ShapeUtil::IsEffectivelyMostMajorDimension(after_bitcast_shape,\n-                                                           0) &&\n-                after_bitcast_shape.dimensions(0) == 1)) {\n-            return absl::InternalError(absl::StrFormat(\n-                \"Only handling bitcasts with majormost dimension \"\n-                \"of size 1. This bitcast is \\\"%s\\\"\",\n-                instruction->ToString()));\n-          }\n-          const Shape new_bitcast_shape =\n-              AddMajormostDimension(shape_before_copy);\n-          VLOG(2) << absl::StreamFormat(\n-              \" Encountered bitcast \\\"%s\\\", updating current shape from %s to \"\n-              \"%s\",\n-              instruction->name(), shape_before_copy.ToString(true),\n-              new_bitcast_shape.ToString(true));\n-          shape_before_copy = new_bitcast_shape;\n-          const Shape new_copy_shape = AddMajormostDimension(shape_after_copy);\n-          VLOG(2) << absl::StreamFormat(\n-              \" Also updating shape after copy from %s to %s\",\n-              shape_after_copy.ToString(true), new_copy_shape.ToString(true));\n-          shape_after_copy = new_copy_shape;\n-        } else {\n-          return absl::InternalError(\n-              absl::StrFormat(\"Only handling bitcasts which add or remove a \"\n-                              \"0'th dimension. This bitcast is \\\"%s\\\"\",\n-                              instruction->ToString()));\n-        }\n+        std::pair<Shape, Shape> new_shapes;\n+        TF_ASSIGN_OR_RETURN(\n+            new_shapes,\n+            GetNewShapesAfterBitcast(instruction, copy_to_move,\n+                                     shape_before_copy, shape_after_copy));\n+        shape_before_copy = new_shapes.first;\n+        shape_after_copy = new_shapes.second;\n       } else if (instruction->opcode() == HloOpcode::kSlice ||\n                  instruction->opcode() == HloOpcode::kDynamicSlice) {\n         // Since we're moving the copy over a Slice/DynamicSlice, we need to\n@@ -614,9 +738,9 @@ absl::Status MoveCopyDown(\n \n // Returns true if the copy should be moved. A copy can be moved if there is\n // always a place for it after being moved back to device.\n-bool ShouldMoveCopyDown(InstructionAndIndex copy_to_move) {\n+bool ShouldMoveCopyDown(HloInstruction* copy_to_move) {\n   std::queue<host_offload_utils::InstructionAndShapeIndex> queue;\n-  queue.push({copy_to_move.instruction, {}});\n+  queue.push(host_offload_utils::InstructionAndShapeIndex(copy_to_move));\n   while (!queue.empty()) {\n     host_offload_utils::InstructionAndShapeIndex current = queue.front();\n     queue.pop();\n@@ -819,7 +943,7 @@ absl::StatusOr<bool> ProcessAnnotationForCopyMovement(\n   for (auto it = copies_to_move.rbegin(); it != copies_to_move.rend(); ++it) {\n     InstructionAndIndex& copy_to_move_and_index = *it;\n     HloInstruction* copy_to_move = copy_to_move_and_index.instruction;\n-    if (ShouldMoveCopyDown(copy_to_move_and_index)) {\n+    if (ShouldMoveCopyDown(copy_to_move)) {\n       TF_RETURN_IF_ERROR(MoveCopyDown(copy_to_move_and_index, call_graph,\n                                       processed_annotations, to_remove));\n       changed = true;"
        },
        {
            "sha": "adcca01e7005d6186cc1907b14ba6d6c8539d1bc",
            "filename": "third_party/xla/xla/hlo/transforms/host_offload_legalize_test.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/34df173e205f2a64a0654628ca11eca8764675cc/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fhost_offload_legalize_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/34df173e205f2a64a0654628ca11eca8764675cc/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fhost_offload_legalize_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Ftransforms%2Fhost_offload_legalize_test.cc?ref=34df173e205f2a64a0654628ca11eca8764675cc",
            "patch": "@@ -659,6 +659,37 @@ ENTRY main {\n   ASSERT_FALSE(changed);\n }\n \n+TEST_F(HostOffloadLegalizeTest, MoveCopyOverTransposingBitcast) {\n+  const std::string& hlo_string = R\"(\n+HloModule jit_f, entry_computation_layout={(bf16[1,1,16384,8,256]{4,3,2,1,0:T(4,128)(2,1)S(5)})->bf16[1,1,16384,8,256]{4,3,2,1,0:T(8,128)(2,1)}}\n+\n+ENTRY main {\n+  param = bf16[1,1,16384,8,256]{4,3,2,1,0:T(4,128)(2,1)} parameter(0)\n+  copy = bf16[1,1,16384,8,256]{4,2,3,1,0:T(8,128)(2,1)} copy(param)\n+  bitcast = bf16[1,1,16384,8,256]{4,3,2,1,0:T(8,128)(2,1)} bitcast(copy)\n+  custom-call = bf16[1,1,16384,8,256]{4,3,2,1,0:T(8,128)(2,1)} custom-call(bitcast), custom_call_target=\"MoveToDevice\"\n+  ROOT add = bf16[1,1,16384,8,256]{4,3,2,1,0:T(8,128)(2,1)} add(custom-call, custom-call)\n+}\n+)\";\n+\n+  TF_ASSERT_OK_AND_ASSIGN(auto module,\n+                          ParseAndReturnVerifiedModule(hlo_string));\n+\n+  TF_ASSERT_OK_AND_ASSIGN(bool changed, RunHostOffloadLegalize(module.get()));\n+\n+  EXPECT_TRUE(changed);\n+  XLA_VLOG_LINES(1, module->ToString());\n+  HloInstruction* custom_call = FindInstruction(module.get(), \"custom-call\");\n+  EXPECT_EQ(\n+      custom_call->shape().layout(),\n+      LayoutUtil::MakeLayout({4, 2, 3, 1, 0}, {Tile{{4, 128}}, Tile{{2, 1}}}));\n+  HloInstruction* copy = custom_call->users()[0];\n+  EXPECT_EQ(copy->opcode(), HloOpcode::kCopy);\n+  EXPECT_EQ(\n+      copy->shape().layout(),\n+      LayoutUtil::MakeLayout({4, 3, 2, 1, 0}, {Tile{{8, 128}}, Tile{{2, 1}}}));\n+}\n+\n }  // namespace\n \n }  // namespace xla"
        }
    ],
    "stats": {
        "total": 298,
        "additions": 227,
        "deletions": 71
    }
}