{
    "author": "tensorflower-gardener",
    "message": "Reverts a91d77918af125702b12e5a4f6a6768a8203ccca\n\nPiperOrigin-RevId: 798338574",
    "sha": "fd32c1a1d90c23ad22be146a3388117b5229d810",
    "files": [
        {
            "sha": "abd06eae6d20ad62450f50eeb6fa6f00c74a0a0f",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer.cc",
            "status": "modified",
            "additions": 45,
            "deletions": 36,
            "changes": 81,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fd32c1a1d90c23ad22be146a3388117b5229d810/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fd32c1a1d90c23ad22be146a3388117b5229d810/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.cc?ref=fd32c1a1d90c23ad22be146a3388117b5229d810",
            "patch": "@@ -52,34 +52,39 @@ namespace xla {\n \n void BufferSequencingEvent::SetSequencingEvent(EventPool::Handle event,\n                                                se::Stream* stream) {\n-  EventState state;\n-  state.event = std::move(event);\n-  state.definition_stream = stream;\n-  event_.emplace(std::move(state));\n+  {\n+    absl::MutexLock lock(&mu_);\n+    CHECK(!event_.event());\n+    event_ = std::move(event);\n+    CHECK(streams_defined_on_.empty());\n+    streams_defined_on_.push_back(stream);\n+    sequence_number_.store(event_.sequence_number(), std::memory_order_seq_cst);\n+  }\n+  defined_status_.emplace(absl::OkStatus());\n }\n \n void BufferSequencingEvent::SetDefinedStatus(absl::Status status) {\n   CHECK(!status.ok());\n-  event_.SetError(status);\n+  defined_status_.emplace(status);\n+}\n+\n+bool BufferSequencingEvent::EventHasBeenRecorded() const {\n+  return event_.event() != nullptr;\n }\n \n uint64_t BufferSequencingEvent::sequence_number() const {\n-  return event_->event.sequence_number();\n+  uint64_t seq = sequence_number_.load(std::memory_order_seq_cst);\n+  return seq;\n }\n \n void BufferSequencingEvent::WaitForEventOnStream(se::Stream* stream) {\n+  absl::MutexLock lock(&mu_);\n+\n   // We cannot wait for an event until ThenRecordEvent has been called; on GPU\n   // newly created events are deemed to have already happened past.\n-  tsl::BlockUntilReady(event_);\n-\n-  if (event_.IsError()) {\n-    return;\n-  }\n-  if (event_->definition_stream == stream) {\n-    return;\n-  }\n+  mu_.Await(\n+      absl::Condition(this, &BufferSequencingEvent::EventHasBeenRecorded));\n \n-  absl::MutexLock lock(&mu_);\n   // The set of defined streams is expected to be very small indeed (usually\n   // 1-2), so a simple linear scan should be fast enough.\n   if (std::find(streams_defined_on_.begin(), streams_defined_on_.end(),\n@@ -88,30 +93,31 @@ void BufferSequencingEvent::WaitForEventOnStream(se::Stream* stream) {\n     return;\n   }\n \n-  stream->WaitFor(event_->event.event()).IgnoreError();\n+  stream->WaitFor(event_.event()).IgnoreError();\n   streams_defined_on_.push_back(stream);\n }\n \n absl::Status BufferSequencingEvent::WaitForEventOnExternalStream(\n     std::intptr_t stream) {\n-  tsl::BlockUntilReady(event_);\n-  if (const auto* error = event_.GetErrorIfPresent()) {\n-    return *error;\n-  }\n-  return event_->event.event()->WaitForEventOnExternalStream(stream);\n+  absl::MutexLock lock(&mu_);\n+\n+  // We cannot wait for an event until ThenRecordEvent has been called; on GPU\n+  // newly created events are deemed to have already happened past.\n+  // TODO(skyewm): do we need this? WaitForEventOnExternalStream is only\n+  // implemented for GPU.\n+  mu_.Await(\n+      absl::Condition(this, &BufferSequencingEvent::EventHasBeenRecorded));\n+\n+  return event_.event()->WaitForEventOnExternalStream(stream);\n }\n \n bool BufferSequencingEvent::IsPredeterminedErrorOrDefinedOn(\n     se::Stream* stream) {\n-  tsl::BlockUntilReady(event_);\n-  CHECK(event_.IsAvailable());\n+  tsl::BlockUntilReady(defined_status_);\n+  CHECK(defined_status_.IsConcrete());\n \n   // IsPredeterminedError\n-  if (event_.IsError()) {\n-    return true;\n-  }\n-\n-  if (event_->definition_stream == stream) {\n+  if (!defined_status_->ok()) {\n     return true;\n   }\n \n@@ -122,12 +128,14 @@ bool BufferSequencingEvent::IsPredeterminedErrorOrDefinedOn(\n }\n \n bool BufferSequencingEvent::IsComplete() {\n-  tsl::BlockUntilReady(event_);\n-  if (event_.IsError()) {\n-    return true;\n-  }\n+  absl::MutexLock lock(&mu_);\n+\n+  // We cannot wait for an event until ThenRecordEvent has been called; on\n+  // GPU newly created events are deemed to have already happened past.\n+  mu_.Await(\n+      absl::Condition(this, &BufferSequencingEvent::EventHasBeenRecorded));\n \n-  return event_->event.event()->PollForStatus() == se::Event::Status::kComplete;\n+  return event_.event()->PollForStatus() == se::Event::Status::kComplete;\n }\n \n void BufferSequencingEvent::ExecuteOrAddToFutureTasks(\n@@ -146,9 +154,10 @@ void BufferSequencingEvent::ExecuteOrAddToFutureTasks(\n \n   // Execute the `task` when definition event becomes available. If it's already\n   // available, the task will be executed immediately.\n-  event_.AndThen([this, traced_task = std::move(traced_task)]() mutable {\n-    thread_pool_->Schedule(std::move(traced_task));\n-  });\n+  defined_status_.AndThen(\n+      [this, traced_task = std::move(traced_task)]() mutable {\n+        thread_pool_->Schedule(std::move(traced_task));\n+      });\n }\n \n ShapedBuffer RawSEDeviceMemory::AsShapedBuffer("
        },
        {
            "sha": "9f7c34b5581c5075915974d5b1a4b42158accc35",
            "filename": "third_party/xla/xla/pjrt/tracked_device_buffer.h",
            "status": "modified",
            "additions": 22,
            "deletions": 20,
            "changes": 42,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/fd32c1a1d90c23ad22be146a3388117b5229d810/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/fd32c1a1d90c23ad22be146a3388117b5229d810/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Ftracked_device_buffer.h?ref=fd32c1a1d90c23ad22be146a3388117b5229d810",
            "patch": "@@ -78,7 +78,7 @@ class BufferSequencingEvent : tsl::AsyncPayload::KeepOnError {\n  public:\n   explicit BufferSequencingEvent(tsl::thread::ThreadPool* thread_pool)\n       : thread_pool_(thread_pool),\n-        event_(tsl::MakeUnconstructedAsyncValueRef<EventState>()) {}\n+        defined_status_(tsl::MakeUnconstructedAsyncValueRef<absl::Status>()) {}\n \n   static tsl::AsyncValueRef<BufferSequencingEvent> Create(\n       tsl::thread::ThreadPool* thread_pool) {\n@@ -129,25 +129,24 @@ class BufferSequencingEvent : tsl::AsyncPayload::KeepOnError {\n   }\n \n   // Executes the `task` if the event is ready; otherwise adds the `task`\n-  // callback to `event_` async value, to be executed when it becomes\n+  // callback to `defined_status_` async value, to be executed when it becomes\n   // available.\n   void ExecuteOrAddToFutureTasks(const std::string& task_name,\n                                  std::function<void()> task);\n \n-  bool IsDefined() { return event_.IsAvailable(); }\n+  bool IsDefined() { return defined_status_.IsConcrete(); }\n \n   // Do not call directly. Use PjRtStreamExecutorClient::SetEventAsError.\n   void SetDefinedStatus(absl::Status status);\n \n   absl::Status GetDefinedStatus() {\n-    CHECK(event_.IsAvailable());\n-    if (const auto* error = event_.GetErrorIfPresent()) {\n-      return *error;\n-    }\n-    return absl::OkStatus();\n+    CHECK(defined_status_.IsConcrete());\n+    return *defined_status_;\n   }\n \n-  bool IsPredeterminedError() { return event_.IsError(); }\n+  bool IsPredeterminedError() {\n+    return defined_status_.IsConcrete() && !defined_status_->ok();\n+  }\n \n   // Returns true if either:\n   // 1. The event IsPredeterminedError\n@@ -157,19 +156,22 @@ class BufferSequencingEvent : tsl::AsyncPayload::KeepOnError {\n   // blocks the calling thread until either of those 2 happens.\n   bool IsPredeterminedErrorOrDefinedOn(se::Stream* stream);\n \n-  struct EventState {\n-    // An event that is triggered when the content of one or more buffers has\n-    // been read or written. If this event is used as a definition event and is\n-    // nullptr, it is assumed that the buffer's content is always defined for\n-    // example because it uses storage borrowed from elsewhere.\n-    EventPool::Handle event;\n-\n-    se::Stream* definition_stream;\n-  };\n-\n  private:\n+  bool EventHasBeenRecorded() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(mu_);\n   uint64_t sequence_number() const;\n \n+  // An event that is triggered when the content of one or more buffers has been\n+  // read or written. If this event is used as a definition event and is\n+  // nullptr, it is assumed that the buffer's content is always defined for\n+  // example because it uses storage borrowed from elsewhere.\n+  EventPool::Handle event_;\n+\n+  // Cache of event_->sequence_number that avoids synchronization overhead.\n+  // TODO(phawkins): In fact, event_->sequence_number is unused beyond the\n+  // initial population of sequence_number_, and we could remove it if we\n+  // refactored the EventPool API.\n+  std::atomic<uint64_t> sequence_number_{0};\n+\n   mutable absl::Mutex mu_;\n   // A list of all streams for which the buffer's content is known to be defined\n   // at the tail of the queue, i.e., for any newly enqueued command.\n@@ -179,7 +181,7 @@ class BufferSequencingEvent : tsl::AsyncPayload::KeepOnError {\n \n   // Indicates if the buffer is in an error status. And error status is used to\n   // propagate the error to the buffer consumers.\n-  tsl::AsyncValueRef<EventState> event_;\n+  tsl::AsyncValueRef<absl::Status> defined_status_;\n };\n \n using BufferSequencingEventRef = tsl::AsyncValueRef<BufferSequencingEvent>;"
        }
    ],
    "stats": {
        "total": 123,
        "additions": 67,
        "deletions": 56
    }
}