{
    "author": "ezhulenev",
    "message": "[xla] Migrate to PjRtFuture<>::MakePromise() API\n\nPiperOrigin-RevId: 806057470",
    "sha": "b644c6b8a80acbd80f8dd4751a2a5f9124312e06",
    "files": [
        {
            "sha": "dee021d366898b61599f09d72f67a5498474f094",
            "filename": "third_party/xla/xla/pjrt/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b644c6b8a80acbd80f8dd4751a2a5f9124312e06/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b644c6b8a80acbd80f8dd4751a2a5f9124312e06/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2FBUILD?ref=b644c6b8a80acbd80f8dd4751a2a5f9124312e06",
            "patch": "@@ -109,6 +109,7 @@ cc_library(\n         \"@com_google_absl//absl/log:check\",\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n+        \"@com_google_absl//absl/strings\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@local_tsl//tsl/profiler/lib:traceme\",\n     ],"
        },
        {
            "sha": "874339001ec8d99a4d5294bdd4eb663fa4dcc6f4",
            "filename": "third_party/xla/xla/pjrt/abstract_tracked_device_buffer.h",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b644c6b8a80acbd80f8dd4751a2a5f9124312e06/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b644c6b8a80acbd80f8dd4751a2a5f9124312e06/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fabstract_tracked_device_buffer.h?ref=b644c6b8a80acbd80f8dd4751a2a5f9124312e06",
            "patch": "@@ -18,15 +18,21 @@ limitations under the License.\n \n #include <array>\n #include <memory>\n+#include <vector>\n \n #include \"absl/base/thread_annotations.h\"\n+#include \"absl/functional/any_invocable.h\"\n #include \"absl/log/check.h\"\n #include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_cat.h\"\n #include \"absl/synchronization/mutex.h\"\n+#include \"xla/pjrt/device_event.h\"\n #include \"xla/pjrt/pjrt_client.h\"\n #include \"xla/pjrt/pjrt_future.h\"\n #include \"xla/pjrt/raw_buffer.h\"\n+#include \"xla/tsl/concurrency/async_value.h\"\n+#include \"xla/tsl/concurrency/ref_count.h\"\n \n namespace xla {\n \n@@ -224,9 +230,8 @@ class CommonPjRtBuffer : public PjRtBuffer {\n \n   absl::Status AcquireScopedRawBuffer(\n       absl::AnyInvocable<absl::StatusOr<tsl::RCReference<PjRtDeviceEvent>>(\n-                             tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n-                             std::vector<tsl::RCReference<tsl::AsyncValue>>\n-                                 definition_events) &&>\n+          tsl::RCReference<CommonPjRtRawBuffer> raw_buffer,\n+          std::vector<tsl::RCReference<tsl::AsyncValue>> definition_events) &&>\n           scoped_acquire,\n       const char* caller_name = \"AcquireScopedRawBuffer\");\n \n@@ -294,7 +299,7 @@ class CommonPjRtBuffer : public PjRtBuffer {\n   }\n \n   mutable absl::Mutex mu_;\n-  PjRtFuture<>::Promise definition_promise_ ABSL_GUARDED_BY(mu_);\n+  PjRtFuture<> definition_future_ ABSL_GUARDED_BY(mu_);\n   PjRtMemorySpace* const memory_space_;\n \n  private:"
        },
        {
            "sha": "22513832af99ddc20c655247dfcea6163d7a1648",
            "filename": "third_party/xla/xla/pjrt/common_pjrt_client.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b644c6b8a80acbd80f8dd4751a2a5f9124312e06/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b644c6b8a80acbd80f8dd4751a2a5f9124312e06/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fcommon_pjrt_client.cc?ref=b644c6b8a80acbd80f8dd4751a2a5f9124312e06",
            "patch": "@@ -1194,12 +1194,12 @@ PjRtFuture<> CommonPjRtBufferImpl::GetReadyFuture() {\n     return PjRtFuture<>(InvalidArgument(\n         \"GetReadyFuture() called on deleted or donated buffer\"));\n   }\n-  if (!definition_promise_) {\n-    definition_promise_ =\n-        device_buffer()->GetReadyFuturePromise(memory_space());\n+  if (!definition_future_) {\n+    auto promise = device_buffer()->GetReadyFuturePromise(memory_space());\n+    definition_future_ = client()->CreateFutureFromUserPromise(\n+        memory_space(), \"CommonPjRtBuffer\", \"Await\", std::move(promise));\n   }\n-  return client()->CreateFutureFromUserPromise(\n-      memory_space(), \"CommonPjRtBuffer\", \"Await\", definition_promise_);\n+  return definition_future_;\n }\n \n }  // namespace xla"
        },
        {
            "sha": "7443cfda93f33968ec251ba16f7309c4a9eb980b",
            "filename": "third_party/xla/xla/pjrt/pjrt_future.h",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b644c6b8a80acbd80f8dd4751a2a5f9124312e06/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b644c6b8a80acbd80f8dd4751a2a5f9124312e06/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_future.h?ref=b644c6b8a80acbd80f8dd4751a2a5f9124312e06",
            "patch": "@@ -217,6 +217,8 @@ class PjRtFutureBase : public PjRtFutureMoveControl<is_move_only> {\n     }\n   }\n \n+  explicit operator bool() const { return static_cast<bool>(promise_); }\n+\n  protected:\n   static constexpr bool IsMoveOnly() { return is_move_only; }\n "
        },
        {
            "sha": "efe3ec1022e083d3a657e5bb09f14f087e8a037e",
            "filename": "third_party/xla/xla/pjrt/pjrt_stream_executor_client.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 12,
            "changes": 28,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/b644c6b8a80acbd80f8dd4751a2a5f9124312e06/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/b644c6b8a80acbd80f8dd4751a2a5f9124312e06/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fpjrt_stream_executor_client.cc?ref=b644c6b8a80acbd80f8dd4751a2a5f9124312e06",
            "patch": "@@ -2194,18 +2194,20 @@ void PjRtStreamExecutorBuffer::CopyToRemoteDevice(\n \n PjRtFuture<> PjRtStreamExecutorBuffer::GetReadyFuture() {\n   absl::InlinedVector<BufferSequencingEventRef, 2> definition_events;\n-  PjRtFuture<>::Promise definition_promise;\n+  PjRtFuture<>::MoveOnlyPromise definition_promise;\n+  PjRtFuture<> definition_future;\n   {\n     absl::MutexLock lock(&mu_);\n     if (device_buffer() == nullptr) {\n       return PjRtFuture<>(InvalidArgument(\n           \"GetReadyFuture() called on deleted or donated buffer\"));\n     }\n-    if (!definition_promise_) {\n+    if (!definition_future_) {\n       definition_events = device_buffer()->definition_events();\n-      definition_promise_ = PjRtFuture<>::CreatePromise();\n+      std::tie(definition_promise, definition_future_) =\n+          PjRtFuture<>::MakePromise();\n     }\n-    definition_promise = definition_promise_;\n+    definition_future = definition_future_;\n   }\n \n   if (!definition_events.empty()) {\n@@ -2214,12 +2216,13 @@ PjRtFuture<> PjRtStreamExecutorBuffer::GetReadyFuture() {\n     auto async_wait_for_events =\n         [definition_events = std::move(definition_events),\n          local_device_state = std::move(local_device_state),\n-         definition_promise]() mutable {\n+         definition_promise = std::make_shared<PjRtFuture<>::Promise>(\n+             std::move(definition_promise))]() mutable {\n           std::unique_ptr<se::Stream> stream;\n           absl::Status defined_status =\n               definition_events[0]->GetDefinedStatus();\n           if (!defined_status.ok()) {\n-            definition_promise.Set(defined_status);\n+            definition_promise->Set(defined_status);\n             return;\n           }\n           for (auto& event : definition_events) {\n@@ -2242,28 +2245,29 @@ PjRtFuture<> PjRtStreamExecutorBuffer::GetReadyFuture() {\n                  event_with_status = definition_events[0]]() mutable {\n                   local_device_state->ReturnStreamToPool(\n                       std::unique_ptr<se::Stream>(stream_ptr));\n-                  definition_promise.Set(event_with_status->GetDefinedStatus());\n+                  definition_promise->Set(\n+                      event_with_status->GetDefinedStatus());\n                 });\n             if (!status.ok()) {\n-              definition_promise.Set(status);\n+              definition_promise->Set(status);\n               return;\n             }\n           } else {\n             // All events are already complete; set the `definition_promise`\n             // with the status of the buffer's first definition event which may\n             // have error status to propagate.\n-            definition_promise.Set(definition_events[0]->GetDefinedStatus());\n+            definition_promise->Set(definition_events[0]->GetDefinedStatus());\n           }\n         };\n     first_definition_event->ExecuteOrAddToFutureTasks(\n         absl::StrFormat(\"async_wait_for_events_%p\", &async_wait_for_events),\n         std::move(async_wait_for_events));\n   }\n \n-  return PjRtFuture<>(\n-      std::move(definition_promise),\n+  return PjRtFutureHelpers::WithProfiling(\n+      std::move(definition_future),\n       /*on_block_start=*/\n-      []() {\n+      [] {\n         tsl::profiler::TraceMeProducer traceme(\n             \"PjRtStreamExecutorBuffer::Await\");\n         VLOG(3) << \"PjRtStreamExecutorBuffer::Await\";"
        }
    ],
    "stats": {
        "total": 54,
        "additions": 33,
        "deletions": 21
    }
}