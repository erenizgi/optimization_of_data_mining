{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 845732556",
    "sha": "36c07984c2dbbd9561106a2666b8d892fa3a9bea",
    "files": [
        {
            "sha": "1e355d45a91ec163b50d507d566655d30a44e3d2",
            "filename": "tensorflow/core/grappler/graph_analyzer/gen_node.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgen_node.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgen_node.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgen_node.cc?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -34,7 +34,7 @@ GenNode::GenNode(const NodeDef* node) : node_(node), op_(nullptr) {}\n \n absl::Status GenNode::BuildGraphInMap(const GraphDef& source, GenNodeMap* map) {\n   for (const auto& n : source.node()) {\n-    const string& name = n.name();\n+    const std::string& name = n.name();\n     if (map->find(name) != map->end()) {\n       // This error code looks more meaningful than ALREADY_EXISTS.\n       return absl::Status(absl::StatusCode::kInvalidArgument,\n@@ -95,7 +95,7 @@ absl::Status GenNode::ParseInputs(const GenNodeMap* map) {\n \n   for (int i = 0; i < n_inputs; ++i) {\n     int other_position;\n-    string other_name = ParseNodeName(node_->input(i), &other_position);\n+    std::string other_name = ParseNodeName(node_->input(i), &other_position);\n     auto other_it = map->find(other_name);\n     if (other_it == map->end()) {\n       return absl::Status(\n@@ -138,8 +138,8 @@ bool GenNode::IsMultiInput(Port port) const {\n   return (it->second.size() > 1);\n }\n \n-GenNode::Port::operator string() const {\n-  string result = this->IsInbound() ? \"i\" : \"o\";\n+GenNode::Port::operator std::string() const {\n+  std::string result = this->IsInbound() ? \"i\" : \"o\";\n   if (this->IsControl()) {\n     result.append(\"C\");\n   } else {"
        },
        {
            "sha": "7194a48a6a2538531d305bb5bfd0981b3a49e242",
            "filename": "tensorflow/core/grappler/graph_analyzer/gen_node.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgen_node.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgen_node.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgen_node.h?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -35,7 +35,7 @@ namespace graph_analyzer {\n class GenNode;\n \n // To find nodes by name.\n-using GenNodeMap = std::unordered_map<string, std::unique_ptr<GenNode>>;\n+using GenNodeMap = std::unordered_map<std::string, std::unique_ptr<GenNode>>;\n \n // One node in the graph, in the form convenient for traversal and generation of\n // subgraphs. It refers to the original NodeDef protobuf for most information\n@@ -51,8 +51,8 @@ class GenNode {\n   explicit GenNode(const NodeDef* node);\n \n   // Access wrappers.\n-  const string& name() const { return node_->name(); }\n-  const string& opcode() const { return node_->op(); }\n+  const std::string& name() const { return node_->name(); }\n+  const std::string& opcode() const { return node_->op(); }\n   const NodeDef* node_def() const { return node_; }\n \n   // Parse the inputs of this node and update the map accordingly, creating the\n@@ -111,7 +111,7 @@ class GenNode {\n \n     // Convenient for printing. I've really wanted it to be implicit but\n     // ClangTidy insists on making it explicit.\n-    explicit operator string() const;\n+    explicit operator std::string() const;\n \n    private:\n     explicit Port(IntPort value) : value_(value) {}"
        },
        {
            "sha": "dde0fb720c01704b191816d00bcaeacab5bb1111",
            "filename": "tensorflow/core/grappler/graph_analyzer/graph_analyzer.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer.cc?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -315,16 +315,16 @@ absl::Status GraphAnalyzer::CollateResult() {\n   return absl::OkStatus();\n }\n \n-std::vector<string> GraphAnalyzer::DumpRawSubgraphs() {\n-  std::vector<string> result;\n+std::vector<std::string> GraphAnalyzer::DumpRawSubgraphs() {\n+  std::vector<std::string> result;\n   for (const auto& it : result_) {\n     result.emplace_back(it->Dump());\n   }\n   return result;\n }\n \n-std::vector<string> GraphAnalyzer::DumpSubgraphs() {\n-  std::vector<string> result;\n+std::vector<std::string> GraphAnalyzer::DumpSubgraphs() {\n+  std::vector<std::string> result;\n   for (auto ptr : ordered_collation_) {\n     result.emplace_back(\n         absl::StrFormat(\"%d %s\", ptr->count, ptr->sig->ToString()));"
        },
        {
            "sha": "be46b6843225a6bd28c88c14767ba8108d3917fb",
            "filename": "tensorflow/core/grappler/graph_analyzer/graph_analyzer.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer.h?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -46,7 +46,7 @@ class GraphAnalyzer {\n   absl::Status Run();\n \n   // Returns the subgraphs found in Run() printed to text.\n-  std::vector<string> DumpSubgraphs();\n+  std::vector<std::string> DumpSubgraphs();\n \n   // Prints the subgraphs found in Run() to stdout.\n   absl::Status OutputSubgraphs();\n@@ -78,7 +78,7 @@ class GraphAnalyzer {\n   absl::Status CollateResult();\n \n   // Returns the raw subgraphs found in FindSubgraphs() printed to text.\n-  std::vector<string> DumpRawSubgraphs();\n+  std::vector<std::string> DumpRawSubgraphs();\n \n   // Finds and adds appropriately to either partial_ or result_ all the\n   // subgraphs that can be created by extending the parent subgraph by one node."
        },
        {
            "sha": "4e9220d3a5c7e573f0909db71b3595e893251c3a",
            "filename": "tensorflow/core/grappler/graph_analyzer/graph_analyzer_test.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 4,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer_test.cc?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -56,10 +56,12 @@ class GraphAnalyzerTest : public ::testing::Test, protected TestGraphs {\n     gran_->ExtendSubgraphAllOrNone(parent, node);\n   }\n \n-  std::vector<string> DumpRawSubgraphs() { return gran_->DumpRawSubgraphs(); }\n+  std::vector<std::string> DumpRawSubgraphs() {\n+    return gran_->DumpRawSubgraphs();\n+  }\n \n-  std::vector<string> DumpPartials() {\n-    std::vector<string> result;\n+  std::vector<std::string> DumpPartials() {\n+    std::vector<std::string> result;\n     for (const auto& it : gran_->partial_) {\n       result.emplace_back(it->Dump());\n     }\n@@ -68,7 +70,9 @@ class GraphAnalyzerTest : public ::testing::Test, protected TestGraphs {\n \n   const GenNodeMap& GetNodes() { return gran_->nodes_; }\n \n-  GenNode* GetNode(const string& name) { return gran_->nodes_.at(name).get(); }\n+  GenNode* GetNode(const std::string& name) {\n+    return gran_->nodes_.at(name).get();\n+  }\n \n   SubgraphPtrSet& GetResult() { return gran_->result_; }\n   SubgraphPtrSet& GetPartial() { return gran_->partial_; }"
        },
        {
            "sha": "0b1b3af2ea5571362f89f01added9a9cba258a7a",
            "filename": "tensorflow/core/grappler/graph_analyzer/graph_analyzer_tool.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer_tool.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer_tool.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer_tool.cc?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -31,7 +31,7 @@ namespace grappler {\n namespace graph_analyzer {\n \n // Dies on failure.\n-static void LoadModel(const string& filename,\n+static void LoadModel(const std::string& filename,\n                       tensorflow::MetaGraphDef* metagraph) {\n   LOG(INFO) << \"Loading model from \" << filename;\n   absl::Status st;\n@@ -49,7 +49,7 @@ static void LoadModel(const string& filename,\n // of train ops (if provided).\n void MaybePruneGraph(const tensorflow::MetaGraphDef& metagraph,\n                      tensorflow::GraphDef* graph) {\n-  std::vector<string> fetch_nodes;\n+  std::vector<std::string> fetch_nodes;\n   for (const auto& fetch :\n        metagraph.collection_def().at(\"train_op\").node_list().value()) {\n     LOG(INFO) << \"Fetch node: \" << fetch;\n@@ -72,7 +72,7 @@ void MaybePruneGraph(const tensorflow::MetaGraphDef& metagraph,\n   }\n }\n \n-void GraphAnalyzerTool(const string& file_name, int n) {\n+void GraphAnalyzerTool(const std::string& file_name, int n) {\n   if (n < 1) {\n     LOG(FATAL) << \"Invalid subgraph size \" << n << \", must be at least 1\";\n   }"
        },
        {
            "sha": "85f75706acf4cb7f334ff95a892a10d4bfb70c33",
            "filename": "tensorflow/core/grappler/graph_analyzer/graph_analyzer_tool.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer_tool.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer_tool.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fgraph_analyzer_tool.h?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -22,7 +22,7 @@ namespace tensorflow {\n namespace grappler {\n namespace graph_analyzer {\n \n-void GraphAnalyzerTool(const string& file_name, int n);\n+void GraphAnalyzerTool(const std::string& file_name, int n);\n \n }  // end namespace graph_analyzer\n }  // end namespace grappler"
        },
        {
            "sha": "123bd0f060bccf4533ca3318a148b76cb89fd805",
            "filename": "tensorflow/core/grappler/graph_analyzer/sig_node.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsig_node.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsig_node.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsig_node.cc?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -99,7 +99,7 @@ void SigNode::ComputeTopoHash0() {\n   last_hashed_nodes_ = next_hashed_nodes_ = node_mask_;\n \n   // TODO(babkin): include the attributes too, as an option.\n-  size_t hval = std::hash<string>()(opcode());\n+  size_t hval = std::hash<std::string>()(opcode());\n \n   // Getting the topology of the links in to the hash early should get more\n   // conflicts resolved early.\n@@ -208,8 +208,8 @@ bool SigNode::operator==(const SigNode& other) const {\n \n constexpr int Signature::kMaxGraphSize;\n \n-string Signature::ToString() const {\n-  string result;\n+std::string Signature::ToString() const {\n+  std::string result;\n   for (size_t n = 0; n < nodes.size(); ++n) {\n     // TODO(babkin): add attributes too.\n     result += absl::StrFormat(\"%d:%s\", n, nodes[n]->opcode());\n@@ -219,9 +219,9 @@ string Signature::ToString() const {\n       // The link entries are already sorted, by tags and then by the\n       // node ranks.\n       if (link.tag.local.IsInbound()) {\n-        result +=\n-            absl::StrFormat(\"[%s:%s:%d]\", string(link.tag.local),\n-                            string(link.tag.remote), entry.peer->unique_rank_);\n+        result += absl::StrFormat(\"[%s:%s:%d]\", std::string(link.tag.local),\n+                                  std::string(link.tag.remote),\n+                                  entry.peer->unique_rank_);\n       }\n     }\n     result.push_back(',');"
        },
        {
            "sha": "2caaf605615796e371793a693c5fe9b56d4cad2f",
            "filename": "tensorflow/core/grappler/graph_analyzer/sig_node.h",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsig_node.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsig_node.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsig_node.h?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -42,7 +42,7 @@ class SigNode;\n // To find nodes by name. Having the map ordered makes the tests easier,\n // and it isn't used in production code often enough to get any win from\n // using an unordered map.\n-using SigNodeMap = std::map<string, std::unique_ptr<SigNode>>;\n+using SigNodeMap = std::map<std::string, std::unique_ptr<SigNode>>;\n \n // One node in the graph, in the form convenient for generation of the signature\n // of the graph, and comparison of two (sub)graphs for equivalence. It refers to\n@@ -61,8 +61,8 @@ class SigNode {\n   explicit SigNode(const NodeDef* node);\n \n   // Access wrappers.\n-  const string& name() const { return node_->name(); }\n-  const string& opcode() const { return node_->op(); }\n+  const std::string& name() const { return node_->name(); }\n+  const std::string& opcode() const { return node_->op(); }\n   const NodeDef* node_def() const { return node_; }\n \n   // For extraction of subgraphs into a separate SigNodeMap, copies the links\n@@ -261,7 +261,7 @@ struct Signature {\n   absl::Status Compute();\n \n   // Convert the computed signature to a string representation.\n-  string ToString() const;\n+  std::string ToString() const;\n \n   SigNodeMap map;        // The nodes in the graph, accessible by name.\n   size_t sig_short = 0;  // Hash of the signature, for the quick equality check."
        },
        {
            "sha": "56980ccedf459cd33595f3bb5f247b9fbabe7f36",
            "filename": "tensorflow/core/grappler/graph_analyzer/sig_node_test.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsig_node_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsig_node_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsig_node_test.cc?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -312,7 +312,7 @@ TEST_F(SigNodeTest, ComputeTopoHash0) {\n   EXPECT_THAT(RefNextHashedNodes(&sn1), Eq(0x02));\n   EXPECT_THAT(RefTopoHash(&sn1), SizeIs(1));\n \n-  size_t exp_hval = std::hash<string>()(sn1.opcode());\n+  size_t exp_hval = std::hash<std::string>()(sn1.opcode());\n   CombineHash(1, &exp_hval);\n   CombineHash(1, &exp_hval);\n   CombineHash(2, &exp_hval);\n@@ -640,14 +640,14 @@ class SignatureTest : public SigBaseTest {\n     std::vector<size_t> countdown;\n     InitPermutation(graph_size, &plain_permutation, &countdown);\n \n-    std::set<string> signatures;\n+    std::set<std::string> signatures;\n     std::vector<size_t> permutation;\n     do {\n       BuildPermutation(plain_permutation, countdown, &permutation);\n \n       constexpr bool kDebugPermutation = false;\n       if (kDebugPermutation) {\n-        string p;\n+        std::string p;\n         for (int i = 0; i < permutation.size(); ++i) {\n           p.push_back('0' + permutation[i]);\n         }\n@@ -1070,7 +1070,7 @@ TEST_F(SignatureTest, OrderLinks) {\n   }\n \n   // How it was ordered in the original graph.\n-  string before = sig_.ToString();\n+  std::string before = sig_.ToString();\n   // clang-format off\n   EXPECT_THAT(before, Eq(\n     \"0:Mul[i0:o0:5][i0:o0:4][i0:o1:4][i0:o2:3][i0:o2:2][i0:o3:2],\"\n@@ -1084,7 +1084,7 @@ TEST_F(SignatureTest, OrderLinks) {\n \n   OrderLinks(&sig_);\n \n-  string after = sig_.ToString();\n+  std::string after = sig_.ToString();\n   // clang-format off\n   EXPECT_THAT(after, Eq(\n       \"0:Mul[i0:o0:4][i0:o0:5][i0:o1:4][i0:o2:2][i0:o2:3][i0:o3:2],\"\n@@ -1132,7 +1132,7 @@ TEST_F(SignatureTest, ToString) {\n     RefHashIsFinal(sig_.nodes[i]) = true;\n   }\n \n-  string result = sig_.ToString();\n+  std::string result = sig_.ToString();\n \n   // clang-format off\n   ASSERT_THAT(result, Eq(\n@@ -1151,14 +1151,14 @@ TEST_F(SignatureTest, Permutation) {\n   std::vector<size_t> countdown;\n   InitPermutation(5, &plain_permutation, &countdown);\n \n-  std::set<string> results;\n+  std::set<std::string> results;\n \n   std::vector<size_t> permutation;\n   do {\n     BuildPermutation(plain_permutation, countdown, &permutation);\n     EXPECT_THAT(permutation, SizeIs(5));\n \n-    string p;\n+    std::string p;\n     for (int i = 0; i < permutation.size(); ++i) {\n       p.push_back('0' + permutation[i]);\n     }"
        },
        {
            "sha": "c08f23d97468cfa74aa120c6d2822fd15a3013f7",
            "filename": "tensorflow/core/grappler/graph_analyzer/subgraph.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsubgraph.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsubgraph.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsubgraph.cc?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -81,9 +81,9 @@ size_t Subgraph::Identity::Hash() const {\n   return result;\n }\n \n-string Subgraph::Dump() {\n+std::string Subgraph::Dump() {\n   // TODO(babkin): this is simplified for now.\n-  std::vector<string> nodes;\n+  std::vector<std::string> nodes;\n   for (const auto& n : id_) {\n     if (specific_) {\n       nodes.emplace_back(absl::StrFormat(\"%s(%s)\", n->opcode(), n->name()));"
        },
        {
            "sha": "140d7d626d80300930d49bae64afebc8734d7378",
            "filename": "tensorflow/core/grappler/graph_analyzer/subgraph.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsubgraph.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsubgraph.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsubgraph.h?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -64,7 +64,7 @@ class Subgraph {\n   size_t Hash() const { return hash_; }\n \n   // Dump the subgraph information to a string.\n-  string Dump();\n+  std::string Dump();\n \n   // Extract this subgraph into a separate graph representation for signature\n   // building, that includes only the links between the nodes in the subgraph"
        },
        {
            "sha": "2d6849cafbcb5738bdf35a2c810480adfb9aa6c6",
            "filename": "tensorflow/core/grappler/graph_analyzer/subgraph_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsubgraph_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsubgraph_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Fsubgraph_test.cc?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -120,15 +120,15 @@ TEST(SubgraphTest, Iteration) {\n   {\n     SubgraphIterator sit(&sg);\n     SubgraphIterator sit2(&sg);\n-    std::vector<string> links;\n+    std::vector<std::string> links;\n     for (; !sit.AtEnd(); sit.Next()) {\n       EXPECT_TRUE(sit == sit2);\n       sit2.Next();\n       EXPECT_FALSE(sit == sit2);\n \n-      links.push_back(absl::StrFormat(\"[%s,%s,%s]\", string(sit.GetPort()),\n+      links.push_back(absl::StrFormat(\"[%s,%s,%s]\", std::string(sit.GetPort()),\n                                       sit.GetNeighbor().node->name(),\n-                                      string(sit.GetNeighbor().port)));\n+                                      std::string(sit.GetNeighbor().port)));\n     }\n     EXPECT_TRUE(sit == sit2);\n "
        },
        {
            "sha": "f9cc5cda65a40d2ae468a416e18722c1a5d0b7c0",
            "filename": "tensorflow/core/grappler/graph_analyzer/test_tools.cc",
            "status": "modified",
            "additions": 31,
            "deletions": 27,
            "changes": 58,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Ftest_tools.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Ftest_tools.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Ftest_tools.cc?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -33,15 +33,15 @@ namespace test {\n \n //=== Helper methods to construct the nodes.\n \n-NodeDef MakeNodeConst(const string& name) {\n+NodeDef MakeNodeConst(const std::string& name) {\n   NodeDef n;\n   n.set_name(name);\n   n.set_op(\"Const\");\n   return n;\n }\n \n-NodeDef MakeNode2Arg(const string& name, const string& opcode,\n-                     const string& arg1, const string& arg2) {\n+NodeDef MakeNode2Arg(const std::string& name, const std::string& opcode,\n+                     const std::string& arg1, const std::string& arg2) {\n   NodeDef n;\n   n.set_name(name);\n   n.set_op(opcode);\n@@ -50,9 +50,9 @@ NodeDef MakeNode2Arg(const string& name, const string& opcode,\n   return n;\n }\n \n-NodeDef MakeNode4Arg(const string& name, const string& opcode,\n-                     const string& arg1, const string& arg2, const string& arg3,\n-                     const string& arg4) {\n+NodeDef MakeNode4Arg(const std::string& name, const std::string& opcode,\n+                     const std::string& arg1, const std::string& arg2,\n+                     const std::string& arg3, const std::string& arg4) {\n   NodeDef n;\n   n.set_name(name);\n   n.set_op(opcode);\n@@ -64,77 +64,81 @@ NodeDef MakeNode4Arg(const string& name, const string& opcode,\n }\n \n // Not really a 2-argument but convenient to construct.\n-NodeDef MakeNodeShapeN(const string& name, const string& arg1,\n-                       const string& arg2) {\n+NodeDef MakeNodeShapeN(const std::string& name, const std::string& arg1,\n+                       const std::string& arg2) {\n   // This opcode is multi-input but not commutative.\n   return MakeNode2Arg(name, \"ShapeN\", arg1, arg2);\n }\n \n // Not really a 2-argument but convenient to construct.\n-NodeDef MakeNodeIdentityN(const string& name, const string& arg1,\n-                          const string& arg2) {\n+NodeDef MakeNodeIdentityN(const std::string& name, const std::string& arg1,\n+                          const std::string& arg2) {\n   // The argument is of a list type.\n   return MakeNode2Arg(name, \"IdentityN\", arg1, arg2);\n }\n \n-NodeDef MakeNodeQuantizedConcat(const string& name, const string& arg1,\n-                                const string& arg2, const string& arg3,\n-                                const string& arg4) {\n+NodeDef MakeNodeQuantizedConcat(const std::string& name,\n+                                const std::string& arg1,\n+                                const std::string& arg2,\n+                                const std::string& arg3,\n+                                const std::string& arg4) {\n   // This opcode has multiple multi-inputs.\n   return MakeNode4Arg(name, \"QuantizedConcat\", arg1, arg2, arg3, arg4);\n }\n \n //=== Helper methods for analysing the structures.\n \n-std::vector<string> DumpLinkMap(const GenNode::LinkMap& link_map) {\n+std::vector<std::string> DumpLinkMap(const GenNode::LinkMap& link_map) {\n   // This will order the entries first.\n-  std::map<string, string> ordered;\n+  std::map<std::string, std::string> ordered;\n   for (const auto& link : link_map) {\n-    string key = string(link.first);\n+    std::string key = std::string(link.first);\n \n     // Order the other sides too. They may be repeating, so store them\n     // in a multiset.\n-    std::multiset<string> others;\n+    std::multiset<std::string> others;\n     for (const auto& other : link.second) {\n-      others.emplace(\n-          absl::StrFormat(\"%s[%s]\", other.node->name(), string(other.port)));\n+      others.emplace(absl::StrFormat(\"%s[%s]\", other.node->name(),\n+                                     std::string(other.port)));\n     }\n     ordered[key] = absl::StrJoin(others, \", \");\n   }\n   // Now dump the result in a predictable order.\n-  std::vector<string> result;\n+  std::vector<std::string> result;\n   result.reserve(ordered.size());\n   for (const auto& link : ordered) {\n     result.emplace_back(link.first + \": \" + link.second);\n   }\n   return result;\n }\n \n-std::vector<string> DumpLinkHashMap(const SigNode::LinkHashMap& link_hash_map) {\n+std::vector<std::string> DumpLinkHashMap(\n+    const SigNode::LinkHashMap& link_hash_map) {\n   // The entries in this map are ordered by hash value which might change\n   // at any point. Re-order them by the link tag.\n   std::map<SigNode::LinkTag, size_t> tags;\n   for (const auto& entry : link_hash_map) {\n     tags[entry.second.tag] = entry.first;\n   }\n \n-  std::vector<string> result;\n+  std::vector<std::string> result;\n   for (const auto& id : tags) {\n     // For predictability, the nodes need to be sorted.\n-    std::vector<string> nodes;\n+    std::vector<std::string> nodes;\n     for (const auto& peer : link_hash_map.at(id.second).peers) {\n       nodes.emplace_back(peer->name());\n     }\n     std::sort(nodes.begin(), nodes.end());\n-    result.emplace_back(string(id.first.local) + \":\" + string(id.first.remote) +\n-                        \": \" + absl::StrJoin(nodes, \", \"));\n+    result.emplace_back(std::string(id.first.local) + \":\" +\n+                        std::string(id.first.remote) + \": \" +\n+                        absl::StrJoin(nodes, \", \"));\n   }\n   return result;\n }\n \n-std::vector<string> DumpHashedPeerVector(\n+std::vector<std::string> DumpHashedPeerVector(\n     const SigNode::HashedPeerVector& hashed_peers) {\n-  std::vector<string> result;\n+  std::vector<std::string> result;\n \n   // Each subset of nodes with the same hash has to be sorted by name.\n   // Other than that, the vector is already ordered by full tags."
        },
        {
            "sha": "89c6f146e0ab0109e0a6ccadfc5f16843933d0bd",
            "filename": "tensorflow/core/grappler/graph_analyzer/test_tools.h",
            "status": "modified",
            "additions": 28,
            "deletions": 25,
            "changes": 53,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Ftest_tools.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/36c07984c2dbbd9561106a2666b8d892fa3a9bea/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Ftest_tools.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcore%2Fgrappler%2Fgraph_analyzer%2Ftest_tools.h?ref=36c07984c2dbbd9561106a2666b8d892fa3a9bea",
            "patch": "@@ -33,47 +33,49 @@ namespace test {\n \n //=== Helper methods to construct the nodes.\n \n-NodeDef MakeNodeConst(const string& name);\n+NodeDef MakeNodeConst(const std::string& name);\n \n-NodeDef MakeNode2Arg(const string& name, const string& opcode,\n-                     const string& arg1, const string& arg2);\n+NodeDef MakeNode2Arg(const std::string& name, const std::string& opcode,\n+                     const std::string& arg1, const std::string& arg2);\n \n-NodeDef MakeNode4Arg(const string& name, const string& opcode,\n-                     const string& arg1, const string& arg2, const string& arg3,\n-                     const string& arg4);\n+NodeDef MakeNode4Arg(const std::string& name, const std::string& opcode,\n+                     const std::string& arg1, const std::string& arg2,\n+                     const std::string& arg3, const std::string& arg4);\n \n-inline NodeDef MakeNodeMul(const string& name, const string& arg1,\n-                           const string& arg2) {\n+inline NodeDef MakeNodeMul(const std::string& name, const std::string& arg1,\n+                           const std::string& arg2) {\n   return MakeNode2Arg(name, \"Mul\", arg1, arg2);\n }\n \n // Not really a 2-argument but convenient to construct.\n-inline NodeDef MakeNodeAddN(const string& name, const string& arg1,\n-                            const string& arg2) {\n+inline NodeDef MakeNodeAddN(const std::string& name, const std::string& arg1,\n+                            const std::string& arg2) {\n   return MakeNode2Arg(name, \"AddN\", arg1, arg2);\n }\n \n-inline NodeDef MakeNodeSub(const string& name, const string& arg1,\n-                           const string& arg2) {\n+inline NodeDef MakeNodeSub(const std::string& name, const std::string& arg1,\n+                           const std::string& arg2) {\n   return MakeNode2Arg(name, \"Sub\", arg1, arg2);\n }\n \n // Has 2 honest outputs.\n-inline NodeDef MakeNodeBroadcastGradientArgs(const string& name,\n-                                             const string& arg1,\n-                                             const string& arg2) {\n+inline NodeDef MakeNodeBroadcastGradientArgs(const std::string& name,\n+                                             const std::string& arg1,\n+                                             const std::string& arg2) {\n   return MakeNode2Arg(name, \"BroadcastGradientArgs\", arg1, arg2);\n }\n \n-NodeDef MakeNodeShapeN(const string& name, const string& arg1,\n-                       const string& arg2);\n+NodeDef MakeNodeShapeN(const std::string& name, const std::string& arg1,\n+                       const std::string& arg2);\n \n-NodeDef MakeNodeIdentityN(const string& name, const string& arg1,\n-                          const string& arg2);\n+NodeDef MakeNodeIdentityN(const std::string& name, const std::string& arg1,\n+                          const std::string& arg2);\n \n-NodeDef MakeNodeQuantizedConcat(const string& name, const string& arg1,\n-                                const string& arg2, const string& arg3,\n-                                const string& arg4);\n+NodeDef MakeNodeQuantizedConcat(const std::string& name,\n+                                const std::string& arg1,\n+                                const std::string& arg2,\n+                                const std::string& arg3,\n+                                const std::string& arg4);\n \n //=== A container of pre-constructed graphs.\n \n@@ -106,12 +108,13 @@ class TestGraphs {\n \n //=== Helper methods for analysing the structures.\n \n-std::vector<string> DumpLinkMap(const GenNode::LinkMap& link_map);\n+std::vector<std::string> DumpLinkMap(const GenNode::LinkMap& link_map);\n \n // Also checks for the consistency of hash values.\n-std::vector<string> DumpLinkHashMap(const SigNode::LinkHashMap& link_hash_map);\n+std::vector<std::string> DumpLinkHashMap(\n+    const SigNode::LinkHashMap& link_hash_map);\n \n-std::vector<string> DumpHashedPeerVector(\n+std::vector<std::string> DumpHashedPeerVector(\n     const SigNode::HashedPeerVector& hashed_peers);\n \n }  // end namespace test"
        }
    ],
    "stats": {
        "total": 207,
        "additions": 109,
        "deletions": 98
    }
}