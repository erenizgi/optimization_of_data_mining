{
    "author": "hhb",
    "message": "Add PoisonExecution to PjRtCApiDevice.\n\nPiperOrigin-RevId: 845879114",
    "sha": "336910b0b3387e81c267d5a3be1474c2e38f8a9a",
    "files": [
        {
            "sha": "49e8c858d4d5a8cd679cad654a1a49942c7122f9",
            "filename": "third_party/xla/xla/pjrt/c/CHANGELOG.md",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2FCHANGELOG.md?ref=336910b0b3387e81c267d5a3be1474c2e38f8a9a",
            "patch": "@@ -1,5 +1,9 @@\n # PJRT C API changelog\n \n+## 0.85\n+\n+* Add `PJRT_Device_PoisonExecution`.\n+\n ## 0.84\n \n * Add `PJRT_Buffer_CopyRawToHostFuture`."
        },
        {
            "sha": "eaeb72ce4164c30d5b4a15fc4156b35a8c1ed840",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api.h",
            "status": "modified",
            "additions": 24,
            "deletions": 3,
            "changes": 27,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api.h?ref=336910b0b3387e81c267d5a3be1474c2e38f8a9a",
            "patch": "@@ -104,7 +104,7 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_Extension_Base, next);\n // Changes include:\n // * Adding a new field to the PJRT_Api or argument structs\n // * Renaming a method or argument (doesn't affect ABI)\n-#define PJRT_API_MINOR 84\n+#define PJRT_API_MINOR 85\n \n // The plugin should set the major_version and minor_version of\n // PJRT_Api.pjrt_api_version to be the `PJRT_API_MAJOR` and `PJRT_API_MINOR` in\n@@ -1416,6 +1416,27 @@ PJRT_DEFINE_STRUCT_TRAITS(PJRT_Device_MemoryStats_Args, peak_pool_bytes_is_set);\n // also return PJRT_Error_Code_UNIMPLEMENTED. Intended for diagnostic purposes.\n typedef PJRT_Error* PJRT_Device_MemoryStats(PJRT_Device_MemoryStats_Args* args);\n \n+struct PJRT_Device_PoisonExecution_Args {\n+  size_t struct_size;\n+  PJRT_Extension_Base* extension_start;\n+\n+  PJRT_Device* device;\n+  int32_t launch_id;\n+\n+  // Status fields.\n+  PJRT_Error_Code error_code;\n+  const char* error_message;\n+  size_t error_message_size;\n+\n+  bool poisoned;  // out\n+};\n+PJRT_DEFINE_STRUCT_TRAITS(PJRT_Device_PoisonExecution_Args, poisoned);\n+\n+// Poisons the earliest execution on this device with given launch_id if it's\n+// not finished yet, i.e. makes its output buffers error.\n+typedef PJRT_Error* PJRT_Device_PoisonExecution(\n+    PJRT_Device_PoisonExecution_Args* args);\n+\n //-------------------------------- Memory --------------------------------------\n \n struct PJRT_Memory_Id_Args {\n@@ -2772,11 +2793,11 @@ typedef struct PJRT_Api {\n   _PJRT_API_STRUCT_FIELD(PJRT_Client_CreateErrorBuffer);\n   _PJRT_API_STRUCT_FIELD(PJRT_AsyncHostToDeviceTransferManager_TransferLiteral);\n   _PJRT_API_STRUCT_FIELD(PJRT_Buffer_CopyRawToHostFuture);\n+  _PJRT_API_STRUCT_FIELD(PJRT_Device_PoisonExecution);\n } PJRT_Api;\n \n enum {\n-  PJRT_Api_STRUCT_SIZE =\n-      PJRT_STRUCT_SIZE(PJRT_Api, PJRT_Buffer_CopyRawToHostFuture)\n+  PJRT_Api_STRUCT_SIZE = PJRT_STRUCT_SIZE(PJRT_Api, PJRT_Device_PoisonExecution)\n };\n \n #undef _PJRT_API_STRUCT_FIELD"
        },
        {
            "sha": "fa74c035be033a132269aa686b820f8105031503",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_test.cc",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_test.cc?ref=336910b0b3387e81c267d5a3be1474c2e38f8a9a",
            "patch": "@@ -953,6 +953,9 @@ FieldOffsetsAndSizesForVersion(int major_version, int minor_version) {\n     if (minor_version >= 84) {\n       add_field(\"PJRT_Buffer_CopyRawToHostFuture\", kFnPtrSize);\n     }\n+    if (minor_version >= 85) {\n+      add_field(\"PJRT_Device_PoisonExecution\", kFnPtrSize);\n+    }\n     return version_offsets_and_sizes;\n   }\n   LOG(FATAL) << \"Unsupported API version: \" << major_version << \".\"\n@@ -1355,6 +1358,9 @@ TEST_F(PjrtCAbiTestBase, FieldOffsetsAndSizes) {\n           {\"PJRT_Buffer_CopyRawToHostFuture\",\n            {offsetof(PJRT_Api, PJRT_Buffer_CopyRawToHostFuture),\n             sizeof(PJRT_Api::PJRT_Buffer_CopyRawToHostFuture)}},\n+          {\"PJRT_Device_PoisonExecution\",\n+           {offsetof(PJRT_Api, PJRT_Device_PoisonExecution),\n+            sizeof(PJRT_Api::PJRT_Device_PoisonExecution)}},\n       };\n   ASSERT_EQ(api_->pjrt_api_version.major_version, PJRT_API_MAJOR);\n   ASSERT_EQ(api_->pjrt_api_version.minor_version, PJRT_API_MINOR);"
        },
        {
            "sha": "223f6b0148db4e9bc763da28da1d84752fbe0523",
            "filename": "third_party/xla/xla/pjrt/c/pjrt_c_api_wrapper_impl.cc",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc%2Fpjrt_c_api_wrapper_impl.cc?ref=336910b0b3387e81c267d5a3be1474c2e38f8a9a",
            "patch": "@@ -774,6 +774,21 @@ PJRT_Error* PJRT_AsyncHostToDeviceTransferManager_TransferLiteral(\n   return nullptr;\n }\n \n+PJRT_Error* PJRT_Device_PoisonExecution(\n+    PJRT_Device_PoisonExecution_Args* args) {\n+  PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n+      \"PJRT_Device_PoisonExecution_Args\",\n+      PJRT_Device_PoisonExecution_Args_STRUCT_SIZE, args->struct_size));\n+\n+  absl::Status error = absl::Status(\n+      pjrt::PjrtErrorCodeToStatusCode(args->error_code),\n+      absl::string_view(args->error_message, args->error_message_size));\n+\n+  PJRT_ASSIGN_OR_RETURN(args->poisoned, args->device->device->PoisonExecution(\n+                                            args->launch_id, error));\n+  return nullptr;\n+}\n+\n PJRT_Error* PJRT_AsyncHostToDeviceTransferManager_RetrieveBuffer(\n     PJRT_AsyncHostToDeviceTransferManager_RetrieveBuffer_Args* args) {\n   PJRT_RETURN_IF_ERROR(ActualStructSizeIsGreaterOrEqual(\n@@ -3227,6 +3242,7 @@ PJRT_Api CreatePjrtApi(PJRT_Client_Create* create_fn,\n       pjrt::PJRT_AsyncHostToDeviceTransferManager_TransferLiteral,\n       /*PJRT_Buffer_CopyRawToHostFuture=*/\n       pjrt::PJRT_Buffer_CopyRawToHostFuture,\n+      /*PJRT_Device_PoisonExecution=*/pjrt::PJRT_Device_PoisonExecution,\n   };\n }\n "
        },
        {
            "sha": "263de8a8c3b868790e0bffe479df78f1a78fe80f",
            "filename": "third_party/xla/xla/pjrt/c_api_client/BUILD",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2FBUILD?ref=336910b0b3387e81c267d5a3be1474c2e38f8a9a",
            "patch": "@@ -116,6 +116,7 @@ xla_cc_test(\n         \"//xla:literal_util\",\n         \"//xla:shape_util\",\n         \"//xla:types\",\n+        \"//xla:util\",\n         \"//xla/backends/cpu:alignment\",\n         \"//xla/ffi\",\n         \"//xla/ffi:ffi_api\",\n@@ -134,9 +135,11 @@ xla_cc_test(\n         \"//xla/tests:literal_test_util\",\n         \"//xla/tsl/lib/core:status_test_util\",\n         \"//xla/tsl/platform:env\",\n+        \"//xla/tsl/platform:errors\",\n         \"//xla/tsl/platform:statusor\",\n         \"//xla/tsl/platform:test\",\n         \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n         \"@com_google_absl//absl/strings:str_format\",\n         \"@com_google_absl//absl/synchronization\",\n         \"@com_google_absl//absl/types:span\","
        },
        {
            "sha": "0e727c473edbc6dff303ab9193cf90d95007ad6d",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.cc",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.cc?ref=336910b0b3387e81c267d5a3be1474c2e38f8a9a",
            "patch": "@@ -1720,6 +1720,28 @@ absl::StatusOr<std::intptr_t> PjRtCApiDevice::GetStreamForExternalReadyEvents()\n   return args.stream;\n }\n \n+absl::StatusOr<bool> PjRtCApiDevice::PoisonExecution(int32_t launch_id,\n+                                                     absl::Status error) {\n+  if (client_->pjrt_c_api()->pjrt_api_version.major_version == 0 &&\n+      client_->pjrt_c_api()->pjrt_api_version.minor_version < 85) {\n+    return absl::UnimplementedError(\n+        \"PJRT_Device_PoisonExecution requires PJRT C API version 0.85 or \"\n+        \"higher.\");\n+  }\n+  const PJRT_Api* c_api = client_->pjrt_c_api();\n+  PJRT_Device_PoisonExecution_Args args;\n+  args.struct_size = PJRT_Device_PoisonExecution_Args_STRUCT_SIZE;\n+  args.device = device_;\n+  args.launch_id = launch_id;\n+\n+  args.error_code = pjrt::StatusCodeToPjrtErrorCode(error.code());\n+  args.error_message = error.message().data();\n+  args.error_message_size = error.message().size();\n+\n+  RETURN_STATUS_IF_PJRT_ERROR(c_api->PJRT_Device_PoisonExecution(&args), c_api);\n+  return args.poisoned;\n+}\n+\n // ------------------------------- Memory --------------------------------------\n \n const PJRT_Api* PjRtCApiMemorySpace::pjrt_c_api() const {"
        },
        {
            "sha": "d61987f8b8c23c4d5dd1fee942ce8daef62619a9",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client.h",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client.h?ref=336910b0b3387e81c267d5a3be1474c2e38f8a9a",
            "patch": "@@ -179,6 +179,9 @@ class PjRtCApiDevice : public PjRtDevice {\n     return nullptr;\n   }\n \n+  absl::StatusOr<bool> PoisonExecution(int32_t launch_id,\n+                                       absl::Status error) override;\n+\n   PJRT_Device* c_device() const { return device_; }\n \n   const PjRtCApiDeviceDescription& description() const override {"
        },
        {
            "sha": "caf4bdc409b6f9920f41414f7ec8cb7c76cadf1b",
            "filename": "third_party/xla/xla/pjrt/c_api_client/pjrt_c_api_client_test.cc",
            "status": "modified",
            "additions": 63,
            "deletions": 2,
            "changes": 65,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/336910b0b3387e81c267d5a3be1474c2e38f8a9a/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpjrt%2Fc_api_client%2Fpjrt_c_api_client_test.cc?ref=336910b0b3387e81c267d5a3be1474c2e38f8a9a",
            "patch": "@@ -26,6 +26,7 @@ limitations under the License.\n #include <gmock/gmock.h>\n #include <gtest/gtest.h>\n #include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n #include \"absl/strings/str_format.h\"\n #include \"absl/synchronization/blocking_counter.h\"\n #include \"absl/types/span.h\"\n@@ -58,11 +59,15 @@ limitations under the License.\n #include \"xla/tests/literal_test_util.h\"\n #include \"xla/tsl/lib/core/status_test_util.h\"\n #include \"xla/tsl/platform/env.h\"\n+#include \"xla/tsl/platform/errors.h\"\n #include \"xla/tsl/platform/statusor.h\"\n #include \"xla/tsl/platform/test.h\"\n #include \"xla/tsl/platform/threadpool.h\"\n #include \"xla/types.h\"\n+#include \"xla/util.h\"\n \n+using ::absl_testing::IsOkAndHolds;\n+using ::absl_testing::StatusIs;\n using ::testing::ElementsAreArray;\n using ::testing::HasSubstr;\n \n@@ -668,8 +673,64 @@ TEST(PjRtCApiClientTest, CopyRawToHostFuture) {\n   result = buffer->CopyRawToHostFuture(error_dst_future, 0, size);\n   error_dst_promise.Set(absl::InternalError(\"Future error\"));\n   absl::Status status = result.Await();\n-  EXPECT_EQ(status.code(), absl::StatusCode::kInternal);\n-  EXPECT_EQ(status.message(), \"Future error\");\n+  EXPECT_THAT(status, StatusIs(absl::StatusCode::kInternal, \"Future error\"));\n+}\n+\n+TEST(PjRtCApiClientTest, PoisonExecution) {\n+  SetUpCpuPjRtApi();\n+  ASSERT_OK_AND_ASSIGN(std::unique_ptr<PjRtClient> client,\n+                       GetCApiClient(\"cpu\"));\n+\n+  ASSERT_OK_AND_ASSIGN(auto hlo_module, ParseAndReturnUnverifiedModule(R\"(\n+HloModule Identity\n+ENTRY Identity() -> f32[2, 2] {\n+    ROOT %result = f32[2, 2] parameter(0)\n+})\",\n+                                                                       {}));\n+  XlaComputation xla_computation(hlo_module->ToProto());\n+  ASSERT_OK_AND_ASSIGN(auto pjrt_executable,\n+                       client->CompileAndLoad(xla_computation, {}));\n+\n+  Shape shape = ShapeUtil::MakeShape(F32, {2, 2});\n+  ASSERT_OK_AND_ASSIGN(auto transfer_manager,\n+                       client->CreateBuffersForAsyncHostToDevice(\n+                           {shape}, client->memory_spaces()[0]));\n+  auto buffer = transfer_manager->RetrieveBuffer(0);\n+\n+  const int32_t kLaunchId = 123;\n+  ExecuteOptions opts;\n+  opts.launch_id = kLaunchId;\n+  // PoisonExecution only works for asynchronous executions. Synchronous\n+  // executions are executed inline and will not be poisonable.\n+  opts.execution_mode = ExecuteOptions::ExecutionMode::kAsynchronous;\n+\n+  auto result =\n+      pjrt_executable->Execute(/*argument_handles=*/{{buffer.get()}}, opts);\n+  ASSERT_OK(result);\n+\n+  // Poisoning the execution should succeed because the execution has not\n+  // started with the input buffer not defined yet.\n+  auto poison_result = client->addressable_devices().front()->PoisonExecution(\n+      kLaunchId, Internal(\"foobar1\"));\n+  ASSERT_THAT(poison_result, IsOkAndHolds(true));\n+\n+  // The buffer is expected to be poisoned with the error.\n+  ASSERT_EQ(result->size(), 1);\n+  ASSERT_EQ(result->at(0).size(), 1);\n+  EXPECT_THAT(result->at(0).at(0)->ToLiteral().Await(),\n+              StatusIs(tsl::error::INTERNAL, HasSubstr(\"foobar1\")));\n+\n+  // A later error (propagated from the input buffer) would not affect the\n+  // already poisoned output buffer.\n+  transfer_manager->SetBufferError(0, Internal(\"foobar2\"));\n+\n+  EXPECT_THAT(result->at(0).at(0)->ToLiteral().Await(),\n+              StatusIs(tsl::error::INTERNAL, HasSubstr(\"foobar1\")));\n+\n+  // Attempting to poison a non-existent execution should fail.\n+  poison_result = client->addressable_devices().front()->PoisonExecution(\n+      kLaunchId + 12, Internal(\"foobar3\"));\n+  EXPECT_THAT(poison_result, IsOkAndHolds(false));\n }\n \n }  // namespace"
        }
    ],
    "stats": {
        "total": 146,
        "additions": 141,
        "deletions": 5
    }
}