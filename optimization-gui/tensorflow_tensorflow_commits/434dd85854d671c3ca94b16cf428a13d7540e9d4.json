{
    "author": "tensorflower-gardener",
    "message": "Apply llvm-use-new-mlir-op-builder fixes\n\nThis migrates `builder.create<Op>()` => `Op::create()`\n\nPiperOrigin-RevId: 846268375",
    "sha": "434dd85854d671c3ca94b16cf428a13d7540e9d4",
    "files": [
        {
            "sha": "6559ad29d1f7880ac123c68d2367f79e174b6191",
            "filename": "tensorflow/compiler/mlir/lite/quantization/common/quantization_lib/quantization_utils.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/434dd85854d671c3ca94b16cf428a13d7540e9d4/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fquantization%2Fcommon%2Fquantization_lib%2Fquantization_utils.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/434dd85854d671c3ca94b16cf428a13d7540e9d4/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fquantization%2Fcommon%2Fquantization_lib%2Fquantization_utils.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fcompiler%2Fmlir%2Flite%2Fquantization%2Fcommon%2Fquantization_lib%2Fquantization_utils.h?ref=434dd85854d671c3ca94b16cf428a13d7540e9d4",
            "patch": "@@ -645,8 +645,8 @@ class QuantizationPattern : public RewritePattern {\n             if (!matchPattern(q.getOperand(), m_Constant(&attr))) {\n               continue;\n             }\n-            auto cst = rewriter.create<arith::ConstantOp>(\n-                quantized_op->getLoc(), attr);\n+            auto cst = arith::ConstantOp::create(rewriter,\n+                                                 quantized_op->getLoc(), attr);\n             quantizing_op->setOperand(i, cst.getResult());\n           }\n         }"
        },
        {
            "sha": "cc5e9139c7d976693686dab15ff4c387ed705815",
            "filename": "third_party/xla/xla/mlir_hlo/mhlo/transforms/map_mhlo_to_scalar_op.h",
            "status": "modified",
            "additions": 154,
            "deletions": 149,
            "changes": 303,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/434dd85854d671c3ca94b16cf428a13d7540e9d4/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fmap_mhlo_to_scalar_op.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/434dd85854d671c3ca94b16cf428a13d7540e9d4/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fmap_mhlo_to_scalar_op.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fmlir_hlo%2Fmhlo%2Ftransforms%2Fmap_mhlo_to_scalar_op.h?ref=434dd85854d671c3ca94b16cf428a13d7540e9d4",
            "patch": "@@ -352,7 +352,7 @@ inline Value getConstantOrSplat(OpBuilder* b, Location loc, Type t,\n   if (ShapedType shapedType = mlir::dyn_cast<ShapedType>(t)) {\n     v = SplatElementsAttr::get(shapedType, v);\n   }\n-  return b->create<arith::ConstantOp>(loc, t, cast<TypedAttr>(v));\n+  return arith::ConstantOp::create(*b, loc, t, cast<TypedAttr>(v));\n }\n \n template <typename PredicateType>\n@@ -401,36 +401,36 @@ inline Value cmpComplex(Location loc, Value lhs, Value rhs,\n   auto complexType = mlir::cast<ComplexType>(lhs.getType());\n   if (mlir::isa<FloatType>(complexType.getElementType())) {\n     if (comparisonDirection == ComparisonDirection::EQ) {\n-      return b->create<complex::EqualOp>(loc, lhs, rhs);\n+      return complex::EqualOp::create(*b, loc, lhs, rhs);\n     }\n     if (comparisonDirection == ComparisonDirection::NE) {\n-      return b->create<complex::NotEqualOp>(loc, lhs, rhs);\n+      return complex::NotEqualOp::create(*b, loc, lhs, rhs);\n     }\n \n     // Perform a lexicographical comparison for the (real, imaginary) pair.\n     Type complexFloatTy = complexType.getElementType();\n \n-    Value lhsReal = b->create<complex::ReOp>(loc, complexFloatTy, lhs);\n-    Value rhsReal = b->create<complex::ReOp>(loc, complexFloatTy, rhs);\n+    Value lhsReal = complex::ReOp::create(*b, loc, complexFloatTy, lhs);\n+    Value rhsReal = complex::ReOp::create(*b, loc, complexFloatTy, rhs);\n \n-    Value lhsImag = b->create<complex::ImOp>(loc, complexFloatTy, lhs);\n-    Value rhsImag = b->create<complex::ImOp>(loc, complexFloatTy, rhs);\n+    Value lhsImag = complex::ImOp::create(*b, loc, complexFloatTy, lhs);\n+    Value rhsImag = complex::ImOp::create(*b, loc, complexFloatTy, rhs);\n \n     auto predicate = getCmpPredicate<arith::CmpFPredicate>(comparisonDirection,\n                                                            /*is_signed=*/true);\n     assert(predicate.has_value() && \"expected valid comparison direction\");\n \n     //   if (lhsReal == rhsReal && lhsImag `predicate` rhsImag ||\n     //       lhsReal `predicate` rhsReal)\n-    Value realsAreEq = b->create<arith::CmpFOp>(loc, arith::CmpFPredicate::OEQ,\n-                                                lhsReal, rhsReal);\n+    Value realsAreEq = arith::CmpFOp::create(*b, loc, arith::CmpFPredicate::OEQ,\n+                                             lhsReal, rhsReal);\n     Value imagsAreOrdered =\n-        b->create<arith::CmpFOp>(loc, *predicate, lhsImag, rhsImag);\n+        arith::CmpFOp::create(*b, loc, *predicate, lhsImag, rhsImag);\n     Value realsAreOrdered =\n-        b->create<arith::CmpFOp>(loc, *predicate, lhsReal, rhsReal);\n+        arith::CmpFOp::create(*b, loc, *predicate, lhsReal, rhsReal);\n \n-    Value orLhs = b->create<arith::AndIOp>(loc, realsAreEq, imagsAreOrdered);\n-    return b->create<arith::OrIOp>(loc, orLhs, realsAreOrdered);\n+    Value orLhs = arith::AndIOp::create(*b, loc, realsAreEq, imagsAreOrdered);\n+    return arith::OrIOp::create(*b, loc, orLhs, realsAreOrdered);\n   }\n   return nullptr;\n }\n@@ -459,9 +459,9 @@ inline Value mapMhloOpToStdScalarOp<mhlo::CompareOp>(\n       // -NaN < -Inf < -Finite < -0 < +0 < +Finite < +Inf < +NaN\n       auto intType = b->getIntegerType(floatType.getWidth());\n       auto zero =\n-          b->create<arith::ConstantOp>(loc, intType, b->getZeroAttr(intType));\n-      auto max = b->create<arith::ConstantOp>(\n-          loc, intType,\n+          arith::ConstantOp::create(*b, loc, intType, b->getZeroAttr(intType));\n+      auto max = arith::ConstantOp::create(\n+          *b, loc, intType,\n           b->getIntegerAttr(intType,\n                             APInt::getSignedMaxValue(floatType.getWidth())));\n       // Switch from a floating point value to a integer value in such a way\n@@ -475,19 +475,19 @@ inline Value mapMhloOpToStdScalarOp<mhlo::CompareOp>(\n       // obvious order, -0 is ordered before 0, and -NaN and NaN appear at the\n       // beginning and end of the ordering.\n       auto toIntegral = [&](Value v) {\n-        auto x = b->create<arith::BitcastOp>(loc, intType, v);\n+        auto x = arith::BitcastOp::create(*b, loc, intType, v);\n         auto cmp =\n-            b->create<arith::CmpIOp>(loc, arith::CmpIPredicate::slt, x, zero);\n-        auto sub = b->create<arith::SubIOp>(loc, max, x);\n-        return b->create<arith::SelectOp>(loc, cmp, sub, x);\n+            arith::CmpIOp::create(*b, loc, arith::CmpIPredicate::slt, x, zero);\n+        auto sub = arith::SubIOp::create(*b, loc, max, x);\n+        return arith::SelectOp::create(*b, loc, cmp, sub, x);\n       };\n       auto lhsInt = toIntegral(lhs);\n       auto rhsInt = toIntegral(rhs);\n       auto predicate =\n           getCmpPredicate<arith::CmpIPredicate>(comparisonDirection,\n                                                 /*is_signed=*/true);\n       assert(predicate.has_value() && \"expected valid comparison direction\");\n-      return b->create<arith::CmpIOp>(loc, *predicate, lhsInt, rhsInt);\n+      return arith::CmpIOp::create(*b, loc, *predicate, lhsInt, rhsInt);\n     }\n     std::optional<arith::CmpFPredicate> predicate =\n         getCmpPredicate<arith::CmpFPredicate>(comparisonDirection,\n@@ -574,7 +574,7 @@ inline Value mapMhloOpToStdScalarOp<mhlo::MaxOp>(\n   // 'max' performs a lexicographical comparison for the (real, imaginary) pair.\n   Value cond = cmpComplex(loc, lhs, rhs, ComparisonDirection::GE, b);\n \n-  return b->create<arith::SelectOp>(loc, cond, lhs, rhs).getResult();\n+  return arith::SelectOp::create(*b, loc, cond, lhs, rhs).getResult();\n }\n \n template <>\n@@ -599,7 +599,7 @@ inline Value mapMhloOpToStdScalarOp<mhlo::MinOp>(\n   // 'min' performs a lexicographical comparison for the (real, imaginary) pair.\n   Value cond = cmpComplex(loc, lhs, rhs, ComparisonDirection::LE, b);\n \n-  return b->create<arith::SelectOp>(loc, cond, lhs, rhs).getResult();\n+  return arith::SelectOp::create(*b, loc, cond, lhs, rhs).getResult();\n }\n \n template <>\n@@ -619,8 +619,8 @@ inline Value mapMhloOpToStdScalarOp<mhlo::ImagOp>(\n     mhlo::ImagOp::Adaptor adaptor, ArrayRef<NamedAttribute> attributes,\n     OpBuilder* b) {\n   if (!mlir::isa<ComplexType>(adaptor.getOperand().getType()))\n-    return b->create<arith::ConstantOp>(\n-        loc, b->getZeroAttr(adaptor.getOperand().getType()));\n+    return arith::ConstantOp::create(\n+        *b, loc, b->getZeroAttr(adaptor.getOperand().getType()));\n   return MapMhloOpToScalarOpImpl<complex::ImOp>{}(\n       loc, resultTypes, argTypes, adaptor.getOperands(), attributes, b);\n }\n@@ -646,10 +646,12 @@ inline Value mapConvertOpToStdScalarOp(Location loc, ArrayRef<Type> targetTypes,\n   if (IsUnsignedIntegerType{}(sourceType) &&\n       mlir::arith::UIToFPOp::areCastCompatible(convertedSourceType,\n                                                targetType)) {\n-    return b->create<mlir::arith::UIToFPOp>(loc, resultTypes, args, attributes);\n+    return mlir::arith::UIToFPOp::create(*b, loc, resultTypes, args,\n+                                         attributes);\n   }\n   if (mlir::arith::SIToFPOp::areCastCompatible(sourceType, targetType)) {\n-    return b->create<mlir::arith::SIToFPOp>(loc, resultTypes, args, attributes);\n+    return mlir::arith::SIToFPOp::create(*b, loc, resultTypes, args,\n+                                         attributes);\n   }\n   if (mlir::isa<FloatType>(sourceType) && mlir::isa<FloatType>(targetType)) {\n     if (sourceType == targetType) {\n@@ -662,60 +664,62 @@ inline Value mapConvertOpToStdScalarOp(Location loc, ArrayRef<Type> targetTypes,\n       // There are no ops for conversions between floats of equal width, so we\n       // go through the next-larger standard type.\n       sourceType = dst.getWidth() == 8 ? b->getF16Type() : b->getF32Type();\n-      src = b->create<mlir::arith::ExtFOp>(loc, sourceType, src).getResult();\n+      src = mlir::arith::ExtFOp::create(*b, loc, sourceType, src).getResult();\n     }\n     assert(sourceType.getIntOrFloatBitWidth() != dst.getWidth());\n \n     if (sourceType.getIntOrFloatBitWidth() > dst.getWidth()) {\n-      return b->create<mlir::arith::TruncFOp>(loc, resultTypes, src,\n-                                              attributes);\n+      return mlir::arith::TruncFOp::create(*b, loc, resultTypes, src,\n+                                           attributes);\n     }\n-    return b->create<mlir::arith::ExtFOp>(loc, resultTypes, src, attributes);\n+    return mlir::arith::ExtFOp::create(*b, loc, resultTypes, src, attributes);\n   }\n   if (targetType.isInteger(/*width=*/1)) {\n     // When casting to bool, we need to compare whether the value is equal to\n     // zero.\n     if (sourceType.isSignlessInteger() || sourceType.isUnsignedInteger()) {\n-      Value zeroIntval = b->create<arith::ConstantOp>(\n-          loc, b->getZeroAttr(args.front().getType()));\n-      return b->create<mlir::arith::CmpIOp>(loc, arith::CmpIPredicate::ne,\n-                                            args.front(), zeroIntval);\n+      Value zeroIntval = arith::ConstantOp::create(\n+          *b, loc, b->getZeroAttr(args.front().getType()));\n+      return mlir::arith::CmpIOp::create(*b, loc, arith::CmpIPredicate::ne,\n+                                         args.front(), zeroIntval);\n     }\n     if (mlir::isa<FloatType>(sourceType)) {\n-      Value zero = b->create<arith::ConstantOp>(\n-          loc, b->getZeroAttr(args.front().getType()));\n-      return b->create<mlir::arith::CmpFOp>(loc, arith::CmpFPredicate::UNE,\n-                                            args.front(), zero);\n+      Value zero = arith::ConstantOp::create(\n+          *b, loc, b->getZeroAttr(args.front().getType()));\n+      return mlir::arith::CmpFOp::create(*b, loc, arith::CmpFPredicate::UNE,\n+                                         args.front(), zero);\n     }\n   }\n   if (mlir::isa<IntegerType>(sourceType) &&\n       mlir::isa<IntegerType>(targetType)) {\n     auto src = mlir::cast<IntegerType>(sourceType);\n     auto res = mlir::cast<IntegerType>(targetType);\n     if (src.getWidth() > res.getWidth()) {\n-      return b->create<mlir::arith::TruncIOp>(loc, resultTypes, args,\n-                                              attributes);\n+      return mlir::arith::TruncIOp::create(*b, loc, resultTypes, args,\n+                                           attributes);\n     }\n     if (src.getWidth() < res.getWidth()) {\n       // Special case boolean values, so they get casted to `1` instead of `-1`.\n       if (IsUnsignedIntegerType{}(src)) {\n-        return b->create<mlir::arith::ExtUIOp>(loc, resultTypes, args,\n-                                               attributes);\n+        return mlir::arith::ExtUIOp::create(*b, loc, resultTypes, args,\n+                                            attributes);\n       }\n-      return b->create<mlir::arith::ExtSIOp>(loc, resultTypes, args,\n-                                             attributes);\n+      return mlir::arith::ExtSIOp::create(*b, loc, resultTypes, args,\n+                                          attributes);\n     }\n     // No conversion is needed for the same width integers\n     return args.front();\n   }\n   if (targetType.isUnsignedInteger() &&\n       mlir::arith::FPToUIOp::areCastCompatible(convertedSourceType,\n                                                targetType)) {\n-    return b->create<mlir::arith::FPToUIOp>(loc, resultTypes, args, attributes);\n+    return mlir::arith::FPToUIOp::create(*b, loc, resultTypes, args,\n+                                         attributes);\n   }\n   if (mlir::arith::FPToSIOp::areCastCompatible(convertedSourceType,\n                                                targetType)) {\n-    return b->create<mlir::arith::FPToSIOp>(loc, resultTypes, args, attributes);\n+    return mlir::arith::FPToSIOp::create(*b, loc, resultTypes, args,\n+                                         attributes);\n   }\n   if (mlir::isa<ComplexType>(targetType)) {\n     Type targetElementType =\n@@ -732,12 +736,12 @@ inline Value mapConvertOpToStdScalarOp(Location loc, ArrayRef<Type> targetTypes,\n       assert(!mlir::isa<ComplexType>(sourceElementType) &&\n              \"elements of complex numbers should not be complex\");\n       Value sourceReal =\n-          b->create<mlir::complex::ReOp>(loc, sourceElementType, args.front());\n+          mlir::complex::ReOp::create(*b, loc, sourceElementType, args.front());\n       targetReal = mapConvertOpToStdScalarOp(\n           loc, targetElementType, targetElementType, sourceElementType,\n           sourceReal, attributes, b);\n       Value sourceImag =\n-          b->create<mlir::complex::ImOp>(loc, sourceElementType, args.front());\n+          mlir::complex::ImOp::create(*b, loc, sourceElementType, args.front());\n       targetImag = mapConvertOpToStdScalarOp(\n           loc, targetElementType, targetElementType, sourceElementType,\n           sourceImag, attributes, b);\n@@ -747,18 +751,18 @@ inline Value mapConvertOpToStdScalarOp(Location loc, ArrayRef<Type> targetTypes,\n       targetReal =\n           mapConvertOpToStdScalarOp(loc, targetElementType, targetElementType,\n                                     argTypes, args, attributes, b);\n-      targetImag = b->create<mlir::arith::ConstantOp>(\n-          loc, b->getFloatAttr(targetElementType, 0.0));\n+      targetImag = mlir::arith::ConstantOp::create(\n+          *b, loc, b->getFloatAttr(targetElementType, 0.0));\n     }\n-    return b->create<mlir::complex::CreateOp>(loc, targetType, targetReal,\n-                                              targetImag);\n+    return mlir::complex::CreateOp::create(*b, loc, targetType, targetReal,\n+                                           targetImag);\n   }\n   if (auto sourceComplexType = mlir::dyn_cast<ComplexType>(sourceType)) {\n     auto sourceElementType = sourceComplexType.getElementType();\n     // When converting from complex to a non-complex type, we take just the real\n     // part of the complex number.\n     Value sourceReal =\n-        b->create<mlir::complex::ReOp>(loc, sourceElementType, args.front());\n+        mlir::complex::ReOp::create(*b, loc, sourceElementType, args.front());\n     return mapConvertOpToStdScalarOp(loc, targetTypes, resultTypes,\n                                      sourceElementType, sourceReal, attributes,\n                                      b);\n@@ -780,8 +784,8 @@ inline Value mapMhloOpToStdScalarOp<mhlo::BitcastConvertOp>(\n   if (resultType.getIntOrFloatBitWidth() != argType.getIntOrFloatBitWidth())\n     return nullptr;\n \n-  return b->create<mlir::arith::BitcastOp>(loc, resultTypes,\n-                                           adaptor.getOperands(), attributes);\n+  return mlir::arith::BitcastOp::create(*b, loc, resultTypes,\n+                                        adaptor.getOperands(), attributes);\n }\n \n template <>\n@@ -819,11 +823,11 @@ inline Value mapMhloOpToStdScalarOp<mhlo::IsFiniteOp>(\n   if (mlir::isa<FloatType>(adaptor.getX().getType())) {\n     auto posInf = APFloat::getInf(\n         mlir::cast<FloatType>(adaptor.getX().getType()).getFloatSemantics());\n-    auto constPosInf = b->create<arith::ConstantOp>(\n-        loc, b->getFloatAttr(adaptor.getX().getType(), posInf));\n-    Value absX = b->create<::mlir::math::AbsFOp>(loc, adaptor.getX());\n-    return b->create<::mlir::arith::CmpFOp>(loc, arith::CmpFPredicate::ONE,\n-                                            absX, constPosInf);\n+    auto constPosInf = arith::ConstantOp::create(\n+        *b, loc, b->getFloatAttr(adaptor.getX().getType(), posInf));\n+    Value absX = ::mlir::math::AbsFOp::create(*b, loc, adaptor.getX());\n+    return ::mlir::arith::CmpFOp::create(*b, loc, arith::CmpFPredicate::ONE,\n+                                         absX, constPosInf);\n   }\n   return nullptr;\n }\n@@ -867,13 +871,13 @@ inline Value mhloAlwaysPropagateNaN(Value v, ValueRange args, Location loc,\n                                     OpBuilder* b) {\n   Type elementType = getElementTypeOrSelf(args.front().getType());\n   if (auto floatType = mlir::dyn_cast<FloatType>(elementType)) {\n-    Value isnan = b->create<mlir::arith::CmpFOp>(loc, arith::CmpFPredicate::UNO,\n-                                                 args[0], args[1]);\n+    Value isnan = mlir::arith::CmpFOp::create(\n+        *b, loc, arith::CmpFPredicate::UNO, args[0], args[1]);\n \n     auto nanApfloat = APFloat::getQNaN(floatType.getFloatSemantics());\n     Value nan = getConstantOrSplat(b, loc, args[0].getType(),\n                                    b->getFloatAttr(floatType, nanApfloat));\n-    v = b->create<mlir::arith::SelectOp>(loc, isnan, nan, v);\n+    v = mlir::arith::SelectOp::create(*b, loc, isnan, nan, v);\n   }\n   return v;\n }\n@@ -898,36 +902,36 @@ inline Value makeSafeIntDiv(ImplicitLocOpBuilder& lb, bool isUnsigned,\n                             Value returnedOnSignedOverflow) {\n   Type type = lhs.getType();\n   auto elementType = mlir::cast<IntegerType>(getElementTypeOrSelf(type));\n-  Value zero = lb.create<arith::ConstantOp>(lb.getZeroAttr(type));\n+  Value zero = arith::ConstantOp::create(lb, lb.getZeroAttr(type));\n   auto makeConstant = [&](const APInt& i) {\n     return getConstantOrSplat(&lb, lb.getLoc(), type,\n                               lb.getIntegerAttr(elementType, i));\n   };\n   Value one = makeConstant(APInt(elementType.getWidth(), 1));\n   Value rhsIsZero =\n-      lb.create<arith::CmpIOp>(arith::CmpIPredicate::eq, rhs, zero);\n+      arith::CmpIOp::create(lb, arith::CmpIPredicate::eq, rhs, zero);\n \n   // For unsigned just set the divisor to 1 when it would be 0.\n   if (isUnsigned) {\n-    Value safeRhs = lb.create<arith::SelectOp>(rhsIsZero, one, rhs);\n-    Value safeDiv = lb.create<U>(lhs, safeRhs);\n-    return lb.create<arith::SelectOp>(rhsIsZero, returnedOnZero, safeDiv);\n+    Value safeRhs = arith::SelectOp::create(lb, rhsIsZero, one, rhs);\n+    Value safeDiv = U::create(lb, lhs, safeRhs);\n+    return arith::SelectOp::create(lb, rhsIsZero, returnedOnZero, safeDiv);\n   }\n \n   // For signed also check for INT_MIN / -1.\n   Value smin = makeConstant(APInt::getSignedMinValue(elementType.getWidth()));\n   Value lhsIsSmin =\n-      lb.create<arith::CmpIOp>(arith::CmpIPredicate::eq, lhs, smin);\n+      arith::CmpIOp::create(lb, arith::CmpIPredicate::eq, lhs, smin);\n   Value minusOne = makeConstant(APInt::getAllOnes(elementType.getWidth()));\n   Value rhsIsMinusOne =\n-      lb.create<arith::CmpIOp>(arith::CmpIPredicate::eq, rhs, minusOne);\n-  Value hasIntMinOverflow = lb.create<arith::AndIOp>(lhsIsSmin, rhsIsMinusOne);\n-  Value rhsIsUnsafe = lb.create<arith::OrIOp>(rhsIsZero, hasIntMinOverflow);\n-  Value safeRhs = lb.create<arith::SelectOp>(rhsIsUnsafe, one, rhs);\n-  Value safeDiv = lb.create<S>(lhs, safeRhs);\n-  Value safeSmin = lb.create<arith::SelectOp>(\n-      hasIntMinOverflow, returnedOnSignedOverflow, safeDiv);\n-  return lb.create<arith::SelectOp>(rhsIsZero, returnedOnZero, safeSmin);\n+      arith::CmpIOp::create(lb, arith::CmpIPredicate::eq, rhs, minusOne);\n+  Value hasIntMinOverflow = arith::AndIOp::create(lb, lhsIsSmin, rhsIsMinusOne);\n+  Value rhsIsUnsafe = arith::OrIOp::create(lb, rhsIsZero, hasIntMinOverflow);\n+  Value safeRhs = arith::SelectOp::create(lb, rhsIsUnsafe, one, rhs);\n+  Value safeDiv = S::create(lb, lhs, safeRhs);\n+  Value safeSmin = arith::SelectOp::create(lb, hasIntMinOverflow,\n+                                           returnedOnSignedOverflow, safeDiv);\n+  return arith::SelectOp::create(lb, rhsIsZero, returnedOnZero, safeSmin);\n }\n \n template <>\n@@ -978,7 +982,7 @@ inline Value mapMhloOpToStdScalarOp<mhlo::RemOp>(\n   // INT_SMIN %s -1 = 0\n   ImplicitLocOpBuilder lb(loc, *b);\n   Type type = adaptor.getLhs().getType();\n-  Value zero = lb.create<arith::ConstantOp>(lb.getZeroAttr(type));\n+  Value zero = arith::ConstantOp::create(lb, lb.getZeroAttr(type));\n   return makeSafeIntDiv<arith::RemUIOp, arith::RemSIOp>(\n       lb, originalType.isUnsignedInteger(), adaptor.getLhs(), adaptor.getRhs(),\n       /*returnedOnZero=*/adaptor.getLhs(),\n@@ -1000,7 +1004,7 @@ inline Value mapMhloOpToStdScalarOp<mhlo::NegOp>(\n     // lmhlo.neg(x, result) -> result = sub(0, x)\n     Value lhs = adaptor.getOperand();\n     Value zeroIntval =\n-        b->create<arith::ConstantOp>(loc, b->getZeroAttr(lhs.getType()));\n+        arith::ConstantOp::create(*b, loc, b->getZeroAttr(lhs.getType()));\n     return b->create<ScalarIOp<mhlo::SubtractOp>>(loc, zeroIntval, lhs);\n   }\n   return nullptr;\n@@ -1018,7 +1022,8 @@ inline Value mapMhloOpToStdScalarOp<mhlo::NotOp>(\n         b, loc, adaptor.getOperand().getType(),\n         b->getIntegerAttr(integerType,\n                           APInt::getAllOnes(integerType.getWidth())));\n-    return b->create<::mlir::arith::XOrIOp>(loc, allOnes, adaptor.getOperand());\n+    return ::mlir::arith::XOrIOp::create(*b, loc, allOnes,\n+                                         adaptor.getOperand());\n   }\n   return nullptr;\n }\n@@ -1037,7 +1042,7 @@ inline Value mapMhloOpToStdScalarOp<mhlo::LogisticOp>(\n   Type type = getElementTypeOrSelf(resultTypes[0]);\n   Value oneFloat =\n       mlir::isa<ComplexType>(type)\n-          ? b->create<arith::ConstantOp>(loc, b->getF32FloatAttr(1.0))\n+          ? arith::ConstantOp::create(*b, loc, b->getF32FloatAttr(1.0))\n           : getConstantOrSplat(b, loc, resultTypes[0],\n                                FloatAttr::get(type, 1.0f));\n   Value one = mapConvertOpToStdScalarOp(loc, resultTypes, resultTypes,\n@@ -1067,51 +1072,51 @@ inline Value mapMhloOpToStdScalarOp<mhlo::PowOp>(\n   // Exponentiation by squaring:\n   // https://en.wikipedia.org/wiki/Exponentiation_by_squaring;\n   Value negOne =\n-      lb.create<arith::ConstantOp>(lb.getIntegerAttr(resultType, -1));\n-  Value zero = lb.create<arith::ConstantOp>(lb.getIntegerAttr(resultType, 0));\n-  Value one = lb.create<arith::ConstantOp>(lb.getIntegerAttr(resultType, 1));\n-  Value two = lb.create<arith::ConstantOp>(lb.getIntegerAttr(resultType, 2));\n-  Value step = lb.create<arith::ConstantIndexOp>(1);\n-  Value lowerBound = lb.create<arith::ConstantIndexOp>(0);\n+      arith::ConstantOp::create(lb, lb.getIntegerAttr(resultType, -1));\n+  Value zero = arith::ConstantOp::create(lb, lb.getIntegerAttr(resultType, 0));\n+  Value one = arith::ConstantOp::create(lb, lb.getIntegerAttr(resultType, 1));\n+  Value two = arith::ConstantOp::create(lb, lb.getIntegerAttr(resultType, 2));\n+  Value step = arith::ConstantIndexOp::create(lb, 1);\n+  Value lowerBound = arith::ConstantIndexOp::create(lb, 0);\n   // Everything else would overflow for any exponent > 1, as 2^64\n   // is the larget possible exponent for a 64-bit integer, and\n   // that's 1 << 6.\n-  Value upperBound = lb.create<arith::ConstantIndexOp>(6);\n+  Value upperBound = arith::ConstantIndexOp::create(lb, 6);\n   auto originalBase = adaptor.getLhs();\n   auto originalExponent = adaptor.getRhs();\n \n   Value accum =\n-      lb.create<scf::ForOp>(\n-            lowerBound, upperBound, step,\n-            SmallVector<Value>({one, originalBase, originalExponent}),\n-            [&](OpBuilder& b, Location, Value /*v*/, ValueRange iters) {\n-              Value accum = iters[0];\n-              Value base = iters[1];\n-              Value exponent = iters[2];\n-\n-              Value condition = b.create<arith::CmpIOp>(\n-                  loc, arith::CmpIPredicate::eq,\n-                  b.create<::mlir::arith::AndIOp>(loc, exponent, one), one);\n-              Value multiplied =\n-                  b.create<::mlir::arith::MulIOp>(loc, accum, base);\n-              accum = b.create<::mlir::arith::SelectOp>(loc, condition,\n-                                                        multiplied, accum);\n-              base = b.create<::mlir::arith::MulIOp>(loc, base, base);\n-              exponent = b.create<::mlir::arith::ShRUIOp>(loc, exponent, one);\n-              b.create<scf::YieldOp>(\n-                  loc, SmallVector<Value>({accum, base, exponent}));\n-            })\n+      scf::ForOp::create(\n+          lb, lowerBound, upperBound, step,\n+          SmallVector<Value>({one, originalBase, originalExponent}),\n+          [&](OpBuilder& b, Location, Value /*v*/, ValueRange iters) {\n+            Value accum = iters[0];\n+            Value base = iters[1];\n+            Value exponent = iters[2];\n+\n+            Value condition = arith::CmpIOp::create(\n+                b, loc, arith::CmpIPredicate::eq,\n+                ::mlir::arith::AndIOp::create(b, loc, exponent, one), one);\n+            Value multiplied =\n+                ::mlir::arith::MulIOp::create(b, loc, accum, base);\n+            accum = ::mlir::arith::SelectOp::create(b, loc, condition,\n+                                                    multiplied, accum);\n+            base = ::mlir::arith::MulIOp::create(b, loc, base, base);\n+            exponent = ::mlir::arith::ShRUIOp::create(b, loc, exponent, one);\n+            scf::YieldOp::create(b, loc,\n+                                 SmallVector<Value>({accum, base, exponent}));\n+          })\n           .getResult(0);\n \n-  Value rhsIsEven = lb.create<arith::CmpIOp>(\n-      arith::CmpIPredicate::eq,\n-      lb.create<arith::RemSIOp>(adaptor.getRhs(), two), zero);\n-  Value rhsIsNegative = lb.create<arith::CmpIOp>(arith::CmpIPredicate::slt,\n-                                                 adaptor.getRhs(), zero);\n-  Value lhsIsOne =\n-      lb.create<arith::CmpIOp>(arith::CmpIPredicate::eq, adaptor.getLhs(), one);\n-  Value lhsIsNegOne = lb.create<arith::CmpIOp>(arith::CmpIPredicate::eq,\n-                                               adaptor.getLhs(), negOne);\n+  Value rhsIsEven = arith::CmpIOp::create(\n+      lb, arith::CmpIPredicate::eq,\n+      arith::RemSIOp::create(lb, adaptor.getRhs(), two), zero);\n+  Value rhsIsNegative = arith::CmpIOp::create(lb, arith::CmpIPredicate::slt,\n+                                              adaptor.getRhs(), zero);\n+  Value lhsIsOne = arith::CmpIOp::create(lb, arith::CmpIPredicate::eq,\n+                                         adaptor.getLhs(), one);\n+  Value lhsIsNegOne = arith::CmpIOp::create(lb, arith::CmpIPredicate::eq,\n+                                            adaptor.getLhs(), negOne);\n \n   // The accum is correct when the rhs is non-negative. When rhs is\n   // negative, we return 0 for integer, with the exception of lhs values of 1\n@@ -1122,12 +1127,12 @@ inline Value mapMhloOpToStdScalarOp<mhlo::PowOp>(\n   // - Return 1 or -1 depending on the parity of rhs when the lhs is -1.\n   // - Return 1 if lhs is 1.\n   // - Else return 0.\n-  Value ifLhsIsOne = lb.create<::mlir::arith::SelectOp>(lhsIsOne, one, zero);\n-  Value ifLhsIsNegOne = lb.create<::mlir::arith::SelectOp>(\n-      lhsIsNegOne, lb.create<::mlir::arith::SelectOp>(rhsIsEven, one, negOne),\n-      ifLhsIsOne);\n-  return lb.create<::mlir::arith::SelectOp>(rhsIsNegative, ifLhsIsNegOne,\n-                                            accum);\n+  Value ifLhsIsOne = ::mlir::arith::SelectOp::create(lb, lhsIsOne, one, zero);\n+  Value ifLhsIsNegOne = ::mlir::arith::SelectOp::create(\n+      lb, lhsIsNegOne,\n+      ::mlir::arith::SelectOp::create(lb, rhsIsEven, one, negOne), ifLhsIsOne);\n+  return ::mlir::arith::SelectOp::create(lb, rhsIsNegative, ifLhsIsNegOne,\n+                                         accum);\n }\n \n template <>\n@@ -1148,35 +1153,35 @@ inline Value mapMhloOpToStdScalarOp<mhlo::SignOp>(\n   Type elementType = getElementTypeOrSelf(operand.getType());\n   if (auto floatType = mlir::dyn_cast<FloatType>(elementType)) {\n     Value zero =\n-        b->create<arith::ConstantOp>(loc, b->getZeroAttr(operand.getType()));\n-    Value ne0I1 = b->create<::mlir::arith::CmpFOp>(\n-        loc, arith::CmpFPredicate::ONE, operand, zero);\n+        arith::ConstantOp::create(*b, loc, b->getZeroAttr(operand.getType()));\n+    Value ne0I1 = ::mlir::arith::CmpFOp::create(\n+        *b, loc, arith::CmpFPredicate::ONE, operand, zero);\n     Value ne0Float =\n-        b->create<::mlir::arith::UIToFPOp>(loc, zero.getType(), ne0I1);\n-    Value copySign = b->create<::mlir::math::CopySignOp>(loc, resultTypes,\n-                                                         ne0Float, operand);\n-    auto isNan = b->create<::mlir::arith::CmpFOp>(\n-        loc, arith::CmpFPredicate::UNO, operand, operand);\n-    return b->create<::mlir::arith::SelectOp>(loc, isNan, operand, copySign);\n+        ::mlir::arith::UIToFPOp::create(*b, loc, zero.getType(), ne0I1);\n+    Value copySign = ::mlir::math::CopySignOp::create(*b, loc, resultTypes,\n+                                                      ne0Float, operand);\n+    auto isNan = ::mlir::arith::CmpFOp::create(\n+        *b, loc, arith::CmpFPredicate::UNO, operand, operand);\n+    return ::mlir::arith::SelectOp::create(*b, loc, isNan, operand, copySign);\n   }\n   if (auto integerType = mlir::dyn_cast<IntegerType>(elementType)) {\n     // sign(x) = x == 0 ? 0 : ((x s>> 31) | 1)\n     Value zero =\n-        b->create<arith::ConstantOp>(loc, b->getZeroAttr(operand.getType()));\n+        arith::ConstantOp::create(*b, loc, b->getZeroAttr(operand.getType()));\n     Value bitwidthMinusOne = getConstantOrSplat(\n         b, loc, operand.getType(),\n         b->getIntegerAttr(integerType, integerType.getWidth() - 1));\n     Value one = getConstantOrSplat(b, loc, operand.getType(),\n                                    b->getIntegerAttr(integerType, 1));\n-    Value cmp = b->create<::mlir::arith::CmpIOp>(loc, arith::CmpIPredicate::eq,\n-                                                 operand, zero);\n+    Value cmp = ::mlir::arith::CmpIOp::create(*b, loc, arith::CmpIPredicate::eq,\n+                                              operand, zero);\n     Value ashr =\n-        b->create<::mlir::arith::ShRSIOp>(loc, operand, bitwidthMinusOne);\n-    Value orOp = b->create<::mlir::arith::OrIOp>(loc, ashr, one);\n-    return b->create<::mlir::arith::SelectOp>(loc, cmp, zero, orOp);\n+        ::mlir::arith::ShRSIOp::create(*b, loc, operand, bitwidthMinusOne);\n+    Value orOp = ::mlir::arith::OrIOp::create(*b, loc, ashr, one);\n+    return ::mlir::arith::SelectOp::create(*b, loc, cmp, zero, orOp);\n   }\n   if (mlir::isa<ComplexType>(elementType)) {\n-    return b->create<::mlir::complex::SignOp>(loc, elementType, operand);\n+    return ::mlir::complex::SignOp::create(*b, loc, elementType, operand);\n   }\n   return nullptr;\n }\n@@ -1192,9 +1197,9 @@ inline Value selectShiftedOrSaturated(ImplicitLocOpBuilder& lb, Value rhs,\n   auto bitWidthInt = etype.getIntOrFloatBitWidth();\n   Value bitWidth = getConstantOrSplat(&lb, lb.getLoc(), type,\n                                       lb.getIntegerAttr(etype, bitWidthInt));\n-  Value cmp = lb.create<mlir::arith::CmpIOp>(mlir::arith::CmpIPredicate::ugt,\n-                                             bitWidth, rhs);\n-  return lb.create<mlir::arith::SelectOp>(cmp, shifted, saturated);\n+  Value cmp = mlir::arith::CmpIOp::create(lb, mlir::arith::CmpIPredicate::ugt,\n+                                          bitWidth, rhs);\n+  return mlir::arith::SelectOp::create(lb, cmp, shifted, saturated);\n }\n \n template <>\n@@ -1208,8 +1213,8 @@ inline Value mapMhloOpToStdScalarOp<mhlo::ShiftLeftOp>(\n   Type type = lhs.getType();\n \n   // \"Saturate\" if the shift is greater than the bitwidth of the type\n-  Value zero = lb.create<arith::ConstantOp>(lb.getZeroAttr(type));\n-  Value shifted = lb.create<mlir::arith::ShLIOp>(lhs, rhs);\n+  Value zero = arith::ConstantOp::create(lb, lb.getZeroAttr(type));\n+  Value shifted = mlir::arith::ShLIOp::create(lb, lhs, rhs);\n \n   return selectShiftedOrSaturated(lb, rhs, shifted, zero, type);\n }\n@@ -1225,8 +1230,8 @@ inline Value mapMhloOpToStdScalarOp<mhlo::ShiftRightLogicalOp>(\n   Type type = lhs.getType();\n \n   // \"Saturate\" if the shift is greater than the bitwidth of the type\n-  Value zero = lb.create<arith::ConstantOp>(b->getZeroAttr(type));\n-  Value shifted = lb.create<mlir::arith::ShRUIOp>(lhs, rhs);\n+  Value zero = arith::ConstantOp::create(lb, b->getZeroAttr(type));\n+  Value shifted = mlir::arith::ShRUIOp::create(lb, lhs, rhs);\n \n   return selectShiftedOrSaturated(lb, rhs, shifted, zero, type);\n }\n@@ -1248,8 +1253,8 @@ inline Value mapMhloOpToStdScalarOp<mhlo::ShiftRightArithmeticOp>(\n   // \"Saturate\" if the shift is greater than the bitwidth of the type\n   Value maxShift = getConstantOrSplat(\n       b, loc, type, lb.getIntegerAttr(etype, bitWidthInt - 1));\n-  Value saturatedShifted = lb.create<mlir::arith::ShRSIOp>(lhs, maxShift);\n-  Value shifted = lb.create<mlir::arith::ShRSIOp>(lhs, rhs);\n+  Value saturatedShifted = mlir::arith::ShRSIOp::create(lb, lhs, maxShift);\n+  Value shifted = mlir::arith::ShRSIOp::create(lb, lhs, rhs);\n \n   return selectShiftedOrSaturated(lb, rhs, shifted, saturatedShifted, type);\n }"
        }
    ],
    "stats": {
        "total": 307,
        "additions": 156,
        "deletions": 151
    }
}