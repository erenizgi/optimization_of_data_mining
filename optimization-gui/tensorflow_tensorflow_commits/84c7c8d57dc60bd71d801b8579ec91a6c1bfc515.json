{
    "author": "tensorflower-gardener",
    "message": "Clone manual computation calls before shard map import pass.\n\nIt is to support non-flat graphs as the shard map import pass, which converts the manual computation calls into manual computation ops, requires there is one call for each manual computation function.\n\nPiperOrigin-RevId: 797281155",
    "sha": "84c7c8d57dc60bd71d801b8579ec91a6c1bfc515",
    "files": [
        {
            "sha": "38110112caf8da78cf05a1acbc8546b49e3c71cd",
            "filename": "third_party/xla/xla/service/spmd/shardy/BUILD",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2FBUILD?ref=84c7c8d57dc60bd71d801b8579ec91a6c1bfc515",
            "patch": "@@ -138,6 +138,7 @@ xla_cc_binary(\n         \"//xla/service/spmd/shardy/round_trip_common:import_func_calls\",\n         \"//xla/service/spmd/shardy/round_trip_common:import_sdy_custom_calls\",\n         \"//xla/service/spmd/shardy/round_trip_common:open_while_free_vars_sharding\",\n+        \"//xla/service/spmd/shardy/sdy_round_trip:clone_manual_computation_calls\",\n         \"//xla/service/spmd/shardy/sdy_round_trip:dedup_meshes\",\n         \"//xla/service/spmd/shardy/sdy_round_trip:export_ops\",\n         \"//xla/service/spmd/shardy/sdy_round_trip:export_shardy_attrs\","
        },
        {
            "sha": "0c1580ee9fcfdd9ee194fc7ec0d29b1613237627",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_opt_main.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_opt_main.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_opt_main.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_opt_main.cc?ref=84c7c8d57dc60bd71d801b8579ec91a6c1bfc515",
            "patch": "@@ -27,6 +27,7 @@ limitations under the License.\n #include \"xla/service/spmd/shardy/round_trip_common/import_func_calls.h\"\n #include \"xla/service/spmd/shardy/round_trip_common/import_sdy_custom_calls.h\"\n #include \"xla/service/spmd/shardy/round_trip_common/open_while_free_vars_sharding.h\"\n+#include \"xla/service/spmd/shardy/sdy_round_trip/clone_manual_computation_calls.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/dedup_meshes.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/export_ops.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/export_shardy_attrs.h\"\n@@ -80,6 +81,7 @@ int main(int argc, char** argv) {\n   xla::sdy::registerSdyRoundTripExportPipeline();\n   xla::sdy::registerSdyRoundTripDedupMeshesPass();\n   xla::sdy::registerSdyRoundTripShardMapExportPass();\n+  xla::sdy::registerSdyRoundTripCloneManualComputationCallsPass();\n   xla::sdy::registerSdyRoundTripShardMapImportPass();\n   xla::sdy::registerSdyRoundTripImportPipeline();\n   xla::sdy::registerSdyRoundTripTestingPipeline();"
        },
        {
            "sha": "aff4649000a76e90f896ebe7b075d30f9abf9fdb",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_round_trip/BUILD",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2FBUILD?ref=84c7c8d57dc60bd71d801b8579ec91a6c1bfc515",
            "patch": "@@ -114,6 +114,22 @@ cc_library(\n     ],\n )\n \n+cc_library(\n+    name = \"clone_manual_computation_calls\",\n+    srcs = [\"clone_manual_computation_calls.cc\"],\n+    hdrs = [\"clone_manual_computation_calls.h\"],\n+    deps = [\n+        \"//xla/service/spmd/shardy:constants\",\n+        \"@llvm-project//llvm:Support\",\n+        \"@llvm-project//mlir:FuncDialect\",\n+        \"@llvm-project//mlir:IR\",\n+        \"@llvm-project//mlir:Pass\",\n+        \"@llvm-project//mlir:Support\",\n+        \"@llvm-project//mlir:TransformUtils\",\n+        \"@stablehlo//:stablehlo_ops\",\n+    ],\n+)\n+\n cc_library(\n     name = \"dedup_meshes\",\n     srcs = [\"dedup_meshes.cc\"],\n@@ -135,6 +151,7 @@ cc_library(\n     hdrs = [\"pipelines.h\"],\n     visibility = internal_visibility([\":friends\"]),\n     deps = [\n+        \":clone_manual_computation_calls\",\n         \":dedup_meshes\",\n         \":export_ops\",\n         \":export_shardy_attrs\","
        },
        {
            "sha": "328569843e84fcffd4480143232833df9fa3755e",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_round_trip/clone_manual_computation_calls.cc",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.cc?ref=84c7c8d57dc60bd71d801b8579ec91a6c1bfc515",
            "patch": "@@ -0,0 +1,111 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#include \"xla/service/spmd/shardy/sdy_round_trip/clone_manual_computation_calls.h\"\n+\n+#include <cassert>\n+#include <memory>\n+\n+#include \"llvm/ADT/DenseSet.h\"\n+#include \"llvm/ADT/StringRef.h\"\n+#include \"llvm/Support/Casting.h\"\n+#include \"llvm/Support/ErrorHandling.h\"\n+#include \"mlir/Dialect/Func/IR/FuncOps.h\"\n+#include \"mlir/IR/BuiltinAttributes.h\"\n+#include \"mlir/IR/BuiltinOps.h\"\n+#include \"mlir/IR/Diagnostics.h\"\n+#include \"mlir/IR/DialectRegistry.h\"\n+#include \"mlir/IR/MLIRContext.h\"\n+#include \"mlir/IR/Operation.h\"\n+#include \"mlir/IR/SymbolTable.h\"\n+#include \"mlir/IR/Value.h\"\n+#include \"mlir/IR/Visitors.h\"\n+#include \"mlir/Pass/Pass.h\"\n+#include \"mlir/Pass/PassManager.h\"\n+#include \"mlir/Pass/PassRegistry.h\"\n+#include \"mlir/Support/LLVM.h\"\n+#include \"mlir/Support/TypeID.h\"\n+#include \"mlir/Transforms/DialectConversion.h\"\n+#include \"stablehlo/dialect/StablehloOps.h\"\n+#include \"xla/service/spmd/shardy/constants.h\"\n+\n+namespace xla {\n+namespace sdy {\n+\n+namespace {\n+\n+using ::mlir::ModuleOp;\n+using ::mlir::StringRef;\n+using ::mlir::SymbolTable;\n+using ::mlir::func::CallOp;\n+using ::mlir::func::FuncOp;\n+\n+namespace stablehlo = ::mlir::stablehlo;\n+\n+class SdyRoundTripCloneManualComputationCallsPass\n+    : public mlir::PassWrapper<SdyRoundTripCloneManualComputationCallsPass,\n+                               mlir::OperationPass<ModuleOp>> {\n+ public:\n+  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(\n+      SdyRoundTripCloneManualComputationCallsPass)\n+\n+  void runOnOperation() final {\n+    ModuleOp moduleOp = getOperation();\n+    SymbolTable symbolTable(moduleOp);\n+\n+    // Clone multiple calls to the same function.\n+    llvm::DenseSet<StringRef> seenCalleeNames;\n+    moduleOp->walk([&](CallOp op) {\n+      if (!op.getCallee().contains(kManualComputationBodyFuncName)) {\n+        return;\n+      }\n+      if (seenCalleeNames.insert(op.getCallee()).second) {\n+        return;\n+      }\n+      // TODO(b/430894772): Clone manual computations but with a body just calls\n+      // a newly created shared function with the body of the manual computation\n+      // bodyinstead of copying the body for each cloned manual computation, so\n+      // they can be potentially be deduplicated at the end.\n+      auto funcOp = symbolTable.lookup<FuncOp>(op.getCallee())->clone();\n+      op.setCallee(symbolTable.insert(funcOp));\n+    });\n+  }\n+\n+  StringRef getArgument() const override {\n+    return \"xla-sdy-round-trip-clone-manual-computation-calls\";\n+  }\n+\n+  StringRef getDescription() const override {\n+    return \"Clone xla.sdy.manual_computation_body functions so that each call \"\n+           \"has its own unique function.\";\n+  }\n+  void getDependentDialects(mlir::DialectRegistry& registry) const final {\n+    registry.insert<stablehlo::StablehloDialect>();\n+  }\n+};\n+\n+}  // namespace\n+\n+void registerSdyRoundTripCloneManualComputationCallsPass() {\n+  mlir::registerPass(createSdyRoundTripCloneManualComputationCallsPass);\n+}\n+\n+std::unique_ptr<mlir::Pass>\n+createSdyRoundTripCloneManualComputationCallsPass() {\n+  return std::make_unique<SdyRoundTripCloneManualComputationCallsPass>();\n+}\n+\n+}  // namespace sdy\n+}  // namespace xla"
        },
        {
            "sha": "ef46ea91585681c2780e09477355bb3a71c57ad7",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_round_trip/clone_manual_computation_calls.h",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fclone_manual_computation_calls.h?ref=84c7c8d57dc60bd71d801b8579ec91a6c1bfc515",
            "patch": "@@ -0,0 +1,34 @@\n+/* Copyright 2025 The OpenXLA Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+#ifndef XLA_SERVICE_SPMD_SHARDY_SDY_ROUND_TRIP_CLONE_MANUAL_COMPUTATION_CALLS_H_\n+#define XLA_SERVICE_SPMD_SHARDY_SDY_ROUND_TRIP_CLONE_MANUAL_COMPUTATION_CALLS_H_\n+\n+#include <memory>\n+\n+#include \"mlir/Pass/Pass.h\"\n+\n+namespace xla {\n+namespace sdy {\n+\n+std::unique_ptr<mlir::Pass> createSdyRoundTripCloneManualComputationCallsPass();\n+\n+// Registers the xla-sdy-round-trip-clone-manual-computation-calls pass.\n+void registerSdyRoundTripCloneManualComputationCallsPass();\n+\n+}  // namespace sdy\n+}  // namespace xla\n+\n+#endif  // XLA_SERVICE_SPMD_SHARDY_SDY_ROUND_TRIP_CLONE_MANUAL_COMPUTATION_CALLS_H_"
        },
        {
            "sha": "443ed31d78e146a5c264e0e6f870b1bb86e49f47",
            "filename": "third_party/xla/xla/service/spmd/shardy/sdy_round_trip/pipelines.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fpipelines.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fpipelines.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Fsdy_round_trip%2Fpipelines.cc?ref=84c7c8d57dc60bd71d801b8579ec91a6c1bfc515",
            "patch": "@@ -26,6 +26,7 @@ limitations under the License.\n #include \"shardy/dialect/sdy/transforms/import/passes.h\"\n #include \"xla/service/hlo.pb.h\"\n #include \"xla/service/spmd/shardy/round_trip_common/pipeline_passes.h\"\n+#include \"xla/service/spmd/shardy/sdy_round_trip/clone_manual_computation_calls.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/dedup_meshes.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/export_ops.h\"\n #include \"xla/service/spmd/shardy/sdy_round_trip/export_shardy_attrs.h\"\n@@ -64,6 +65,9 @@ void addSdyRoundTripImportPipeline(mlir::OpPassManager& pm,\n                                    bool liftAndDedupMeshes) {\n   addCommonPreImportPasses(pm, enableConstantImport);\n   pm.addPass(createSdyRoundTripImportShardyAttrsPass());\n+  // TODO(b/430894772): Drop the pass and handle cloning inside shard map import\n+  // pass.\n+  pm.addPass(createSdyRoundTripCloneManualComputationCallsPass());\n   pm.addPass(createSdyRoundTripShardMapImportPass());\n   addCommonPostImportPasses(pm, importFuncCalls,\n                             importOnlyUninlineableFuncCalls);"
        },
        {
            "sha": "4032bd091250118bc5f03adc1738d9931d8ecd3f",
            "filename": "third_party/xla/xla/service/spmd/shardy/test/sdy_round_trip_clone_manual_computation_calls.mlir",
            "status": "added",
            "additions": 128,
            "deletions": 0,
            "changes": 128,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_clone_manual_computation_calls.mlir",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/84c7c8d57dc60bd71d801b8579ec91a6c1bfc515/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_clone_manual_computation_calls.mlir",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fspmd%2Fshardy%2Ftest%2Fsdy_round_trip_clone_manual_computation_calls.mlir?ref=84c7c8d57dc60bd71d801b8579ec91a6c1bfc515",
            "patch": "@@ -0,0 +1,128 @@\n+// RUN: sdy_opt %s -xla-sdy-round-trip-clone-manual-computation-calls -split-input-file 2>&1 | FileCheck %s\n+\n+sdy.mesh @mesh_0 = <[\"a\"=4, \"b\"=2]>\n+\n+// CHECK-LABEL: func @single_manual_comp\n+func.func @single_manual_comp(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>) {\n+  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n+  // CHECK: call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %1 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  return %2 : tensor<8x32xf32>\n+}\n+\n+// CHECK:      func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n+// CHECK-NEXT: }\n+func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}\n+\n+// -----\n+\n+sdy.mesh @mesh_0 = <[\"a\"=4, \"b\"=2]>\n+\n+// CHECK-LABEL: func @using_same_body_func\n+func.func @using_same_body_func(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>) {\n+  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n+  // CHECK: call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %1 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  // CHECK: call @local_xla.sdy.manual_computation_body_0(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %3 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %4 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%3) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  return %4 : tensor<8x32xf32>\n+}\n+\n+// CHECK:      func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n+// CHECK-NEXT: }\n+func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}\n+\n+// CHECK:      func.func @local_xla.sdy.manual_computation_body_0(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n+// CHECK-NEXT: }\n+\n+// -----\n+\n+sdy.mesh @mesh_0 = <[\"a\"=4, \"b\"=2]>\n+\n+// CHECK-LABEL: func @using_different_body_func\n+func.func @using_different_body_func(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>) {\n+  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n+  // CHECK: call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %1 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  // CHECK: call @local_xla.sdy.manual_computation_body_another(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %3 = call @local_xla.sdy.manual_computation_body_another(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %4 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%3) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  return %4 : tensor<8x32xf32>\n+}\n+\n+// CHECK:      func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n+// CHECK-NEXT: }\n+func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}\n+\n+// CHECK:      func.func @local_xla.sdy.manual_computation_body_another(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n+// CHECK-NEXT: }\n+func.func @local_xla.sdy.manual_computation_body_another(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}\n+\n+// -----\n+\n+sdy.mesh @mesh_0 = <[\"a\"=4, \"b\"=2]>\n+\n+// CHECK-LABEL: func @using_same_body_func_potential_name_collision\n+func.func @using_same_body_func_potential_name_collision(%arg0: tensor<8x16xf32>, %arg1: tensor<16x32xf32>) -> (tensor<8x32xf32>) {\n+  %0:2 = stablehlo.custom_call @local_xla.sdy.GlobalToLocalShape(%arg0, %arg1) {mhlo.frontend_attributes = {xla.sdy.in_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {\\22b\\22}]>, <@mesh_0, [{\\22b\\22}, {}], replicated={\\22a\\22}>]>\", xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\"}} : (tensor<8x16xf32>, tensor<16x32xf32>) -> (tensor<2x8xf32>, tensor<8x32xf32>)\n+  // CHECK: call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %1 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %2 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%1) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  // CHECK: call @local_xla.sdy.manual_computation_body_0(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %3 = call @local_xla.sdy.manual_computation_body_0(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %4 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%3) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  // CHECK: call @local_xla.sdy.manual_computation_body_1(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %5 = call @local_xla.sdy.manual_computation_body(%0#0, %0#1) : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  %6 = stablehlo.custom_call @local_xla.sdy.LocalToGlobalShape(%5) {mhlo.frontend_attributes = {xla.sdy.manual_axes = \"#sdy<manual_axes{\\22a\\22, \\22b\\22}>\", xla.sdy.out_shardings = \"#sdy.sharding_per_value<[<@mesh_0, [{\\22a\\22}, {}], replicated={\\22b\\22}>]>\"}} : (tensor<2x32xf32>) -> tensor<8x32xf32>\n+  return %6 : tensor<8x32xf32>\n+}\n+\n+// CHECK:      func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n+// CHECK-NEXT: }\n+func.func @local_xla.sdy.manual_computation_body(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}\n+\n+// CHECK:      func.func @local_xla.sdy.manual_computation_body_0(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n+// CHECK-NEXT: }\n+func.func @local_xla.sdy.manual_computation_body_0(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+  %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+  return %0 : tensor<2x32xf32>\n+}\n+\n+// CHECK:      func.func @local_xla.sdy.manual_computation_body_1(%arg0: tensor<2x8xf32>, %arg1: tensor<8x32xf32>) -> tensor<2x32xf32> {\n+// CHECK-NEXT:   %0 = stablehlo.dot %arg0, %arg1 : (tensor<2x8xf32>, tensor<8x32xf32>) -> tensor<2x32xf32>\n+// CHECK-NEXT:   return %0 : tensor<2x32xf32>\n+// CHECK-NEXT: }\n+"
        }
    ],
    "stats": {
        "total": 297,
        "additions": 297,
        "deletions": 0
    }
}