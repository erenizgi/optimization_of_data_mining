{
    "author": "tensorflower-gardener",
    "message": "add a Get method to attribute_map\n\nallowing for easier value access\n\nPiperOrigin-RevId: 811657204",
    "sha": "bd0c58359a462f27e38d146955eacf94bd5a5566",
    "files": [
        {
            "sha": "025851f5c5ceca7fb42a668a84c99b6c2ac15c75",
            "filename": "third_party/xla/xla/python/ifrt/BUILD",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bd0c58359a462f27e38d146955eacf94bd5a5566/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bd0c58359a462f27e38d146955eacf94bd5a5566/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2FBUILD?ref=bd0c58359a462f27e38d146955eacf94bd5a5566",
            "patch": "@@ -164,6 +164,7 @@ cc_library(\n         \"@com_google_absl//absl/status\",\n         \"@com_google_absl//absl/status:statusor\",\n         \"@com_google_absl//absl/strings\",\n+        \"@com_google_absl//absl/types:span\",\n     ],\n )\n \n@@ -176,6 +177,10 @@ xla_cc_test(\n         \":serdes_test_util\",\n         \":serdes_version\",\n         \"//xla/tsl/platform:statusor\",\n+        \"@com_google_absl//absl/status\",\n+        \"@com_google_absl//absl/status:status_matchers\",\n+        \"@com_google_absl//absl/strings:string_view\",\n+        \"@com_google_absl//absl/types:span\",\n         \"@com_google_googletest//:gtest_main\",\n     ],\n )"
        },
        {
            "sha": "a8c9f11c8d49a973e74bae9b4d26945752b25eb7",
            "filename": "third_party/xla/xla/python/ifrt/attribute_map.h",
            "status": "modified",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bd0c58359a462f27e38d146955eacf94bd5a5566/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bd0c58359a462f27e38d146955eacf94bd5a5566/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map.h?ref=bd0c58359a462f27e38d146955eacf94bd5a5566",
            "patch": "@@ -19,12 +19,17 @@ limitations under the License.\n #include <cstddef>\n #include <cstdint>\n #include <string>\n+#include <type_traits>\n #include <utility>\n #include <variant>\n #include <vector>\n \n #include \"absl/container/flat_hash_map.h\"\n+#include \"absl/status/status.h\"\n #include \"absl/status/statusor.h\"\n+#include \"absl/strings/str_cat.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n #include \"xla/python/ifrt/attribute_map.pb.h\"\n #include \"xla/python/ifrt/serdes_default_version_accessor.h\"\n #include \"xla/python/ifrt/serdes_version.h\"\n@@ -86,6 +91,25 @@ class AttributeMap {\n \n   const Map& map() const { return map_; }\n \n+  template <typename T>\n+  absl::StatusOr<T> Get(const std::string& key) const {\n+    if constexpr (std::is_same_v<T, std::string> ||\n+                  std::is_same_v<T, absl::string_view>) {\n+      return Get<T, StringValue>(key);\n+    } else if constexpr (std::is_same_v<T, bool>) {\n+      return Get<T, BoolValue>(key);\n+    } else if constexpr (std::is_same_v<T, int64_t>) {\n+      return Get<T, Int64Value>(key);\n+    } else if constexpr (std::is_same_v<T, std::vector<int64_t>> ||\n+                         std::is_same_v<T, absl::Span<const int64_t>>) {\n+      return Get<T, Int64ListValue>(key);\n+    } else if constexpr (std::is_same_v<T, float>) {\n+      return Get<T, FloatValue>(key);\n+    } else {\n+      static_assert(false, \"Unsupported type for AttributeMap::Get\");\n+    }\n+  }\n+\n   // Deserializes `AttributeMapProto` into `AttributeMap`.\n   static absl::StatusOr<AttributeMap> FromProto(const AttributeMapProto& proto);\n \n@@ -102,6 +126,20 @@ class AttributeMap {\n   }\n \n  private:\n+  template <typename T, typename V>\n+  absl::StatusOr<T> Get(const std::string& key) const {\n+    auto it = map_.find(key);\n+    if (it == map_.end()) {\n+      return absl::NotFoundError(absl::StrCat(\"Key not found: \", key));\n+    }\n+    const V* value = std::get_if<V>(&it->second);\n+    if (value == nullptr) {\n+      return absl::InvalidArgumentError(\n+          absl::StrCat(\"Value type mismatch for key: \", key));\n+    }\n+    return value->value;\n+  }\n+\n   Map map_;\n };\n "
        },
        {
            "sha": "96069fdfb6ee74ecc749cc563d37e1268bd07e6b",
            "filename": "third_party/xla/xla/python/ifrt/attribute_map_test.cc",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/bd0c58359a462f27e38d146955eacf94bd5a5566/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/bd0c58359a462f27e38d146955eacf94bd5a5566/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt%2Fattribute_map_test.cc?ref=bd0c58359a462f27e38d146955eacf94bd5a5566",
            "patch": "@@ -19,7 +19,12 @@ limitations under the License.\n #include <string>\n #include <vector>\n \n+#include <gmock/gmock.h>\n #include <gtest/gtest.h>\n+#include \"absl/status/status.h\"\n+#include \"absl/status/status_matchers.h\"\n+#include \"absl/strings/string_view.h\"\n+#include \"absl/types/span.h\"\n #include \"xla/python/ifrt/serdes_test_util.h\"\n #include \"xla/python/ifrt/serdes_version.h\"\n #include \"xla/tsl/platform/statusor.h\"\n@@ -28,6 +33,10 @@ namespace xla {\n namespace ifrt {\n namespace {\n \n+using ::absl_testing::IsOkAndHolds;\n+using ::absl_testing::StatusIs;\n+using ::testing::HasSubstr;\n+\n TEST(AttributeMapTest, MapElements) {\n   AttributeMap map({\n       {\"string\", AttributeMap::StringValue(\"value\")},\n@@ -48,6 +57,33 @@ TEST(AttributeMapTest, MapElements) {\n       << map.DebugString();\n }\n \n+TEST(AttributeMapTest, Get) {\n+  AttributeMap map({\n+      {\"string\", AttributeMap::StringValue(\"value\")},\n+      {\"bool\", AttributeMap::BoolValue(true)},\n+      {\"int64\", AttributeMap::Int64Value(123)},\n+      {\"int64_list\", AttributeMap::Int64ListValue({int64_t{1}, int64_t{2}})},\n+      {\"float\", AttributeMap::FloatValue(1.23f)},\n+  });\n+\n+  EXPECT_THAT(map.Get<std::string>(\"string\"), IsOkAndHolds(\"value\"));\n+  EXPECT_THAT(map.Get<absl::string_view>(\"string\"), IsOkAndHolds(\"value\"));\n+  EXPECT_THAT(map.Get<bool>(\"bool\"), IsOkAndHolds(true));\n+  EXPECT_THAT(map.Get<int64_t>(\"int64\"), IsOkAndHolds(123));\n+  EXPECT_THAT(map.Get<std::vector<int64_t>>(\"int64_list\"),\n+              IsOkAndHolds(std::vector<int64_t>{1, 2}));\n+  EXPECT_THAT(map.Get<absl::Span<const int64_t>>(\"int64_list\"),\n+              IsOkAndHolds(std::vector<int64_t>{1, 2}));\n+  EXPECT_THAT(map.Get<float>(\"float\"), IsOkAndHolds(1.23f));\n+\n+  EXPECT_THAT(map.Get<std::string>(\"float\"),\n+              StatusIs(absl::StatusCode::kInvalidArgument,\n+                       HasSubstr(\"Value type mismatch for key: float\")));\n+  EXPECT_THAT(map.Get<absl::Span<const int64_t>>(\"string\"),\n+              StatusIs(absl::StatusCode::kInvalidArgument,\n+                       HasSubstr(\"Value type mismatch for key: string\")));\n+}\n+\n class AttributeMapSerDesTest : public testing::TestWithParam<SerDesVersion> {\n  public:\n   AttributeMapSerDesTest() : version_(GetParam()) {}"
        }
    ],
    "stats": {
        "total": 79,
        "additions": 79,
        "deletions": 0
    }
}