{
    "author": "ezhulenev",
    "message": "[xla:ifrt] Replace Future::OnReady with Future::Map\n\nPiperOrigin-RevId: 817838912",
    "sha": "1783c8cccfc34694829c5ddff2903e02adcd79ae",
    "files": [
        {
            "sha": "c9fd9eaabe3ffa879fc1bac1aaf82a764fa0f24c",
            "filename": "third_party/xla/xla/python/ifrt_proxy/server/ifrt_backend.cc",
            "status": "modified",
            "additions": 35,
            "deletions": 79,
            "changes": 114,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/1783c8cccfc34694829c5ddff2903e02adcd79ae/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/1783c8cccfc34694829c5ddff2903e02adcd79ae/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fpython%2Fifrt_proxy%2Fserver%2Fifrt_backend.cc?ref=1783c8cccfc34694829c5ddff2903e02adcd79ae",
            "patch": "@@ -794,24 +794,12 @@ tsl::Future<BackendInterface::Response> IfrtBackend::HandleCheckFutureRequest(\n     futures_.erase(it);\n   }\n \n-  auto [promise, resp_future] =\n-      tsl::Future<BackendInterface::Response>::MakePromise();\n-  // With Future, the `future` needs to be owned by one or more owners until\n-  // `OnReady()`'s lambda gets executed. So, capture a copy of `future` in the\n-  // lambda, making the lambda itself an owner of `future`.\n-  future.OnReady([op_id = request->request_metadata().op_id(),\n-                  promise = std::move(promise),\n-                  hold = future](absl::Status status) mutable {\n-    if (!status.ok()) {\n-      promise.Set(std::move(status));\n-      return;\n-    }\n-    auto ifrt_resp = NewIfrtResponse(op_id);\n-    ifrt_resp->mutable_check_future_response();\n-    promise.Set(std::move(ifrt_resp));\n-  });\n-\n-  return std::move(resp_future);\n+  return future.Map<BackendInterface::Response>(\n+      [op_id = request->request_metadata().op_id()] {\n+        auto ifrt_resp = NewIfrtResponse(op_id);\n+        ifrt_resp->mutable_check_future_response();\n+        return ifrt_resp;\n+      });\n }\n \n tsl::Future<BackendInterface::Response>\n@@ -830,22 +818,12 @@ IfrtBackend::HandleCheckValueReadyRequest(\n     values.push_back(*std::move(array));\n   }\n \n-  auto [ifrt_response_promise, ifrt_response_future] =\n-      tsl::Future<BackendInterface::Response>::MakePromise();\n-\n-  client_->GetReadyFuture(values).OnReady(\n-      [op_id = request->request_metadata().op_id(),\n-       promise = std::move(ifrt_response_promise)](\n-          absl::Status status) mutable -> void {\n-        if (!status.ok()) {\n-          promise.Set(std::move(status));\n-          return;\n-        }\n+  return client_->GetReadyFuture(values).Map<BackendInterface::Response>(\n+      [op_id = request->request_metadata().op_id()] {\n         auto ifrt_response = NewIfrtResponse(op_id);\n         ifrt_response->mutable_check_value_ready_response();\n-        promise.Set(std::move(ifrt_response));\n+        return ifrt_response;\n       });\n-  return std::move(ifrt_response_future);\n }\n \n absl::StatusOr<BackendInterface::Response>\n@@ -1110,38 +1088,25 @@ IfrtBackend::HandleCopyToStringHostBufferRequest(\n   // Allocate the host buffer and start the copy.\n   auto host_buffer = std::make_unique<std::vector<absl::Cord>>(\n       (*array)->shape().num_elements());\n-  tsl::Future<> copy_status = (*array)->CopyToHostBuffer(\n+  tsl::Future<> copy_done = (*array)->CopyToHostBuffer(\n       host_buffer->data(), /*byte_strides=*/std::nullopt,\n       ArrayCopySemantics::kAlwaysCopy);\n \n-  auto [resp_promise, resp_future] =\n-      tsl::Future<BackendInterface::Response>::MakePromise();\n-\n   // Make the response proto when the copy is done.\n-  auto response_maker =\n+  return copy_done.Map(\n       [this, op_id = request->request_metadata().op_id(),\n        host_buffer = std::move(host_buffer),\n-       host_buffer_handle =\n-           copy_to_host.host_buffer_handle()](absl::Status status) mutable\n-      -> absl::StatusOr<std::unique_ptr<IfrtResponse>> {\n-    TF_RETURN_IF_ERROR(status);\n-\n-    TF_ASSIGN_OR_RETURN(auto serialized_string_host_buffer,\n-                        SerializeStringHostBuffer(*host_buffer));\n-    TF_RETURN_IF_ERROR(host_buffer_store_->Store(\n-        host_buffer_handle, std::move(*serialized_string_host_buffer)));\n-\n-    std::unique_ptr<IfrtResponse> response = NewIfrtResponse(op_id);\n-    response->mutable_copy_to_host_buffer_response();\n-    return response;\n-  };\n-  copy_status.OnReady([promise = std::move(resp_promise),\n-                       response_maker = std::move(response_maker)](\n-                          absl::Status status) mutable {\n-    promise.Set(response_maker(status));\n-  });\n-\n-  return std::move(resp_future);\n+       host_buffer_handle = copy_to_host.host_buffer_handle()]()\n+          -> absl::StatusOr<BackendInterface::Response> {\n+        TF_ASSIGN_OR_RETURN(auto serialized_string_host_buffer,\n+                            SerializeStringHostBuffer(*host_buffer));\n+        TF_RETURN_IF_ERROR(host_buffer_store_->Store(\n+            host_buffer_handle, std::move(*serialized_string_host_buffer)));\n+\n+        std::unique_ptr<IfrtResponse> response = NewIfrtResponse(op_id);\n+        response->mutable_copy_to_host_buffer_response();\n+        return response;\n+      });\n }\n \n tsl::Future<BackendInterface::Response>\n@@ -1188,31 +1153,22 @@ IfrtBackend::HandleCopyToHostBufferRequest(\n   }\n \n   // TODO(b/282757875): Consider other ArrayCopySemantics.\n-  tsl::Future<> copy_status =\n+  tsl::Future<> copy_done =\n       (*array)->CopyToHostBuffer(mem_region->zeroth_element(), byte_strides,\n                                  ArrayCopySemantics::kAlwaysCopy);\n \n-  auto [resp_promise, resp_future] =\n-      tsl::Future<BackendInterface::Response>::MakePromise();\n-  auto on_ready = [this, op_id = request->request_metadata().op_id(),\n-                   host_buffer = std::move(host_buffer),\n-                   host_buffer_handle = copy_to_host.host_buffer_handle()](\n-                      absl::Status status) mutable\n-      -> absl::StatusOr<std::unique_ptr<IfrtResponse>> {\n-    TF_RETURN_IF_ERROR(status);\n-\n-    TF_RETURN_IF_ERROR(\n-        host_buffer_store_->Store(host_buffer_handle, *std::move(host_buffer)));\n-\n-    std::unique_ptr<IfrtResponse> response = NewIfrtResponse(op_id);\n-    response->mutable_copy_to_host_buffer_response();\n-    return response;\n-  };\n-  copy_status.OnReady(\n-      [promise = std::move(resp_promise), on_ready = std::move(on_ready)](\n-          absl::Status status) mutable { promise.Set(on_ready(status)); });\n-\n-  return std::move(resp_future);\n+  return copy_done.Map(\n+      [this, op_id = request->request_metadata().op_id(),\n+       host_buffer = std::move(host_buffer),\n+       host_buffer_handle = copy_to_host.host_buffer_handle()]()\n+          -> absl::StatusOr<BackendInterface::Response> {\n+        TF_RETURN_IF_ERROR(host_buffer_store_->Store(host_buffer_handle,\n+                                                     *std::move(host_buffer)));\n+\n+        std::unique_ptr<IfrtResponse> response = NewIfrtResponse(op_id);\n+        response->mutable_copy_to_host_buffer_response();\n+        return response;\n+      });\n }\n \n absl::StatusOr<BackendInterface::Response>"
        }
    ],
    "stats": {
        "total": 114,
        "additions": 35,
        "deletions": 79
    }
}