{
    "author": "allanrenucci",
    "message": "[NFC] Rewrite `tsl::strings::{StrCat,StrAppend}` using `absl::{StrCat,StrAppend}`.\n\nPiperOrigin-RevId: 803352129",
    "sha": "07dcc5f8b12e9321df688ec5c9ab0a2581f6750f",
    "files": [
        {
            "sha": "62b2557290f7805e6d7c9fe1a31f29dbed690b6c",
            "filename": "tensorflow/python/_pywrap_tensorflow.def",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/07dcc5f8b12e9321df688ec5c9ab0a2581f6750f/tensorflow%2Fpython%2F_pywrap_tensorflow.def",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/07dcc5f8b12e9321df688ec5c9ab0a2581f6750f/tensorflow%2Fpython%2F_pywrap_tensorflow.def",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/tensorflow%2Fpython%2F_pywrap_tensorflow.def?ref=07dcc5f8b12e9321df688ec5c9ab0a2581f6750f",
            "patch": "@@ -217,7 +217,6 @@ EXPORTS\n   ?Build@KernelDefBuilder@tensorflow@@QEAAPEBVKernelDef@2@XZ\n   ?Canonicalize@FunctionParameterCanonicalizer@tensorflow@@QEAA_NPEAU_object@@0V?$Span@PEAU_object@@@lts_20250512@absl@@@Z\n   ?Capture@StackTrace@tensorflow@@SA?AV?$shared_ptr@VStackTrace@tensorflow@@@std@@H@Z\n-  ?CatPieces@internal@strings@tsl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$initializer_list@V?$basic_string_view@DU?$char_traits@D@std@@@std@@@5@@Z\n   ?CatPieces@strings_internal@lts_20250512@absl@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$initializer_list@V?$basic_string_view@DU?$char_traits@D@std@@@std@@@5@@Z\n   ?Check@PyListChecker@py_dispatch@tensorflow@@UEAA?AW4MatchType@PyTypeChecker@23@PEAU_object@@@Z\n   ?Check@PyUnionChecker@py_dispatch@tensorflow@@UEAA?AW4MatchType@PyTypeChecker@23@PEAU_object@@@Z"
        },
        {
            "sha": "2511d1ac41acdf12238217b2858917ad492753b1",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/BUILD",
            "status": "modified",
            "additions": 0,
            "deletions": 19,
            "changes": 19,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/07dcc5f8b12e9321df688ec5c9ab0a2581f6750f/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2FBUILD",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/07dcc5f8b12e9321df688ec5c9ab0a2581f6750f/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2FBUILD",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2FBUILD?ref=07dcc5f8b12e9321df688ec5c9ab0a2581f6750f",
            "patch": "@@ -458,7 +458,6 @@ filegroup(\n         \"statusor.h\",\n         \"str_util.cc\",\n         \"str_util.h\",\n-        \"strcat.cc\",\n         \"strcat.h\",\n         \"stringpiece.h\",\n         \"stringprintf.cc\",\n@@ -774,7 +773,6 @@ cc_library(\n \n cc_library(\n     name = \"strcat\",\n-    srcs = [\"strcat.cc\"],\n     hdrs = [\"strcat.h\"],\n     deps = [\n         \":numbers\",\n@@ -1368,23 +1366,6 @@ tsl_cc_test(\n     ],\n )\n \n-tsl_cc_test(\n-    name = \"strcat_test\",\n-    size = \"small\",\n-    srcs = [\n-        \"strcat_test.cc\",\n-    ],\n-    deps = [\n-        \":bfloat16\",\n-        \":strcat\",\n-        \":stringprintf\",\n-        \"@com_google_absl//absl/strings\",\n-        \"@com_google_googletest//:gtest_main\",\n-        \"@local_xla//xla/tsl/platform:test\",\n-        \"@local_xla//xla/tsl/platform:types\",\n-    ],\n-)\n-\n tsl_cc_test(\n     name = \"stringpiece_test\",\n     size = \"small\","
        },
        {
            "sha": "24f533bed5a173877374b9ab6f2b40a9b4486598",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/strcat.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 267,
            "changes": 267,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4cd5088297479ae63bab2a63e581a6d1b871eaf1/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fstrcat.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4cd5088297479ae63bab2a63e581a6d1b871eaf1/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fstrcat.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fstrcat.cc?ref=4cd5088297479ae63bab2a63e581a6d1b871eaf1",
            "patch": "@@ -1,267 +0,0 @@\n-/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"tsl/platform/strcat.h\"\n-\n-#include <stdarg.h>\n-#include <stdint.h>\n-#include <stdio.h>\n-#include <string.h>\n-\n-#include <algorithm>\n-#include <initializer_list>\n-#include <string>\n-\n-#include \"absl/meta/type_traits.h\"\n-#include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/string_view.h\"\n-#include \"xla/tsl/platform/logging.h\"\n-\n-namespace tsl {\n-namespace strings {\n-\n-\n-// ----------------------------------------------------------------------\n-// StrCat()\n-//    This merges the given strings or integers, with no delimiter.  This\n-//    is designed to be the fastest possible way to construct a string out\n-//    of a mix of raw C strings, StringPieces, strings, and integer values.\n-// ----------------------------------------------------------------------\n-\n-// Append is merely a version of memcpy that returns the address of the byte\n-// after the area just overwritten.  It comes in multiple flavors to minimize\n-// call overhead.\n-static char* Append1(char* out, const absl::AlphaNum& x) {\n-  if (x.data() == nullptr) return out;\n-\n-  memcpy(out, x.data(), x.size());\n-  return out + x.size();\n-}\n-\n-static char* Append2(char* out, const absl::AlphaNum& x1,\n-                     const absl::AlphaNum& x2) {\n-  if (x1.data() != nullptr) {\n-    memcpy(out, x1.data(), x1.size());\n-    out += x1.size();\n-  }\n-\n-  if (x2.data() == nullptr) return out;\n-\n-  memcpy(out, x2.data(), x2.size());\n-  return out + x2.size();\n-}\n-\n-static char* Append4(char* out, const absl::AlphaNum& x1,\n-                     const absl::AlphaNum& x2, const absl::AlphaNum& x3,\n-                     const absl::AlphaNum& x4) {\n-  if (x1.data() != nullptr) {\n-    memcpy(out, x1.data(), x1.size());\n-    out += x1.size();\n-  }\n-\n-  if (x2.data() != nullptr) {\n-    memcpy(out, x2.data(), x2.size());\n-    out += x2.size();\n-  }\n-\n-  if (x3.data() != nullptr) {\n-    memcpy(out, x3.data(), x3.size());\n-    out += x3.size();\n-  }\n-\n-  if (x4.data() == nullptr) return out;\n-\n-  memcpy(out, x4.data(), x4.size());\n-  return out + x4.size();\n-}\n-\n-std::string StrCat(const absl::AlphaNum& a) {\n-  return std::string(a.data(), a.size());\n-}\n-\n-std::string StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b) {\n-  std::string result(a.size() + b.size(), '\\0');\n-  char *const begin = &*result.begin();\n-  char *out = Append2(begin, a, b);\n-  DCHECK_EQ(out, begin + result.size());\n-  return result;\n-}\n-\n-std::string StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b,\n-                   const absl::AlphaNum& c) {\n-  std::string result(a.size() + b.size() + c.size(), '\\0');\n-  char *const begin = &*result.begin();\n-  char *out = Append2(begin, a, b);\n-  out = Append1(out, c);\n-  DCHECK_EQ(out, begin + result.size());\n-  return result;\n-}\n-\n-std::string StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b,\n-                   const absl::AlphaNum& c, const absl::AlphaNum& d) {\n-  std::string result(a.size() + b.size() + c.size() + d.size(), '\\0');\n-  char *const begin = &*result.begin();\n-  char *out = Append4(begin, a, b, c, d);\n-  DCHECK_EQ(out, begin + result.size());\n-  return result;\n-}\n-\n-namespace {\n-// HasMember is true_type or false_type, depending on whether or not\n-// T has a __resize_default_init member. Resize will call the\n-// __resize_default_init member if it exists, and will call the resize\n-// member otherwise.\n-template <typename string_type, typename = void>\n-struct ResizeUninitializedTraits {\n-  using HasMember = std::false_type;\n-  static void Resize(string_type *s, size_t new_size) { s->resize(new_size); }\n-};\n-\n-// __resize_default_init is provided by libc++ >= 8.0.\n-template <typename string_type>\n-struct ResizeUninitializedTraits<\n-    string_type, absl::void_t<decltype(std::declval<string_type &>()\n-                                           .__resize_default_init(237))> > {\n-  using HasMember = std::true_type;\n-  static void Resize(string_type *s, size_t new_size) {\n-    s->__resize_default_init(new_size);\n-  }\n-};\n-\n-static inline void STLStringResizeUninitialized(std::string* s,\n-                                                size_t new_size) {\n-  ResizeUninitializedTraits<std::string>::Resize(s, new_size);\n-}\n-\n-// Used to ensure exponential growth so that the amortized complexity of\n-// increasing the string size by a small amount is O(1), in contrast to\n-// O(str->size()) in the case of precise growth.\n-// TODO(b/217943845): Would be better to use absl::strings so we don't need to\n-// keep cherry-picking performance fixes.\n-template <typename string_type>\n-void STLStringReserveAmortized(string_type *s, size_t new_size) {\n-  const size_t cap = s->capacity();\n-  if (new_size > cap) {\n-    // Make sure to always grow by at least a factor of 2x.\n-    s->reserve((std::max)(new_size, 2 * cap));\n-  }\n-}\n-\n-// Like STLStringResizeUninitialized(str, new_size), except guaranteed to use\n-// exponential growth so that the amortized complexity of increasing the string\n-// size by a small amount is O(1), in contrast to O(str->size()) in the case of\n-// precise growth.\n-template <typename string_type>\n-void STLStringResizeUninitializedAmortized(string_type *s, size_t new_size) {\n-  STLStringReserveAmortized(s, new_size);\n-  STLStringResizeUninitialized(s, new_size);\n-}\n-\n-}  // namespace\n-namespace internal {\n-\n-// Do not call directly - these are not part of the public API.\n-std::string CatPieces(std::initializer_list<absl::string_view> pieces) {\n-  size_t total_size = 0;\n-  for (const absl::string_view piece : pieces) total_size += piece.size();\n-  std::string result(total_size, '\\0');\n-\n-  char *const begin = &*result.begin();\n-  char *out = begin;\n-  for (const absl::string_view piece : pieces) {\n-    const size_t this_size = piece.size();\n-    memcpy(out, piece.data(), this_size);\n-    out += this_size;\n-  }\n-  DCHECK_EQ(out, begin + result.size());\n-  return result;\n-}\n-\n-// It's possible to call StrAppend with a StringPiece that is itself a fragment\n-// of the string we're appending to.  However the results of this are random.\n-// Therefore, check for this in debug mode.  Use unsigned math so we only have\n-// to do one comparison.\n-#define DCHECK_NO_OVERLAP(dest, src) \\\n-  DCHECK_GE(uintptr_t((src).data() - (dest).data()), uintptr_t((dest).size()))\n-\n-void AppendPieces(std::string* result,\n-                  std::initializer_list<absl::string_view> pieces) {\n-  size_t old_size = result->size();\n-  size_t total_size = old_size;\n-  for (const absl::string_view piece : pieces) {\n-    DCHECK_NO_OVERLAP(*result, piece);\n-    total_size += piece.size();\n-  }\n-  STLStringResizeUninitializedAmortized(result, total_size);\n-\n-  char *const begin = &*result->begin();\n-  char *out = begin + old_size;\n-  for (const absl::string_view piece : pieces) {\n-    const size_t this_size = piece.size();\n-    memcpy(out, piece.data(), this_size);\n-    out += this_size;\n-  }\n-  DCHECK_EQ(out, begin + result->size());\n-}\n-\n-}  // namespace internal\n-\n-void StrAppend(std::string* dest, const absl::AlphaNum& a) {\n-  DCHECK_NO_OVERLAP(*dest, a);\n-  dest->append(a.data(), a.size());\n-}\n-\n-void StrAppend(std::string* dest, const absl::AlphaNum& a,\n-               const absl::AlphaNum& b) {\n-  DCHECK_NO_OVERLAP(*dest, a);\n-  DCHECK_NO_OVERLAP(*dest, b);\n-  std::string::size_type old_size = dest->size();\n-  STLStringResizeUninitializedAmortized(dest, old_size + a.size() + b.size());\n-  char* const begin = &*dest->begin();\n-  char *out = Append2(begin + old_size, a, b);\n-  DCHECK_EQ(out, begin + dest->size());\n-}\n-\n-void StrAppend(std::string* dest, const absl::AlphaNum& a,\n-               const absl::AlphaNum& b, const absl::AlphaNum& c) {\n-  DCHECK_NO_OVERLAP(*dest, a);\n-  DCHECK_NO_OVERLAP(*dest, b);\n-  DCHECK_NO_OVERLAP(*dest, c);\n-  std::string::size_type old_size = dest->size();\n-  STLStringResizeUninitializedAmortized(\n-      dest, old_size + a.size() + b.size() + c.size());\n-  char* const begin = &*dest->begin();\n-  char *out = Append2(begin + old_size, a, b);\n-  out = Append1(out, c);\n-  DCHECK_EQ(out, begin + dest->size());\n-}\n-\n-void StrAppend(std::string* dest, const absl::AlphaNum& a,\n-               const absl::AlphaNum& b, const absl::AlphaNum& c,\n-               const absl::AlphaNum& d) {\n-  DCHECK_NO_OVERLAP(*dest, a);\n-  DCHECK_NO_OVERLAP(*dest, b);\n-  DCHECK_NO_OVERLAP(*dest, c);\n-  DCHECK_NO_OVERLAP(*dest, d);\n-  std::string::size_type old_size = dest->size();\n-  STLStringResizeUninitializedAmortized(\n-      dest, old_size + a.size() + b.size() + c.size() + d.size());\n-  char* const begin = &*dest->begin();\n-  char *out = Append4(begin + old_size, a, b, c, d);\n-  DCHECK_EQ(out, begin + dest->size());\n-}\n-\n-}  // namespace strings\n-}  // namespace tsl"
        },
        {
            "sha": "f82190957c1b0a3b6b1305cb2fdb2a94ffca4776",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/strcat.h",
            "status": "modified",
            "additions": 38,
            "deletions": 47,
            "changes": 85,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/07dcc5f8b12e9321df688ec5c9ab0a2581f6750f/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fstrcat.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/07dcc5f8b12e9321df688ec5c9ab0a2581f6750f/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fstrcat.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fstrcat.h?ref=07dcc5f8b12e9321df688ec5c9ab0a2581f6750f",
            "patch": "@@ -20,7 +20,6 @@ limitations under the License.\n #ifndef TENSORFLOW_TSL_PLATFORM_STRCAT_H_\n #define TENSORFLOW_TSL_PLATFORM_STRCAT_H_\n \n-#include <initializer_list>\n #include <string>\n \n #include \"absl/base/attributes.h\"\n@@ -106,44 +105,30 @@ using AlphaNum ABSL_DEPRECATE_AND_INLINE() = absl::AlphaNum;\n // ----------------------------------------------------------------------\n \n // For performance reasons, we have specializations for <= 4 args.\n-ABSL_DEPRECATED(\"Use absl::StrCat() instead.\")\n-std::string StrCat(const absl::AlphaNum& a) TF_MUST_USE_RESULT;\n-ABSL_DEPRECATED(\"Use absl::StrCat() instead.\")\n-std::string StrCat(const absl::AlphaNum& a,\n-                   const absl::AlphaNum& b) TF_MUST_USE_RESULT;\n-ABSL_DEPRECATED(\"Use absl::StrCat() instead.\")\n-std::string StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b,\n-                   const absl::AlphaNum& c) TF_MUST_USE_RESULT;\n-ABSL_DEPRECATED(\"Use absl::StrCat() instead.\")\n-std::string StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b,\n-                   const absl::AlphaNum& c,\n-                   const absl::AlphaNum& d) TF_MUST_USE_RESULT;\n-\n-namespace internal {\n-\n-// Do not call directly - this is not part of the public API.\n-std::string CatPieces(std::initializer_list<absl::string_view> pieces);\n-void AppendPieces(std::string *dest,\n-                  std::initializer_list<absl::string_view> pieces);\n-\n-}  // namespace internal\n+ABSL_DEPRECATE_AND_INLINE()\n+inline std::string StrCat(const absl::AlphaNum& a) { return absl::StrCat(a); }\n+ABSL_DEPRECATE_AND_INLINE()\n+inline std::string StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b) {\n+  return absl::StrCat(a, b);\n+}\n+ABSL_DEPRECATE_AND_INLINE()\n+inline std::string StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b,\n+                          const absl::AlphaNum& c) {\n+  return absl::StrCat(a, b, c);\n+}\n+ABSL_DEPRECATE_AND_INLINE()\n+inline std::string StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b,\n+                          const absl::AlphaNum& c, const absl::AlphaNum& d) {\n+  return absl::StrCat(a, b, c, d);\n+}\n \n // Support 5 or more arguments\n-template <typename... AV>\n-ABSL_DEPRECATED(\"Use absl::StrCat() instead.\")\n-std::string\n-    StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b,\n-           const absl::AlphaNum& c, const absl::AlphaNum& d,\n-           const absl::AlphaNum& e, const AV&... args) TF_MUST_USE_RESULT;\n-\n template <typename... AV>\n ABSL_DEPRECATED(\"Use absl::StrCat() instead.\")\n std::string StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b,\n                    const absl::AlphaNum& c, const absl::AlphaNum& d,\n                    const absl::AlphaNum& e, const AV&... args) {\n-  return internal::CatPieces(\n-      {a.Piece(), b.Piece(), c.Piece(), d.Piece(), e.Piece(),\n-       static_cast<const absl::AlphaNum&>(args).Piece()...});\n+  return absl::StrCat(a, b, c, d, e, args...);\n }\n \n // ----------------------------------------------------------------------\n@@ -167,18 +152,26 @@ std::string StrCat(const absl::AlphaNum& a, const absl::AlphaNum& b,\n //    worked around as consecutive calls to StrAppend are quite efficient.\n // ----------------------------------------------------------------------\n \n-ABSL_DEPRECATED(\"Use absl::StrAppend() instead.\")\n-void StrAppend(std::string* dest, const absl::AlphaNum& a);\n-ABSL_DEPRECATED(\"Use absl::StrAppend() instead.\")\n-void StrAppend(std::string* dest, const absl::AlphaNum& a,\n-               const absl::AlphaNum& b);\n-ABSL_DEPRECATED(\"Use absl::StrAppend() instead.\")\n-void StrAppend(std::string* dest, const absl::AlphaNum& a,\n-               const absl::AlphaNum& b, const absl::AlphaNum& c);\n-ABSL_DEPRECATED(\"Use absl::StrAppend() instead.\")\n-void StrAppend(std::string* dest, const absl::AlphaNum& a,\n-               const absl::AlphaNum& b, const absl::AlphaNum& c,\n-               const absl::AlphaNum& d);\n+ABSL_DEPRECATE_AND_INLINE()\n+inline void StrAppend(std::string* dest, const absl::AlphaNum& a) {\n+  absl::StrAppend(dest, a);\n+}\n+ABSL_DEPRECATE_AND_INLINE()\n+inline void StrAppend(std::string* dest, const absl::AlphaNum& a,\n+                      const absl::AlphaNum& b) {\n+  absl::StrAppend(dest, a, b);\n+}\n+ABSL_DEPRECATE_AND_INLINE()\n+inline void StrAppend(std::string* dest, const absl::AlphaNum& a,\n+                      const absl::AlphaNum& b, const absl::AlphaNum& c) {\n+  absl::StrAppend(dest, a, b, c);\n+}\n+ABSL_DEPRECATE_AND_INLINE()\n+inline void StrAppend(std::string* dest, const absl::AlphaNum& a,\n+                      const absl::AlphaNum& b, const absl::AlphaNum& c,\n+                      const absl::AlphaNum& d) {\n+  absl::StrAppend(dest, a, b, c, d);\n+}\n \n // Support 5 or more arguments\n template <typename... AV>\n@@ -187,9 +180,7 @@ inline void StrAppend(std::string* dest, const absl::AlphaNum& a,\n                       const absl::AlphaNum& b, const absl::AlphaNum& c,\n                       const absl::AlphaNum& d, const absl::AlphaNum& e,\n                       const AV&... args) {\n-  internal::AppendPieces(dest,\n-                         {a.Piece(), b.Piece(), c.Piece(), d.Piece(), e.Piece(),\n-                          static_cast<const absl::AlphaNum&>(args).Piece()...});\n+  absl::StrAppend(dest, a, b, c, d, e, args...);\n }\n \n }  // namespace strings"
        },
        {
            "sha": "63930612a2aa622bcbfa4d9180a67bfd33e683b4",
            "filename": "third_party/xla/third_party/tsl/tsl/platform/strcat_test.cc",
            "status": "removed",
            "additions": 0,
            "deletions": 394,
            "changes": 394,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/4cd5088297479ae63bab2a63e581a6d1b871eaf1/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fstrcat_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/4cd5088297479ae63bab2a63e581a6d1b871eaf1/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fstrcat_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fthird_party%2Ftsl%2Ftsl%2Fplatform%2Fstrcat_test.cc?ref=4cd5088297479ae63bab2a63e581a6d1b871eaf1",
            "patch": "@@ -1,394 +0,0 @@\n-/* Copyright 2015 The TensorFlow Authors. All Rights Reserved.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-==============================================================================*/\n-\n-#include \"tsl/platform/strcat.h\"\n-\n-#include <cstddef>\n-#include <cstdint>\n-#include <string>\n-\n-#include \"absl/strings/str_cat.h\"\n-#include \"absl/strings/string_view.h\"\n-#include \"xla/tsl/platform/test.h\"\n-#include \"xla/tsl/platform/types.h\"\n-#include \"tsl/platform/bfloat16.h\"\n-#include \"tsl/platform/stringprintf.h\"\n-\n-#ifdef _MSC_VER\n-// ssize_t is not a standard C++ type.\n-typedef ptrdiff_t ssize_t;\n-#endif\n-\n-namespace tsl {\n-namespace strings {\n-\n-// Test StrCat of ints and longs of various sizes and signdedness.\n-TEST(StrCat, Ints) {\n-  const int16_t s = -1;\n-  const uint16 us = 2;\n-  const int i = -3;\n-  const unsigned int ui = 4;\n-  const int32_t l = -5;\n-  const uint32 ul = 6;\n-  const int64_t ll = -7;\n-  const uint64 ull = 8;\n-  const ptrdiff_t ptrdiff = -9;\n-  const size_t size = 10;\n-  const ssize_t ssize = -11;\n-  const intptr_t intptr = -12;\n-  const uintptr_t uintptr = 13;\n-  string answer;\n-  answer = StrCat(s, us);\n-  EXPECT_EQ(answer, \"-12\");\n-  answer = StrCat(i, ui);\n-  EXPECT_EQ(answer, \"-34\");\n-  answer = StrCat(l, ul);\n-  EXPECT_EQ(answer, \"-56\");\n-  answer = StrCat(ll, ull);\n-  EXPECT_EQ(answer, \"-78\");\n-  answer = StrCat(ptrdiff, size);\n-  EXPECT_EQ(answer, \"-910\");\n-  answer = StrCat(ssize, intptr);\n-  EXPECT_EQ(answer, \"-11-12\");\n-  answer = StrCat(uintptr, 0);\n-  EXPECT_EQ(answer, \"130\");\n-}\n-\n-TEST(StrCat, Floats) {\n-  const int s = 0;\n-  const float f = 1.5f;\n-  const double d = 1.5;\n-\n-  string answer;\n-  answer = StrCat(s, f);\n-  EXPECT_EQ(answer, \"01.5\");\n-  answer = StrCat(s, d);\n-  EXPECT_EQ(answer, \"01.5\");\n-}\n-\n-TEST(StrCat, Nulls) {\n-  string result;\n-  // When passed to StrCat the below will produce a NULL data pointer\n-  absl::string_view v;\n-\n-  string strs[] = {\"Hello\", \"Cruel\", \"World\"};\n-\n-  result = StrCat(v);\n-  EXPECT_EQ(result, \"\");\n-\n-  result = StrCat(strs[0], v);\n-  EXPECT_EQ(result, \"Hello\");\n-\n-  result = StrCat(v, strs[0]);\n-  EXPECT_EQ(result, \"Hello\");\n-\n-  result = StrCat(v, strs[0], strs[1]);\n-  EXPECT_EQ(result, \"HelloCruel\");\n-\n-  result = StrCat(strs[0], v, strs[1]);\n-  EXPECT_EQ(result, \"HelloCruel\");\n-\n-  result = StrCat(strs[0], strs[1], v);\n-  EXPECT_EQ(result, \"HelloCruel\");\n-\n-  result = StrCat(v, strs[0], strs[1], strs[2]);\n-  EXPECT_EQ(result, \"HelloCruelWorld\");\n-\n-  result = StrCat(strs[0], v, strs[1], strs[2]);\n-  EXPECT_EQ(result, \"HelloCruelWorld\");\n-\n-  result = StrCat(strs[0], strs[1], v, strs[2]);\n-  EXPECT_EQ(result, \"HelloCruelWorld\");\n-\n-  result = StrCat(strs[0], strs[1], strs[2], v);\n-  EXPECT_EQ(result, \"HelloCruelWorld\");\n-}\n-\n-TEST(StrCat, Basics) {\n-  string result;\n-\n-  string strs[] = {\"Hello\", \"Cruel\", \"World\"};\n-\n-  absl::string_view pieces[] = {\"Hello\", \"Cruel\", \"World\"};\n-\n-  const char *c_strs[] = {\"Hello\", \"Cruel\", \"World\"};\n-\n-  int32 i32s[] = {'H', 'C', 'W'};\n-  uint64 ui64s[] = {12345678910LL, 10987654321LL};\n-\n-  result = StrCat(false, true, 2, 3);\n-  EXPECT_EQ(result, \"0123\");\n-\n-  result = StrCat(-1);\n-  EXPECT_EQ(result, \"-1\");\n-\n-  result = StrCat(0.5);\n-  EXPECT_EQ(result, \"0.5\");\n-\n-  result = StrCat(strs[1], pieces[2]);\n-  EXPECT_EQ(result, \"CruelWorld\");\n-\n-  result = StrCat(strs[0], \", \", pieces[2]);\n-  EXPECT_EQ(result, \"Hello, World\");\n-\n-  result = StrCat(strs[0], \", \", strs[1], \" \", strs[2], \"!\");\n-  EXPECT_EQ(result, \"Hello, Cruel World!\");\n-\n-  result = StrCat(pieces[0], \", \", pieces[1], \" \", pieces[2]);\n-  EXPECT_EQ(result, \"Hello, Cruel World\");\n-\n-  result = StrCat(c_strs[0], \", \", c_strs[1], \" \", c_strs[2]);\n-  EXPECT_EQ(result, \"Hello, Cruel World\");\n-\n-  result = StrCat(\"ASCII \", i32s[0], \", \", i32s[1], \" \", i32s[2], \"!\");\n-  EXPECT_EQ(result, \"ASCII 72, 67 87!\");\n-\n-  result = StrCat(ui64s[0], \", \", ui64s[1], \"!\");\n-  EXPECT_EQ(result, \"12345678910, 10987654321!\");\n-\n-  string one = \"1\";  // Actually, it's the size of this string that we want; a\n-                     // 64-bit build distinguishes between size_t and uint64,\n-                     // even though they're both unsigned 64-bit values.\n-  result = StrCat(\"And a \", one.size(), \" and a \", &result[2] - &result[0],\n-                  \" and a \", one, \" 2 3 4\", \"!\");\n-  EXPECT_EQ(result, \"And a 1 and a 2 and a 1 2 3 4!\");\n-\n-  // result = StrCat(\"Single chars won't compile\", '!');\n-  // result = StrCat(\"Neither will NULLs\", NULL);\n-  result = StrCat(\"To output a char by ASCII/numeric value, use +: \", '!' + 0);\n-  EXPECT_EQ(result, \"To output a char by ASCII/numeric value, use +: 33\");\n-\n-  float f = 100000.5;\n-  result = StrCat(\"A hundred K and a half is \", f);\n-  EXPECT_EQ(result, \"A hundred K and a half is 100000\");\n-\n-  double d = f;\n-  d *= d;\n-  result = StrCat(\"A hundred K and a half squared is \", d);\n-  EXPECT_EQ(result, \"A hundred K and a half squared is 1.00001e+10\");\n-\n-  result = StrCat(1, 2, 333, 4444, 55555, 666666, 7777777, 88888888, 999999999);\n-  EXPECT_EQ(result, \"12333444455555666666777777788888888999999999\");\n-}\n-\n-TEST(StrCat, MaxArgs) {\n-  string result;\n-  // Test 10 up to 26 arguments, the current maximum\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\");\n-  EXPECT_EQ(result, \"123456789a\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\");\n-  EXPECT_EQ(result, \"123456789ab\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\");\n-  EXPECT_EQ(result, \"123456789abc\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\");\n-  EXPECT_EQ(result, \"123456789abcd\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\");\n-  EXPECT_EQ(result, \"123456789abcde\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n-  EXPECT_EQ(result, \"123456789abcdef\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\");\n-  EXPECT_EQ(result, \"123456789abcdefg\");\n-  result =\n-      StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\");\n-  EXPECT_EQ(result, \"123456789abcdefgh\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n-                  \"h\", \"i\");\n-  EXPECT_EQ(result, \"123456789abcdefghi\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n-                  \"h\", \"i\", \"j\");\n-  EXPECT_EQ(result, \"123456789abcdefghij\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n-                  \"h\", \"i\", \"j\", \"k\");\n-  EXPECT_EQ(result, \"123456789abcdefghijk\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n-                  \"h\", \"i\", \"j\", \"k\", \"l\");\n-  EXPECT_EQ(result, \"123456789abcdefghijkl\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n-                  \"h\", \"i\", \"j\", \"k\", \"l\", \"m\");\n-  EXPECT_EQ(result, \"123456789abcdefghijklm\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n-                  \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\");\n-  EXPECT_EQ(result, \"123456789abcdefghijklmn\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n-                  \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\");\n-  EXPECT_EQ(result, \"123456789abcdefghijklmno\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n-                  \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\");\n-  EXPECT_EQ(result, \"123456789abcdefghijklmnop\");\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\n-                  \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\");\n-  EXPECT_EQ(result, \"123456789abcdefghijklmnopq\");\n-  // No limit thanks to C++11's variadic templates\n-  result = StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \"a\", \"b\", \"c\", \"d\", \"e\", \"f\",\n-                  \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\",\n-                  \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\",\n-                  \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\",\n-                  \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\");\n-  EXPECT_EQ(result,\n-            \"12345678910abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n-}\n-\n-TEST(StrAppend, Basics) {\n-  string result = \"existing text\";\n-\n-  string strs[] = {\"Hello\", \"Cruel\", \"World\"};\n-\n-  absl::string_view pieces[] = {\"Hello\", \"Cruel\", \"World\"};\n-\n-  const char *c_strs[] = {\"Hello\", \"Cruel\", \"World\"};\n-\n-  int32 i32s[] = {'H', 'C', 'W'};\n-  uint64 ui64s[] = {12345678910LL, 10987654321LL};\n-\n-  string::size_type old_size = result.size();\n-  StrAppend(&result, strs[0]);\n-  EXPECT_EQ(result.substr(old_size), \"Hello\");\n-\n-  old_size = result.size();\n-  StrAppend(&result, strs[1], pieces[2]);\n-  EXPECT_EQ(result.substr(old_size), \"CruelWorld\");\n-\n-  old_size = result.size();\n-  StrAppend(&result, strs[0], \", \", pieces[2]);\n-  EXPECT_EQ(result.substr(old_size), \"Hello, World\");\n-\n-  old_size = result.size();\n-  StrAppend(&result, strs[0], \", \", strs[1], \" \", strs[2], \"!\");\n-  EXPECT_EQ(result.substr(old_size), \"Hello, Cruel World!\");\n-\n-  old_size = result.size();\n-  StrAppend(&result, pieces[0], \", \", pieces[1], \" \", pieces[2]);\n-  EXPECT_EQ(result.substr(old_size), \"Hello, Cruel World\");\n-\n-  old_size = result.size();\n-  StrAppend(&result, c_strs[0], \", \", c_strs[1], \" \", c_strs[2]);\n-  EXPECT_EQ(result.substr(old_size), \"Hello, Cruel World\");\n-\n-  old_size = result.size();\n-  StrAppend(&result, \"ASCII \", i32s[0], \", \", i32s[1], \" \", i32s[2], \"!\");\n-  EXPECT_EQ(result.substr(old_size), \"ASCII 72, 67 87!\");\n-\n-  old_size = result.size();\n-  StrAppend(&result, ui64s[0], \", \", ui64s[1], \"!\");\n-  EXPECT_EQ(result.substr(old_size), \"12345678910, 10987654321!\");\n-\n-  string one = \"1\";  // Actually, it's the size of this string that we want; a\n-                     // 64-bit build distinguishes between size_t and uint64,\n-                     // even though they're both unsigned 64-bit values.\n-  old_size = result.size();\n-  StrAppend(&result, \"And a \", one.size(), \" and a \", &result[2] - &result[0],\n-            \" and a \", one, \" 2 3 4\", \"!\");\n-  EXPECT_EQ(result.substr(old_size), \"And a 1 and a 2 and a 1 2 3 4!\");\n-\n-  // result = StrCat(\"Single chars won't compile\", '!');\n-  // result = StrCat(\"Neither will NULLs\", NULL);\n-  old_size = result.size();\n-  StrAppend(&result,\n-            \"To output a char by ASCII/numeric value, use +: \", '!' + 0);\n-  EXPECT_EQ(result.substr(old_size),\n-            \"To output a char by ASCII/numeric value, use +: 33\");\n-\n-  float f = 100000.5;\n-  old_size = result.size();\n-  StrAppend(&result, \"A hundred K and a half is \", f);\n-  EXPECT_EQ(result.substr(old_size), \"A hundred K and a half is 100000\");\n-\n-  double d = f;\n-  d *= d;\n-  old_size = result.size();\n-  StrAppend(&result, \"A hundred K and a half squared is \", d);\n-  EXPECT_EQ(result.substr(old_size),\n-            \"A hundred K and a half squared is 1.00001e+10\");\n-\n-  // Test 9 arguments, the old maximum\n-  old_size = result.size();\n-  StrAppend(&result, 1, 22, 333, 4444, 55555, 666666, 7777777, 88888888, 9);\n-  EXPECT_EQ(result.substr(old_size), \"1223334444555556666667777777888888889\");\n-\n-  // No limit thanks to C++11's variadic templates\n-  old_size = result.size();\n-  StrAppend(&result, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, \"a\", \"b\", \"c\", \"d\", \"e\",\n-            \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\",\n-            \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\", \"A\", \"B\", \"C\", \"D\", \"E\",\n-            \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\",\n-            \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\",\n-            \"No limit thanks to C++11's variadic templates\");\n-  EXPECT_EQ(result.substr(old_size),\n-            \"12345678910abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n-            \"No limit thanks to C++11's variadic templates\");\n-}\n-\n-TEST(StrAppend, Death) {\n-  string s = \"self\";\n-  EXPECT_DEBUG_DEATH(StrAppend(&s, s.c_str() + 1), \"Check failed:\");\n-  EXPECT_DEBUG_DEATH(StrAppend(&s, s), \"Check failed:\");\n-}\n-\n-static void CheckHex64(uint64 v) {\n-  string actual = strings::StrCat(absl::Hex(v, absl::kZeroPad16));\n-  string expected = Printf(\"%016llx\", static_cast<unsigned long long>(v));\n-  EXPECT_EQ(expected, actual) << \" decimal value \" << v;\n-\n-  actual = strings::StrCat(absl::Hex(v, absl::kZeroPad8));\n-  expected = Printf(\"%08llx\", static_cast<unsigned long long>(v));\n-  EXPECT_EQ(expected, actual) << \" decimal value \" << v;\n-\n-  actual = strings::StrCat(absl::Hex(v));\n-  expected = Printf(\"%llx\", static_cast<unsigned long long>(v));\n-  EXPECT_EQ(expected, actual) << \" decimal value \" << v;\n-}\n-\n-static void CheckHex32(uint32 v) {\n-  string actual = strings::StrCat(absl::Hex(v, absl::kZeroPad8));\n-  string expected = Printf(\"%08x\", v);\n-  EXPECT_EQ(expected, actual) << \" decimal value \" << v;\n-\n-  actual = strings::StrCat(absl::Hex(v));\n-  expected = Printf(\"%x\", v);\n-  EXPECT_EQ(expected, actual) << \" decimal value \" << v;\n-}\n-\n-static void CheckHexSigned32(int32_t v) {\n-  string actual = strings::StrCat(absl::Hex(v, absl::kZeroPad8));\n-  string expected = Printf(\"%08x\", v);\n-  EXPECT_EQ(expected, actual) << \" decimal value \" << v;\n-\n-  actual = strings::StrCat(absl::Hex(v));\n-  expected = Printf(\"%x\", v);\n-  EXPECT_EQ(expected, actual) << \" decimal value \" << v;\n-}\n-\n-static void TestFastPrints() {\n-  // Test min int to make sure that works\n-  for (int i = 0; i < 10000; i++) {\n-    CheckHex64(i);\n-    CheckHex32(i);\n-    CheckHexSigned32(i);\n-    CheckHexSigned32(-i);\n-  }\n-  CheckHex64(0x123456789abcdef0ull);\n-  CheckHex32(0x12345678);\n-\n-  int8_t minus_one_8bit = -1;\n-  EXPECT_EQ(\"ff\", strings::StrCat(absl::Hex(minus_one_8bit)));\n-\n-  int16_t minus_one_16bit = -1;\n-  EXPECT_EQ(\"ffff\", strings::StrCat(absl::Hex(minus_one_16bit)));\n-}\n-\n-TEST(Numbers, TestFunctionsMovedOverFromNumbersMain) { TestFastPrints(); }\n-\n-}  // namespace strings\n-}  // namespace tsl"
        }
    ],
    "stats": {
        "total": 766,
        "additions": 38,
        "deletions": 728
    }
}