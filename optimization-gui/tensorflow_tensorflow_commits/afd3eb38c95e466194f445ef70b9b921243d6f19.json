{
    "author": "mwhittaker",
    "message": "Move `BufferAssigner::Run` arguments to `Options` struct.\n\n`BufferAssigner::Run` had a lot of optional arguments, and I'm planning on\nadding even more, so I moved them to an `Options` struct.\n\nPiperOrigin-RevId: 839451734",
    "sha": "afd3eb38c95e466194f445ef70b9b921243d6f19",
    "files": [
        {
            "sha": "4079d96b6cd208b552f092ce0cecf392a218916a",
            "filename": "third_party/xla/xla/backends/cpu/codegen/elemental/elemental_kernel_emitter_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Felemental%2Felemental_kernel_emitter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Felemental%2Felemental_kernel_emitter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Felemental%2Felemental_kernel_emitter_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -61,7 +61,8 @@ class ElementalKernelEmitterTest : public HloHardwareIndependentTestBase {\n         [](const BufferValue& buffer) {\n           return CpuExecutable::ShapeSizeBytes(buffer.shape());\n         },\n-        &alias_info_, [](LogicalBuffer::Color) { return /*alignment=*/1; });\n+        &alias_info_, [](LogicalBuffer::Color) { return /*alignment=*/1; },\n+        BufferAssigner::Options{});\n   }\n \n  private:"
        },
        {
            "sha": "0c09ff701243982d6b7ed1aeee833f2603d19e8b",
            "filename": "third_party/xla/xla/backends/cpu/codegen/emitters/cpu_fusion_emitter_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Femitters%2Fcpu_fusion_emitter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Femitters%2Fcpu_fusion_emitter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Femitters%2Fcpu_fusion_emitter_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -59,7 +59,8 @@ class CpuFusionEmitterTest : public HloHardwareIndependentTestBase {\n         [](const BufferValue& buffer) {\n           return CpuExecutable::ShapeSizeBytes(buffer.shape());\n         },\n-        &alias_info_, [](LogicalBuffer::Color) { return /*alignment=*/1; });\n+        &alias_info_, [](LogicalBuffer::Color) { return /*alignment=*/1; },\n+        BufferAssigner::Options{});\n   }\n \n   AliasInfo alias_info_;"
        },
        {
            "sha": "ce48ffe88158d25175cb422ff5d9d3cb97ccc4b7",
            "filename": "third_party/xla/xla/backends/cpu/codegen/kernel_api_ir_builder_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Fkernel_api_ir_builder_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Fkernel_api_ir_builder_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fbackends%2Fcpu%2Fcodegen%2Fkernel_api_ir_builder_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -88,7 +88,8 @@ class KernelApiIrBuilderTestBase : public HloHardwareIndependentTestBase {\n         [](const BufferValue& buffer) {\n           return CpuExecutable::ShapeSizeBytes(buffer.shape());\n         },\n-        &alias_info_, [](LogicalBuffer::Color) { return /*alignment=*/1; });\n+        &alias_info_, [](LogicalBuffer::Color) { return /*alignment=*/1; },\n+        BufferAssigner::Options{});\n   }\n \n   void SetKernelFunctionAttributes(llvm::Function* function) {"
        },
        {
            "sha": "f890492b09bd2d6468e7b5f76e6c513e1e3447f8",
            "filename": "third_party/xla/xla/codegen/emitters/kernel_arguments_test.cc",
            "status": "modified",
            "additions": 19,
            "deletions": 6,
            "changes": 25,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Fkernel_arguments_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Fkernel_arguments_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fcodegen%2Femitters%2Fkernel_arguments_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -18,6 +18,7 @@ limitations under the License.\n #include <cstddef>\n #include <cstdint>\n #include <memory>\n+#include <utility>\n #include <vector>\n \n #include <gmock/gmock.h>\n@@ -67,12 +68,14 @@ TEST_F(KernelArgumentsTest, GetArgumentBufferSlices) {\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n                           ParseAndReturnVerifiedModule(kHloString));\n   AliasInfo alias_info;\n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       std::unique_ptr<BufferAssignment> assignment,\n       BufferAssigner::Run(\n           module.get(), std::make_unique<DependencyHloOrdering>(module.get()),\n           &BufferSizeBytes, &alias_info, [](LogicalBuffer::Color) { return 0; },\n-          /*allocate_buffers_for_constants=*/true));\n+          std::move(opts)));\n \n   // Three allocations: one for each parameter, plus one for the output.\n   EXPECT_THAT(assignment->Allocations(), SizeIs(3));\n@@ -120,6 +123,8 @@ ENTRY main {\n   HloInstruction* root = module->entry_computation()->root_instruction();\n \n   AliasInfo alias_info;\n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       std::unique_ptr<BufferAssignment> buffer_assignment,\n       BufferAssigner::Run(\n@@ -128,7 +133,7 @@ ENTRY main {\n             return ShapeUtil::ByteSizeOf(buffer.shape(), sizeof(void*));\n           },\n           &alias_info, [](LogicalBuffer::Color) { return 1; },\n-          /*allocate_buffers_for_constants=*/true));\n+          std::move(opts)));\n \n   KernelArguments::BufferAlignment buffer_alignment;\n   buffer_alignment.entry_parameter_align_bytes = 1;\n@@ -186,12 +191,14 @@ ENTRY main {\n   HloInstruction* root = module->entry_computation()->root_instruction();\n \n   AliasInfo alias_info;\n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       std::unique_ptr<BufferAssignment> buffer_assignment,\n       BufferAssigner::Run(\n           module.get(), std::make_unique<DependencyHloOrdering>(module.get()),\n           &BufferSizeBytes, &alias_info, [](LogicalBuffer::Color) { return 1; },\n-          /*allocate_buffers_for_constants=*/true));\n+          std::move(opts)));\n \n   KernelArguments::BufferAlignment buffer_alignment;\n   buffer_alignment.entry_parameter_align_bytes = 1;\n@@ -254,12 +261,14 @@ ENTRY main {\n   HloInstruction* root = module->entry_computation()->root_instruction();\n \n   AliasInfo alias_info;\n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       std::unique_ptr<BufferAssignment> buffer_assignment,\n       BufferAssigner::Run(\n           module.get(), std::make_unique<DependencyHloOrdering>(module.get()),\n           &BufferSizeBytes, &alias_info, [](LogicalBuffer::Color) { return 1; },\n-          /*allocate_buffers_for_constants=*/true));\n+          std::move(opts)));\n \n   KernelArguments::BufferAlignment buffer_alignment;\n   buffer_alignment.entry_parameter_align_bytes = 1;\n@@ -292,12 +301,14 @@ ENTRY main {\n   HloInstruction* root = module->entry_computation()->root_instruction();\n \n   AliasInfo alias_info;\n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       std::unique_ptr<BufferAssignment> buffer_assignment,\n       BufferAssigner::Run(\n           module.get(), std::make_unique<DependencyHloOrdering>(module.get()),\n           &BufferSizeBytes, &alias_info, [](LogicalBuffer::Color) { return 1; },\n-          /*allocate_buffers_for_constants=*/true));\n+          std::move(opts)));\n \n   KernelArguments::BufferAlignment buffer_alignment;\n   buffer_alignment.entry_parameter_align_bytes = 1;\n@@ -331,12 +342,14 @@ TEST_F(KernelArgumentsTest, UnmanagedArguments) {\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<VerifiedHloModule> module,\n                           ParseAndReturnVerifiedModule(kHloString));\n   AliasInfo alias_info;\n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       std::unique_ptr<BufferAssignment> assignment,\n       BufferAssigner::Run(\n           module.get(), std::make_unique<DependencyHloOrdering>(module.get()),\n           &BufferSizeBytes, &alias_info, [](LogicalBuffer::Color) { return 0; },\n-          /*allocate_buffers_for_constants=*/true));\n+          std::move(opts)));\n   // Input and output buffers are managed.\n   EXPECT_THAT(assignment->Allocations(), SizeIs(3));\n   auto unmanaged_arguments = std::vector{"
        },
        {
            "sha": "3706e726161ab8ce1c48a465b25d74e28ad3ed44",
            "filename": "third_party/xla/xla/hlo/ir/hlo_module_test.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fhlo%2Fir%2Fhlo_module_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -1166,6 +1166,8 @@ TEST(HloModuleTest, TestCreateFromProtoUpdatesBufferAssignment) {\n     return ShapeUtil::ByteSizeOf(buffer.shape(), sizeof(void*));\n   };\n \n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto buffer_assignment,\n       BufferAssigner::Run(\n@@ -1175,7 +1177,7 @@ TEST(HloModuleTest, TestCreateFromProtoUpdatesBufferAssignment) {\n           /*buffer_size=*/std::move(buffer_size_func),\n           /*alias_info=*/&alias_info,\n           /*color_alignment=*/[](LogicalBuffer::Color) -> int64_t { return 1; },\n-          /*allocate_buffers_for_constants=*/true));\n+          /*options=*/std::move(opts)));\n \n   BufferAssignmentProto buffer_assignment_proto = buffer_assignment->ToProto();\n   *opt_hlo_module_proto.mutable_buffer_assignment() = buffer_assignment_proto;"
        },
        {
            "sha": "03e7f2f96239bb4c64257211dee35bbfc2a7e903",
            "filename": "third_party/xla/xla/service/buffer_assignment.cc",
            "status": "modified",
            "additions": 30,
            "deletions": 41,
            "changes": 71,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -1353,22 +1353,11 @@ void BufferAssignment::Finalize() {\n absl::StatusOr<std::unique_ptr<BufferAssignment>> BufferAssigner::Run(\n     const HloModule* module, std::unique_ptr<HloOrdering> hlo_ordering,\n     BufferValue::SizeFunction buffer_size, const AliasInfo* alias_info,\n-    LogicalBuffer::AlignmentFunction color_alignment,\n-    bool allocate_buffers_for_constants, BufferAssigner::Colorer colorer,\n-    std::optional<BufferAssigner::MustNotLiveOut> must_not_live_out,\n-    std::unique_ptr<PresetAssignments> preset_assignments,\n-    const PrivateStacks& private_stacks,\n-    GlobalDecreasingSizeBestFitHeap<HloValue>::BufferIntervalCompare\n-        heap_buffer_interval_compare,\n-    std::optional<BufferAssignment::BufferIsolationOptions> isolation_options,\n-    std::optional<BufferValue::Color> temp_buffer_color) {\n-  BufferAssigner assigner(allocate_buffers_for_constants, std::move(colorer),\n-                          must_not_live_out, std::move(preset_assignments),\n-                          alias_info);\n-  return assigner.CreateAssignment(\n-      module, std::move(hlo_ordering), std::move(buffer_size),\n-      std::move(color_alignment), private_stacks, heap_buffer_interval_compare,\n-      isolation_options, temp_buffer_color);\n+    LogicalBuffer::AlignmentFunction color_alignment, Options opts) {\n+  BufferAssigner assigner(alias_info, std::move(opts));\n+  return assigner.CreateAssignment(module, std::move(hlo_ordering),\n+                                   std::move(buffer_size),\n+                                   std::move(color_alignment));\n }\n \n bool BufferAssigner::LiveRangeInterferes(const HloValue* buffer1,\n@@ -1469,13 +1458,13 @@ absl::StatusOr<bool> BufferAssigner::MaybeAssignBuffer(\n     return false;\n   }\n \n-  if (must_not_live_out_.has_value()) {\n+  if (opts_.must_not_live_out.has_value()) {\n     if (allocation->maybe_live_out()) {\n       // If a buffer maybe live out, the allocation cannot contain any node\n-      // where must_not_live_out_ returns true.\n+      // where must_not_live_out returns true.\n       for (const HloValue* value : hlo_buffer.values()) {\n-        if ((*must_not_live_out_)(assignment->alias_analysis(),\n-                                  value->instruction(), value->index())) {\n+        if ((*opts_.must_not_live_out)(assignment->alias_analysis(),\n+                                       value->instruction(), value->index())) {\n           VLOG(4) << \"Can't assign: \" << value->instruction()->ToString()\n                   << \" cannot live out of the module\";\n           return false;\n@@ -1490,8 +1479,8 @@ absl::StatusOr<bool> BufferAssigner::MaybeAssignBuffer(\n     if (assignment->alias_analysis().BufferLivesOut(hlo_buffer)) {\n       for (const auto& buffer_offset_size : allocation->assigned_buffers()) {\n         const HloValue* value = buffer_offset_size.first;\n-        if ((*must_not_live_out_)(assignment->alias_analysis(),\n-                                  value->instruction(), value->index())) {\n+        if ((*opts_.must_not_live_out)(assignment->alias_analysis(),\n+                                       value->instruction(), value->index())) {\n           VLOG(4) << \"Can't assign: \" << value->instruction()\n                   << \" cannot live out of the module\";\n           return false;\n@@ -1569,7 +1558,7 @@ absl::Status BufferAssigner::AssignSingleHloBuffer(\n   const int64_t buffer_size = assignment->HloBufferSize(*hlo_buffer);\n   for (const HloValue* value : hlo_buffer->values()) {\n     if (value->instruction()->opcode() == HloOpcode::kConstant) {\n-      if (allocate_buffers_for_constants_) {\n+      if (opts_.allocate_buffers_for_constants) {\n         TF_ASSIGN_OR_RETURN(\n             BufferAllocation * allocation,\n             assignment->NewAllocation(*hlo_buffer, buffer_size));\n@@ -1856,14 +1845,15 @@ BufferAssigner::SplitBuffersByPrivateStackComputation(\n absl::Status BufferAssigner::AssignPresetBuffers(\n     absl::flat_hash_set<const HloBuffer*>* assigned_buffers,\n     BufferAssignment* assignment) {\n-  if (!preset_assignments_) {\n+  if (!opts_.preset_assignments) {\n     return absl::OkStatus();\n   }\n \n   // Create an allocation for each preset color.\n   absl::flat_hash_map<LogicalBuffer::Color, BufferAllocation*>\n       preset_allocations;\n-  for (auto& color_and_info : preset_assignments_->assignment_informations()) {\n+  for (auto& color_and_info :\n+       opts_.preset_assignments->assignment_informations()) {\n     LogicalBuffer::Color color(color_and_info.first);\n     auto inserted = preset_allocations.emplace(\n         color,\n@@ -1879,7 +1869,7 @@ absl::Status BufferAssigner::AssignPresetBuffers(\n \n   const HloAliasAnalysis& alias_analysis = assignment->alias_analysis();\n \n-  for (auto& position_and_chunk : preset_assignments_->chunks()) {\n+  for (auto& position_and_chunk : opts_.preset_assignments->chunks()) {\n     const HloPosition& defining_position = position_and_chunk.first;\n     const HloBuffer& buffer = alias_analysis.GetUniqueBufferAt(\n         defining_position.instruction, defining_position.index);\n@@ -1899,7 +1889,7 @@ absl::Status BufferAssigner::AssignPresetBuffers(\n \n   // Upon consumption of the preset assignments, delete it so that if this\n   // method is called again, it does not assign the same buffers multiple times.\n-  preset_assignments_ = {};\n+  opts_.preset_assignments = {};\n \n   return absl::OkStatus();\n }\n@@ -1971,7 +1961,7 @@ absl::Status BufferAssigner::AssignBuffersWithSequentialOrdering(\n       VLOG(2) << \"Simulating heap for color \" << color;\n       int64_t alignment = assignment->color_alignment_(color);\n       HeapSimulator::Options options;\n-      options.alloc_constants = allocate_buffers_for_constants_;\n+      options.alloc_constants = opts_.allocate_buffers_for_constants;\n       auto private_stacks_it = private_stacks.find(color);\n       if (private_stacks_it != private_stacks.end()) {\n         // For private stack colors, we collect all of the buffers that are\n@@ -2279,12 +2269,7 @@ absl::StatusOr<std::unique_ptr<BufferAssignment>>\n BufferAssigner::CreateAssignment(\n     const HloModule* module, std::unique_ptr<HloOrdering> hlo_ordering,\n     BufferValue::SizeFunction buffer_size,\n-    LogicalBuffer::AlignmentFunction color_alignment,\n-    const PrivateStacks& private_stacks,\n-    GlobalDecreasingSizeBestFitHeap<HloValue>::BufferIntervalCompare\n-        heap_buffer_interval_compare,\n-    std::optional<BufferAssignment::BufferIsolationOptions> isolation_options,\n-    std::optional<BufferValue::Color> temp_buffer_color) {\n+    LogicalBuffer::AlignmentFunction color_alignment) {\n   TF_ASSIGN_OR_RETURN(std::unique_ptr<HloAliasAnalysis> alias_analysis,\n                       HloAliasAnalysis::Run(module, alias_info_));\n \n@@ -2318,7 +2303,7 @@ BufferAssigner::CreateAssignment(\n       std::move(hlo_live_range)));\n \n   TF_RETURN_IF_ERROR(\n-      colorer_(&assignment->alias_analysis(), assignment->hlo_ordering()));\n+      opts_.colorer(&assignment->alias_analysis(), assignment->hlo_ordering()));\n   VLOG(3) << \"After coloring:\";\n   XLA_VLOG_LINES(3,\n                  assignment->alias_analysis().dataflow_analysis().ToString());\n@@ -2348,10 +2333,12 @@ BufferAssigner::CreateAssignment(\n       module->config().debug_options().xla_multiheap_size_constraint_per_heap();\n   VLOG(2) << \"Multiheap per heap size limit: \"\n           << multiheap_size_constraint_per_heap;\n+  const PrivateStacks private_stacks;\n   TF_RETURN_IF_ERROR(AssignBuffersWithSequentialOrdering(\n       buffers_to_assign_sequentially, run_whole_module_heap_simulation,\n-      assignment.get(), private_stacks, heap_buffer_interval_compare,\n-      isolation_options));\n+      assignment.get(),\n+      opts_.private_stacks ? *opts_.private_stacks : private_stacks,\n+      opts_.heap_buffer_interval_compare, opts_.isolation_options));\n \n   std::vector<const HloComputation*> thread_local_computations_no_fusion;\n   // Now assign buffers for thread-local computations. All LogicalBuffers get\n@@ -2389,12 +2376,14 @@ BufferAssigner::CreateAssignment(\n   // is marked, since it is used to determine whether an allocation contains\n   // temporary buffers or not.\n   absl::flat_hash_set<BufferValue::Color> private_stack_colors;\n-  for (const auto& [color, computations] : private_stacks) {\n-    private_stack_colors.insert(color);\n+  if (opts_.private_stacks) {\n+    for (const auto& [color, computations] : *opts_.private_stacks) {\n+      private_stack_colors.insert(color);\n+    }\n   }\n \n-  TF_RETURN_IF_ERROR(assignment->CombineTempAllocations(private_stack_colors,\n-                                                        temp_buffer_color));\n+  TF_RETURN_IF_ERROR(assignment->CombineTempAllocations(\n+      private_stack_colors, opts_.temp_buffer_color));\n \n   XLA_VLOG_LINES(2, assignment->ToString());\n   assignment->ComputeSummaryStats();"
        },
        {
            "sha": "1b8e5b61cfa4d1ba7f8d4f03e0ded56a43204033",
            "filename": "third_party/xla/xla/service/buffer_assignment.h",
            "status": "modified",
            "additions": 29,
            "deletions": 42,
            "changes": 71,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment.h?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -719,6 +719,30 @@ class BufferAssigner {\n   using PrivateStacks = absl::flat_hash_map<BufferValue::Color,\n                                             std::vector<const HloComputation*>>;\n \n+  // Options for BufferAssigner::Run.\n+  struct Options {\n+    // If true, allocate buffers for constant instructions.\n+    bool allocate_buffers_for_constants = false;\n+\n+    // Functor used to assign colors to newly allocated logical buffers.\n+    Colorer colorer = DefaultColorer();\n+\n+    // An optional function that returns true if the given instruction can't\n+    // live out of a computation.\n+    std::optional<MustNotLiveOut> must_not_live_out;\n+\n+    // Description of any buffer offsets that are already set by an earlier\n+    // pass.\n+    std::unique_ptr<memory_space_assignment::PresetAssignments>\n+        preset_assignments;\n+\n+    const PrivateStacks* private_stacks = nullptr;\n+    GlobalDecreasingSizeBestFitHeap<HloValue>::BufferIntervalCompare\n+        heap_buffer_interval_compare;\n+    std::optional<BufferAssignment::BufferIsolationOptions> isolation_options;\n+    std::optional<BufferValue::Color> temp_buffer_color;\n+  };\n+\n   static Colorer DefaultColorer() {\n     return [](HloAliasAnalysis* alias_analysis, const HloOrdering&) {\n       for (HloValue* value : alias_analysis->dataflow_analysis().values()) {\n@@ -745,42 +769,18 @@ class BufferAssigner {\n   static absl::StatusOr<std::unique_ptr<BufferAssignment>> Run(\n       const HloModule* module, std::unique_ptr<HloOrdering> hlo_ordering,\n       BufferValue::SizeFunction buffer_size, const AliasInfo* alias_info,\n-      LogicalBuffer::AlignmentFunction color_alignment,\n-      bool allocate_buffers_for_constants = false,\n-      Colorer colorer = DefaultColorer(),\n-      std::optional<MustNotLiveOut> must_not_live_out = std::nullopt,\n-      std::unique_ptr<memory_space_assignment::PresetAssignments>\n-          preset_assignments = {},\n-      const PrivateStacks& private_stacks = {},\n-      GlobalDecreasingSizeBestFitHeap<HloValue>::BufferIntervalCompare\n-          heap_buffer_interval_compare = nullptr,\n-      std::optional<BufferAssignment::BufferIsolationOptions>\n-          isolation_options = std::nullopt,\n-      std::optional<BufferValue::Color> temp_buffer_color = std::nullopt);\n+      LogicalBuffer::AlignmentFunction color_alignment, Options options);\n \n  private:\n-  BufferAssigner(bool allocate_buffers_for_constants, Colorer colorer,\n-                 std::optional<MustNotLiveOut> must_not_live_out,\n-                 std::unique_ptr<memory_space_assignment::PresetAssignments>\n-                     preset_assignments,\n-                 const AliasInfo* alias_info)\n-      : allocate_buffers_for_constants_(allocate_buffers_for_constants),\n-        colorer_(colorer),\n-        must_not_live_out_(must_not_live_out),\n-        preset_assignments_(std::move(preset_assignments)),\n-        alias_info_(alias_info) {}\n+  BufferAssigner(const AliasInfo* alias_info, Options opts)\n+      : alias_info_(alias_info), opts_(std::move(opts)) {}\n   virtual ~BufferAssigner() = default;\n \n   // Create a buffer assignment.\n   absl::StatusOr<std::unique_ptr<BufferAssignment>> CreateAssignment(\n       const HloModule* module, std::unique_ptr<HloOrdering> hlo_ordering,\n       BufferValue::SizeFunction buffer_size,\n-      LogicalBuffer::AlignmentFunction color_alignment,\n-      const PrivateStacks& private_stacks,\n-      GlobalDecreasingSizeBestFitHeap<HloValue>::BufferIntervalCompare\n-          heap_buffer_interval_compare,\n-      std::optional<BufferAssignment::BufferIsolationOptions> isolation_options,\n-      std::optional<BufferValue::Color> temp_buffer_color);\n+      LogicalBuffer::AlignmentFunction color_alignment);\n \n   // Assigns buffers to the instructions in the given computations. \"assignment\"\n   // is modified to reflect the new buffer assignments. If is_thread_local is\n@@ -869,21 +869,8 @@ class BufferAssigner {\n       absl::Span<const HloComputation* const> private_stack_computations,\n       const CallGraph& call_graph) const;\n \n-  // If true, allocate buffers for constant instructions.\n-  bool allocate_buffers_for_constants_;\n-\n-  // Functor used to assign colors to newly allocated logical buffers.\n-  Colorer colorer_;\n-\n-  // An optional function that returns true if the given instruction can't live\n-  // out of a computation.\n-  std::optional<MustNotLiveOut> must_not_live_out_;\n-\n-  // Description of any buffer offsets that are already set by an earlier pass.\n-  std::unique_ptr<memory_space_assignment::PresetAssignments>\n-      preset_assignments_;\n-\n   const AliasInfo* alias_info_;\n+  Options opts_;\n \n   BufferAssigner(const BufferAssigner&) = delete;\n   BufferAssigner& operator=(const BufferAssigner&) = delete;"
        },
        {
            "sha": "86a5dfaf63e987fb3c65e8dcb61dda1f28944bf5",
            "filename": "third_party/xla/xla/service/buffer_assignment_test.cc",
            "status": "modified",
            "additions": 40,
            "deletions": 25,
            "changes": 65,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fbuffer_assignment_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -118,11 +118,13 @@ class BufferAssignmentTest : public HloHardwareIndependentTestBase {\n \n   std::unique_ptr<BufferAssignment> RunBufferAssignment(HloModule* module,\n                                                         int64_t alignment = 1) {\n+    BufferAssigner::Options opts;\n+    opts.allocate_buffers_for_constants = true;\n     return BufferAssigner::Run(\n                module, std::make_unique<DependencyHloOrdering>(module),\n                &BufferSizeBytes, &alias_info_,\n                [alignment](LogicalBuffer::Color) { return alignment; },\n-               /*allocate_buffers_for_constants=*/true)\n+               std::move(opts))\n         .value();\n   }\n \n@@ -141,25 +143,29 @@ class BufferAssignmentTest : public HloHardwareIndependentTestBase {\n       const BufferAssigner::PrivateStacks& private_stacks = {},\n       std::optional<BufferAssignment::BufferIsolationOptions>\n           isolation_options = std::nullopt) {\n+    BufferAssigner::Options opts;\n+    opts.allocate_buffers_for_constants = true;\n+    opts.colorer = colorer;\n+    opts.private_stacks = &private_stacks;\n+    opts.isolation_options = isolation_options;\n     return BufferAssigner::Run(\n                module,\n                std::make_unique<SequentialHloOrdering>(module->schedule()),\n                &BufferSizeBytes, &alias_info_,\n                [alignment](LogicalBuffer::Color) { return alignment; },\n-               /*allocate_buffers_for_constants=*/true, colorer,\n-               /*must_not_live_out=*/std::nullopt,\n-               /*preset_assignments=*/{}, private_stacks,\n-               /*heap_buffer_interval_compare=*/nullptr, isolation_options)\n+               std::move(opts))\n         .value();\n   }\n \n   std::unique_ptr<BufferAssignment> RunBufferAssignmentNoBuffersForConstants(\n       HloModule* module, int64_t alignment = 1) {\n+    BufferAssigner::Options opts;\n+    opts.allocate_buffers_for_constants = false;\n     return BufferAssigner::Run(\n                module, std::make_unique<DependencyHloOrdering>(module),\n                &BufferSizeBytes, &alias_info_,\n                [alignment](LogicalBuffer::Color) { return alignment; },\n-               /*allocate_buffers_for_constants=*/false)\n+               std::move(opts))\n         .value();\n   }\n \n@@ -171,24 +177,28 @@ class BufferAssignmentTest : public HloHardwareIndependentTestBase {\n       return instruction->opcode() == HloOpcode::kAdd;\n     };\n \n+    BufferAssigner::Options opts;\n+    opts.allocate_buffers_for_constants = false;\n+    opts.must_not_live_out = must_not_live_out;\n     return BufferAssigner::Run(\n                module, std::make_unique<DependencyHloOrdering>(module),\n                &BufferSizeBytes, &alias_info_,\n                [alignment](LogicalBuffer::Color) { return alignment; },\n-               /*allocate_buffers_for_constants=*/false,\n-               /*colorer=*/BufferAssigner::DefaultColorer(),\n-               /*must_not_live_out=*/must_not_live_out)\n+               std::move(opts))\n         .value();\n   }\n \n   std::unique_ptr<BufferAssignment> RunColoredBufferAssignment(\n       HloModule* module, BufferAssigner::Colorer colorer,\n       int64_t alignment = 1) {\n+    BufferAssigner::Options opts;\n+    opts.allocate_buffers_for_constants = true;\n+    opts.colorer = std::move(colorer);\n     return BufferAssigner::Run(\n                module, std::make_unique<DependencyHloOrdering>(module),\n                &BufferSizeBytes, &alias_info_,\n                [alignment](LogicalBuffer::Color) { return alignment; },\n-               /*allocate_buffers_for_constants=*/true, std::move(colorer))\n+               std::move(opts))\n         .value();\n   }\n \n@@ -197,41 +207,41 @@ class BufferAssignmentTest : public HloHardwareIndependentTestBase {\n       int64_t alignment = 1) {\n     HloSchedule schedule(module);\n     schedule.set_sequence(module->entry_computation(), instruction_sequence);\n+    BufferAssigner::Options opts;\n+    opts.allocate_buffers_for_constants = true;\n     return BufferAssigner::Run(\n                module, std::make_unique<SequentialHloOrdering>(schedule),\n                &BufferSizeBytes, &alias_info_,\n                [alignment](LogicalBuffer::Color) { return alignment; },\n-               /*allocate_buffers_for_constants=*/true)\n+               std::move(opts))\n         .value();\n   }\n \n   std::unique_ptr<BufferAssignment> RunBufferAssignmentWithPresetAssignments(\n       HloModule* module, std::unique_ptr<PresetAssignments> preset_assignments,\n       int64_t alignment = 1) {\n+    BufferAssigner::Options opts;\n+    opts.allocate_buffers_for_constants = true;\n+    opts.preset_assignments = std::move(preset_assignments);\n     return BufferAssigner::Run(\n                module, std::make_unique<DependencyHloOrdering>(module),\n                &BufferSizeBytes, &alias_info_,\n                [alignment](LogicalBuffer::Color) { return alignment; },\n-               /*allocate_buffers_for_constants=*/true,\n-               BufferAssigner::DefaultColorer(),\n-               /*must_not_live_out=*/std::nullopt,\n-               std::move(preset_assignments))\n+               std::move(opts))\n         .value();\n   }\n \n   std::unique_ptr<BufferAssignment> RunBufferAssignmentWithIsolationOptions(\n       HloModule* module, std::optional<BufferAssignment::BufferIsolationOptions>\n                              isolation_options = std::nullopt) {\n+    BufferAssigner::Options opts;\n+    opts.allocate_buffers_for_constants = true;\n+    opts.isolation_options = isolation_options;\n     return BufferAssigner::Run(\n                module,\n                std::make_unique<SequentialHloOrdering>(module->schedule()),\n                &BufferSizeBytes, &alias_info_,\n-               [](LogicalBuffer::Color) { return 1; },\n-               /*allocate_buffers_for_constants=*/true,\n-               BufferAssigner::DefaultColorer(),\n-               /*must_not_live_out=*/std::nullopt,\n-               /*preset_assignments=*/{}, /*private_stacks=*/{},\n-               /*heap_buffer_interval_compare=*/nullptr, isolation_options)\n+               [](LogicalBuffer::Color) { return 1; }, std::move(opts))\n         .value();\n   }\n \n@@ -2413,11 +2423,13 @@ class WhileBufferAssignmentTest : public HloHardwareIndependentTestBase {\n                                                         int64_t alignment = 1) {\n     HloSchedule schedule =\n         ScheduleModule(module, &alias_info_, ByteSizeOf).value();\n+    BufferAssigner::Options opts;\n+    opts.allocate_buffers_for_constants = true;\n     return BufferAssigner::Run(\n                module, std::make_unique<SequentialHloOrdering>(schedule),\n                ByteSizeOf, &alias_info_,\n                [alignment](LogicalBuffer::Color) { return alignment; },\n-               /*allocate_buffers_for_constants=*/true)\n+               std::move(opts))\n         .value();\n   }\n \n@@ -2735,13 +2747,14 @@ TEST_F(WhileBufferAssignmentTest, ColocatedBuffers) {\n       {token, infeed, infeed_data, while0, while1, zero, add, while2, tuple});\n   TF_ASSERT_OK(schedule.Verify());\n \n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   TF_ASSERT_OK_AND_ASSIGN(\n       auto assignment,\n       BufferAssigner::Run(\n           module.get(), std::make_unique<SequentialHloOrdering>(schedule),\n           &BufferSizeBytes, &alias_info_,\n-          [](LogicalBuffer::Color) { return 1; },\n-          /*allocate_buffers_for_constants=*/true));\n+          [](LogicalBuffer::Color) { return 1; }, std::move(opts)));\n \n   // The result tuple elements must be assigned with different buffers.\n   TF_ASSERT_OK_AND_ASSIGN(auto slice0, assignment->GetUniqueSlice(tuple, {0}));\n@@ -3470,11 +3483,13 @@ TEST_F(WhileBufferAssignmentTest, WhileLoopsInterferingResultRange) {\n   // itself is buggy.\n   TF_ASSERT_OK(schedule.Verify());\n \n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   auto assignment =\n       BufferAssigner::Run(\n           module.get(), std::make_unique<SequentialHloOrdering>(schedule),\n           ByteSizeOf, &alias_info_, [](LogicalBuffer::Color) { return 1; },\n-          /*allocate_buffers_for_constants=*/true)\n+          std::move(opts))\n           .value();\n \n   EXPECT_TRUE(BuffersDistinct({while0}, {while1}, *assignment));"
        },
        {
            "sha": "895657789c891fd6c840f80713447ab1d53702bd",
            "filename": "third_party/xla/xla/service/cpu/cpu_compiler.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fcpu_compiler.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -2352,10 +2352,12 @@ absl::StatusOr<std::unique_ptr<BufferAssignment>>\n CpuCompiler::CreateBufferAssignment(const HloModule& module) const {\n   // Run buffer allocation on the HLO graph.\n   AliasInfo alias_info;\n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   return BufferAssigner::Run(\n       &module, std::make_unique<SequentialHloOrdering>(module.schedule()),\n       BufferSizeBytesFunction(), &alias_info, memory_alignment,\n-      /*allocate_buffers_for_constants=*/true);\n+      std::move(opts));\n }\n \n }  // namespace cpu"
        },
        {
            "sha": "02657508e4f9ce5e04412a2911dc1b850536e0fb",
            "filename": "third_party/xla/xla/service/cpu/ir_emitter_test.cc",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fir_emitter_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fir_emitter_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fir_emitter_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -117,7 +117,8 @@ TEST_F(IrEmitterTest, ComputeFuncStack) {\n           [](const BufferValue& buffer) {\n             return ShapeUtil::ByteSizeOf(buffer.shape(), sizeof(void*));\n           },\n-          &alias_info, [](LogicalBuffer::Color) { return /*alignment=*/1; }));\n+          &alias_info, [](LogicalBuffer::Color) { return /*alignment=*/1; },\n+          BufferAssigner::Options{}));\n \n   TargetMachineFeaturesStub target_machine([](int64_t size) { return 1; });\n \n@@ -290,12 +291,14 @@ CreateIrEmitterForConstantEmissionTests(HloModule& module,\n \n   auto memory_alignment = [](LogicalBuffer::Color) { return MinAlign(); };\n   // Run buffer allocation on the HLO graph.\n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   TF_ASSIGN_OR_RETURN(\n       std::unique_ptr<BufferAssignment> assignment,\n-      BufferAssigner::Run(\n-          &module, std::make_unique<SequentialHloOrdering>(schedule),\n-          buffer_size_bytes_function, &alias_info, memory_alignment,\n-          /*allocate_buffers_for_constants=*/true));\n+      BufferAssigner::Run(&module,\n+                          std::make_unique<SequentialHloOrdering>(schedule),\n+                          buffer_size_bytes_function, &alias_info,\n+                          memory_alignment, std::move(opts)));\n \n   auto target_machine_features =\n       std::make_unique<TargetMachineFeatures>(jit_compiler.target_machine());"
        },
        {
            "sha": "773c9fe88726625fd94812f341192877cb5b25cc",
            "filename": "third_party/xla/xla/service/cpu/scoped_ir_builder_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fscoped_ir_builder_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fscoped_ir_builder_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Fscoped_ir_builder_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -52,7 +52,8 @@ class IRBuilderGuardTest : public HloHardwareIndependentTestBase {\n             [](const BufferValue& buffer) {\n               return CpuExecutable::ShapeSizeBytes(buffer.shape());\n             },\n-            &alias_info_, [](LogicalBuffer::Color) { return /*alignment=*/1; })\n+            &alias_info_, [](LogicalBuffer::Color) { return /*alignment=*/1; },\n+            BufferAssigner::Options{})\n             .value();\n \n     TargetMachineFeaturesStub target_machine([](int64_t size) { return 1; });"
        },
        {
            "sha": "8d79d54d8256ec7ca5758b45b156336b3d7c3b56",
            "filename": "third_party/xla/xla/service/cpu/tests/cpu_noalias_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Ftests%2Fcpu_noalias_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Ftests%2Fcpu_noalias_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fcpu%2Ftests%2Fcpu_noalias_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -81,7 +81,8 @@ TEST_F(CpuNoAliasTest, Concat) {\n       hlo_module.get(),\n       std::make_unique<DependencyHloOrdering>(hlo_module.get()),\n       backend().compiler()->BufferSizeBytesFunction(), &alias_info,\n-      [](LogicalBuffer::Color) { return /*alignment=*/1; });\n+      [](LogicalBuffer::Color) { return /*alignment=*/1; },\n+      BufferAssigner::Options{});\n   ASSERT_EQ(status_or_buffer_assn.status(), absl::OkStatus());\n \n   llvm::LLVMContext context;"
        },
        {
            "sha": "b3bf5ef9096159d23e5d7d16ca6ac6f2b42f84f3",
            "filename": "third_party/xla/xla/service/dump_test.cc",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fdump_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fdump_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fdump_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -19,6 +19,7 @@ limitations under the License.\n \n #include <memory>\n #include <string>\n+#include <utility>\n #include <vector>\n \n #include <gmock/gmock.h>\n@@ -135,6 +136,8 @@ TEST(DumpHloModule, WithBufferAssignment) {\n   TF_ASSERT_OK_AND_ASSIGN(std::unique_ptr<HloModule> m,\n                           ParseAndReturnUnverifiedModule(kModuleStr, config));\n   AliasInfo alias_info;\n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n   std::unique_ptr<BufferAssignment> buffer_assignment =\n       BufferAssigner::Run(\n           /*module=*/&*m,\n@@ -145,7 +148,7 @@ TEST(DumpHloModule, WithBufferAssignment) {\n           },\n           &alias_info,\n           /*color_alignment=*/[](LogicalBuffer::Color) -> int64_t { return 1; },\n-          /*allocate_buffers_for_constants=*/true)\n+          /*options=*/std::move(opts))\n           .value();\n   std::string dump_name = \"dump\";\n   std::vector<std::string> paths ="
        },
        {
            "sha": "2d151d1d1385cbc28e4b2013189ac63d8e28295b",
            "filename": "third_party/xla/xla/service/gpu/compile_module_to_llvm_ir.cc",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fcompile_module_to_llvm_ir.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fcompile_module_to_llvm_ir.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fcompile_module_to_llvm_ir.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -206,19 +206,18 @@ absl::StatusOr<std::unique_ptr<BufferAssignment>> RunBufferAssignment(\n                 (int)MemorySpaceColor::kTempBuffer)\n           : std::nullopt;\n \n+  BufferAssigner::Options opts;\n+  opts.allocate_buffers_for_constants = true;\n+  opts.colorer = CreateColorer(options);\n+  opts.temp_buffer_color = color;\n   TF_ASSIGN_OR_RETURN(\n       std::unique_ptr<BufferAssignment> buffer_assignment,\n       BufferAssigner::Run(\n           module, std::make_unique<SequentialHloOrdering>(module->schedule()),\n           std::move(buffer_size_bytes_function), alias_info,\n           /*color_alignment=*/\n           [](LogicalBuffer::Color) { return kXlaAllocatedBufferAlignBytes; },\n-          /*allocate_buffers_for_constants=*/true,\n-          /*colorer=*/CreateColorer(options),\n-          /*must_not_live_out=*/{},\n-          /*preset_assignments*/ {},\n-          /*private_stack*/ {}, /*heap_buffer_interval_compare*/ nullptr,\n-          /*isolation_options*/ std::nullopt, color));\n+          std::move(opts)));\n \n   VLOG(1) << \"Buffer Assignment Stats for \" << module->name() << \"\\n\"\n           << buffer_assignment->StatsString(alias_info);"
        },
        {
            "sha": "0d4a8ea870b57e810c40882559067f8f32f911fa",
            "filename": "third_party/xla/xla/service/gpu/gpu_executable_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_executable_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_executable_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fgpu_executable_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -258,7 +258,8 @@ MakeNonEmptyBufferAssignment() {\n           [](const BufferValue& buffer) {\n             return ShapeUtil::ByteSizeOf(buffer.shape(), sizeof(void*));\n           },\n-          &alias_info, [](LogicalBuffer::Color) { return /*alignment=*/1; }));\n+          &alias_info, [](LogicalBuffer::Color) { return /*alignment=*/1; },\n+          BufferAssigner::Options{}));\n   EXPECT_FALSE(buffer_assignment->Allocations().empty());\n   return buffer_assignment;\n }"
        },
        {
            "sha": "fe0469980f45ed1b42c66adfc5dd704ef0d26af8",
            "filename": "third_party/xla/xla/service/gpu/nvptx_compiler_test.cc",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fnvptx_compiler_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/afd3eb38c95e466194f445ef70b9b921243d6f19/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fnvptx_compiler_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Fservice%2Fgpu%2Fnvptx_compiler_test.cc?ref=afd3eb38c95e466194f445ef70b9b921243d6f19",
            "patch": "@@ -88,7 +88,8 @@ class NVPTXCompilerTest : public HloTestBase {\n         module, std::make_unique<SequentialHloOrdering>(module->schedule()),\n         buffer_size_bytes_function, alias_info.get(),\n         /*color_alignment=*/\n-        [](LogicalBuffer::Color) { return kXlaAllocatedBufferAlignBytes; });\n+        [](LogicalBuffer::Color) { return kXlaAllocatedBufferAlignBytes; },\n+        BufferAssigner::Options{});\n   }\n \n  protected:"
        }
    ],
    "stats": {
        "total": 290,
        "additions": 155,
        "deletions": 135
    }
}