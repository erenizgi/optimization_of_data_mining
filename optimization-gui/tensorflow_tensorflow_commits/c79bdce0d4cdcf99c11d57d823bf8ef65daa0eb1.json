{
    "author": "tensorflower-gardener",
    "message": "Automated Code Change\n\nPiperOrigin-RevId: 812377415",
    "sha": "c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1",
    "files": [
        {
            "sha": "903fcb0071e926e7c1becee511bde40a76247b95",
            "filename": "third_party/xla/xla/tsl/platform/cloud/expiring_lru_cache.h",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fexpiring_lru_cache.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fexpiring_lru_cache.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fexpiring_lru_cache.h?ref=c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1",
            "patch": "@@ -49,15 +49,15 @@ class ExpiringLRUCache {\n     if (max_age_ == 0) {\n       return;\n     }\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     InsertLocked(key, value);\n   }\n \n   // Delete the entry with key `key`. Return true if the entry was found for\n   // `key`, false if the entry was not found. In both cases, there is no entry\n   // with key `key` existed after the call.\n   bool Delete(const string& key) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     return DeleteLocked(key);\n   }\n \n@@ -68,7 +68,7 @@ class ExpiringLRUCache {\n     if (max_age_ == 0) {\n       return false;\n     }\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     return LookupLocked(key, value);\n   }\n \n@@ -84,22 +84,22 @@ class ExpiringLRUCache {\n     }\n \n     {\n-      absl::MutexLock lock(&mu_);\n+      absl::MutexLock lock(mu_);\n       if (LookupLocked(key, value)) {\n         return absl::OkStatus();\n       }\n     }\n     absl::Status s = compute_func(key, value);\n     if (s.ok()) {\n-      absl::MutexLock lock(&mu_);\n+      absl::MutexLock lock(mu_);\n       InsertLocked(key, *value);\n     }\n     return s;\n   }\n \n   /// Clear the cache.\n   void Clear() {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     cache_.clear();\n     lru_list_.clear();\n   }"
        },
        {
            "sha": "735a2fa663781ec6a6703586d1f16e3c335f6e2c",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_dns_cache.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.cc?ref=c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1",
            "patch": "@@ -66,7 +66,7 @@ GcsDnsCache::GcsDnsCache(Env* env, int64_t refresh_rate_secs)\n \n void GcsDnsCache::AnnotateRequest(HttpRequest* request) {\n   // TODO(saeta): Denylist failing IP addresses.\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   if (!started_) {\n     VLOG(1) << \"Starting GCS DNS cache.\";\n     DCHECK(!worker_) << \"Worker thread already exists!\";\n@@ -235,7 +235,7 @@ void GcsDnsCache::WorkerThread() {\n   while (true) {\n     {\n       // Don't immediately re-resolve the addresses.\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       if (cancelled_) return;\n       cond_var_.WaitWithTimeout(&mu_, absl::Seconds(refresh_rate_secs_));\n       if (cancelled_) return;\n@@ -245,7 +245,7 @@ void GcsDnsCache::WorkerThread() {\n     auto new_addresses = ResolveNames(kCachedDomainNames);\n \n     {\n-      absl::MutexLock l(&mu_);\n+      absl::MutexLock l(mu_);\n       // Update instance variables.\n       addresses_.swap(new_addresses);\n     }"
        },
        {
            "sha": "4b4f19935c42b368ff5ab99cac605ba50c880e89",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_dns_cache.h",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache.h?ref=c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1",
            "patch": "@@ -43,7 +43,7 @@ class GcsDnsCache {\n   GcsDnsCache(Env* env, int64_t refresh_rate_secs);\n \n   ~GcsDnsCache() {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     cancelled_ = true;\n     cond_var_.Signal();\n   }"
        },
        {
            "sha": "b2180666bb6b87566a123522fa991194af549fc1",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_dns_cache_test.cc",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache_test.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache_test.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_dns_cache_test.cc?ref=c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1",
            "patch": "@@ -77,7 +77,7 @@ class GcsDnsCacheTest : public ::testing::Test {\n   void AnnotateRequestTest() {\n     GcsDnsCache d;\n     {\n-      absl::MutexLock l(&d.mu_);\n+      absl::MutexLock l(d.mu_);\n       d.started_ = true;  // Avoid creating a thread.\n       d.addresses_ = {{\"192.168.1.1\"}, {\"172.134.1.1\"}};\n     }"
        },
        {
            "sha": "6f40b1eafbdb9e7bfc5601883df5f2701c41edc5",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_file_system.h",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_file_system.h?ref=c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1",
            "patch": "@@ -226,15 +226,15 @@ class GcsFileSystem : public FileSystem {\n   /// These accessors are mainly for testing purposes, to verify that the\n   /// environment variables that control these parameters are handled correctly.\n   size_t block_size() {\n-    absl::ReaderMutexLock l(&block_cache_lock_);\n+    absl::ReaderMutexLock l(block_cache_lock_);\n     return file_block_cache_->block_size();\n   }\n   size_t max_bytes() {\n-    absl::ReaderMutexLock l(&block_cache_lock_);\n+    absl::ReaderMutexLock l(block_cache_lock_);\n     return file_block_cache_->max_bytes();\n   }\n   uint64 max_staleness() {\n-    absl::ReaderMutexLock l(&block_cache_lock_);\n+    absl::ReaderMutexLock l(block_cache_lock_);\n     return file_block_cache_->max_staleness();\n   }\n   TimeoutConfig timeouts() const { return timeouts_; }"
        },
        {
            "sha": "ba890acf2addb8c301f876bf1aad5a75bbab294a",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_throttle.cc",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.cc?ref=c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1",
            "patch": "@@ -35,7 +35,7 @@ GcsThrottle::GcsThrottle(EnvTime* env_time)\n       env_time_(env_time ? env_time : get_default_env_time()) {}\n \n bool GcsThrottle::AdmitRequest() {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   UpdateState();\n   if (available_tokens_ < config_.tokens_per_request) {\n     return false || !config_.enabled;\n@@ -45,13 +45,13 @@ bool GcsThrottle::AdmitRequest() {\n }\n \n void GcsThrottle::RecordResponse(size_t num_bytes) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   UpdateState();\n   available_tokens_ -= request_bytes_to_tokens(num_bytes);\n }\n \n void GcsThrottle::SetConfig(GcsThrottleConfig config) {\n-  absl::MutexLock l(&mu_);\n+  absl::MutexLock l(mu_);\n   config_ = config;\n   available_tokens_ = config.initial_tokens;\n   last_updated_secs_ = env_time_->GetOverridableNowSeconds();"
        },
        {
            "sha": "454bdf505a47834820840637e3fb5ac451b73ea1",
            "filename": "third_party/xla/xla/tsl/platform/cloud/gcs_throttle.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fgcs_throttle.h?ref=c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1",
            "patch": "@@ -113,7 +113,7 @@ class GcsThrottle {\n    * instrumentation the number of available tokens in the pool.\n    */\n   inline int64_t available_tokens() TF_LOCKS_EXCLUDED(mu_) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     UpdateState();\n     return available_tokens_;\n   }\n@@ -126,7 +126,7 @@ class GcsThrottle {\n    * true.\n    */\n   bool is_enabled() TF_LOCKS_EXCLUDED(mu_) {\n-    absl::MutexLock l(&mu_);\n+    absl::MutexLock l(mu_);\n     return config_.enabled;\n   }\n "
        },
        {
            "sha": "32ba11e19d9aaf3e47a1db500230da79502e3ac0",
            "filename": "third_party/xla/xla/tsl/platform/cloud/now_seconds_env.h",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fnow_seconds_env.h",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fnow_seconds_env.h",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fnow_seconds_env.h?ref=c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1",
            "patch": "@@ -29,13 +29,13 @@ class NowSecondsEnv : public EnvWrapper {\n \n   /// The current (fake) timestamp.\n   uint64 NowSeconds() const override {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     return now_;\n   }\n \n   /// Set the current (fake) timestamp.\n   void SetNowSeconds(uint64 now) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     now_ = now;\n   }\n "
        },
        {
            "sha": "fc4b745a29e52185f88fbb911ec750cc301ff184",
            "filename": "third_party/xla/xla/tsl/platform/cloud/ram_file_block_cache.cc",
            "status": "modified",
            "additions": 12,
            "deletions": 12,
            "changes": 24,
            "blob_url": "https://github.com/tensorflow/tensorflow/blob/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache.cc",
            "raw_url": "https://github.com/tensorflow/tensorflow/raw/c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache.cc",
            "contents_url": "https://api.github.com/repos/tensorflow/tensorflow/contents/third_party%2Fxla%2Fxla%2Ftsl%2Fplatform%2Fcloud%2Fram_file_block_cache.cc?ref=c79bdce0d4cdcf99c11d57d823bf8ef65daa0eb1",
            "patch": "@@ -26,7 +26,7 @@ limitations under the License.\n namespace tsl {\n \n bool RamFileBlockCache::BlockNotStale(const std::shared_ptr<Block>& block) {\n-  absl::MutexLock l(&block->mu);\n+  absl::MutexLock l(block->mu);\n   if (block->state != FetchState::FINISHED) {\n     return true;  // No need to check for staleness.\n   }\n@@ -36,7 +36,7 @@ bool RamFileBlockCache::BlockNotStale(const std::shared_ptr<Block>& block) {\n \n std::shared_ptr<RamFileBlockCache::Block> RamFileBlockCache::Lookup(\n     const Key& key) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   auto entry = block_map_.find(key);\n   if (entry != block_map_.end()) {\n     if (BlockNotStale(entry->second)) {\n@@ -72,7 +72,7 @@ void RamFileBlockCache::Trim() {\n /// Move the block to the front of the LRU list if it isn't already there.\n absl::Status RamFileBlockCache::UpdateLRU(const Key& key,\n                                           const std::shared_ptr<Block>& block) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   if (block->timestamp == 0) {\n     // The block was evicted from another thread. Allow it to remain evicted.\n     return absl::OkStatus();\n@@ -108,7 +108,7 @@ absl::Status RamFileBlockCache::MaybeFetch(\n         // Perform this action in a cleanup callback to avoid locking mu_ after\n         // locking block->mu.\n         if (downloaded_block) {\n-          absl::MutexLock l(&mu_);\n+          absl::MutexLock l(mu_);\n           // Do not update state if the block is already to be evicted.\n           if (block->timestamp != 0) {\n             // Use capacity() instead of size() to account for all  memory\n@@ -124,15 +124,15 @@ absl::Status RamFileBlockCache::MaybeFetch(\n       });\n   // Loop until either block content is successfully fetched, or our request\n   // encounters an error.\n-  absl::MutexLock l(&block->mu);\n+  absl::MutexLock l(block->mu);\n   absl::Status status = absl::OkStatus();\n   while (true) {\n     switch (block->state) {\n       case FetchState::ERROR:\n         TF_FALLTHROUGH_INTENDED;\n       case FetchState::CREATED:\n         block->state = FetchState::FETCHING;\n-        block->mu.Unlock();  // Release the lock while making the API call.\n+        block->mu.unlock();  // Release the lock while making the API call.\n         block->data.clear();\n         block->data.resize(block_size_, 0);\n         size_t bytes_transferred;\n@@ -141,7 +141,7 @@ absl::Status RamFileBlockCache::MaybeFetch(\n         if (cache_stats_ != nullptr) {\n           cache_stats_->RecordCacheMissBlockSize(bytes_transferred);\n         }\n-        block->mu.Lock();  // Reacquire the lock immediately afterwards\n+        block->mu.lock();  // Reacquire the lock immediately afterwards\n         if (status.ok()) {\n           block->data.resize(bytes_transferred, 0);\n           // Shrink the data capacity to the actual size used.\n@@ -234,7 +234,7 @@ absl::Status RamFileBlockCache::Read(const string& filename, size_t offset,\n \n bool RamFileBlockCache::ValidateAndUpdateFileSignature(const string& filename,\n                                                        int64_t file_signature) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   auto it = file_signature_map_.find(filename);\n   if (it != file_signature_map_.end()) {\n     if (it->second == file_signature) {\n@@ -250,14 +250,14 @@ bool RamFileBlockCache::ValidateAndUpdateFileSignature(const string& filename,\n }\n \n size_t RamFileBlockCache::CacheSize() const {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   return cache_size_;\n }\n \n void RamFileBlockCache::Prune() {\n   while (\n       !stop_pruning_thread_.WaitForNotificationWithTimeout(absl::Seconds(1))) {\n-    absl::MutexLock lock(&mu_);\n+    absl::MutexLock lock(mu_);\n     uint64 now = env_->NowSeconds();\n     while (!lra_list_.empty()) {\n       auto it = block_map_.find(lra_list_.back());\n@@ -273,15 +273,15 @@ void RamFileBlockCache::Prune() {\n }\n \n void RamFileBlockCache::Flush() {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   block_map_.clear();\n   lru_list_.clear();\n   lra_list_.clear();\n   cache_size_ = 0;\n }\n \n void RamFileBlockCache::RemoveFile(const string& filename) {\n-  absl::MutexLock lock(&mu_);\n+  absl::MutexLock lock(mu_);\n   RemoveFile_Locked(filename);\n }\n "
        }
    ],
    "stats": {
        "total": 66,
        "additions": 33,
        "deletions": 33
    }
}